{"meta":{"title":"茶瓜客","subtitle":"解衣又作茶瓜客，倚槛同看烟雨峰","description":"解衣又作茶瓜客，倚槛同看烟雨峰","author":"茶瓜客","url":"https://www.chaguake.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-03-09T07:38:35.984Z","updated":"2021-03-09T05:57:02.612Z","comments":false,"path":"/404.html","permalink":"https://www.chaguake.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-07T08:50:40.413Z","updated":"2021-09-07T08:50:40.413Z","comments":true,"path":"about/index.html","permalink":"https://www.chaguake.com/about/index.html","excerpt":"","text":"性别男，26岁，3年C++后台开发岗位经验。 接触图形学之后，被图形渲染领域技术所吸引，如今在努力学习图形渲染方面知识。"},{"title":"书单","date":"2021-03-11T03:27:43.709Z","updated":"2021-03-11T03:27:43.709Z","comments":true,"path":"books/index.html","permalink":"https://www.chaguake.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-03-09T07:36:46.388Z","updated":"2021-03-09T05:57:02.612Z","comments":false,"path":"categories/index.html","permalink":"https://www.chaguake.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-03-09T06:20:35.606Z","updated":"2021-03-09T05:57:02.612Z","comments":true,"path":"links/index.html","permalink":"https://www.chaguake.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-03-11T03:28:04.838Z","updated":"2021-03-11T03:28:04.838Z","comments":true,"path":"repository/index.html","permalink":"https://www.chaguake.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-09T07:36:46.388Z","updated":"2021-03-09T05:57:02.612Z","comments":false,"path":"tags/index.html","permalink":"https://www.chaguake.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"细分着色器01——OpenGL的细分着色","slug":"Subdivision01","date":"2021-09-10T00:42:32.000Z","updated":"2021-09-10T00:45:01.671Z","comments":true,"path":"2021/09/10/Subdivision01/","link":"","permalink":"https://www.chaguake.com/2021/09/10/Subdivision01/","excerpt":"","text":"细分着色器01 细分着色器在 《OpenGL编程指南（第九版）》的第9章中，介绍了细分着色器的两个处理阶段——细分控制和细分计算，这两个分别对应各自的着色器。 细分控制着色器细分控制着色器可以控制输出面片的细分程度，OpenGl支持三种不同的细分域：四边形、三角形以及等值线集合。 而细分总量是通过两组数据来控制：内侧和外侧细分层级。外侧细分层级控制细分区域的周长，保存在4个元素的数组 gl_TessLevelOuter 中。内侧细分层级设置细分区域内部划分方式，保存在2个元素的数组 gl_TessLevelInner 中。 四边形细分 四边形细分使用数组 gl_TessLevelOuter 和 gl_TessLevelInner 所有元素。 1234567gl_TessLevelInner[0] &#x3D; 3.0;gl_TessLevelInner[1] &#x3D; 4.0;gl_TessLevelOuter[0] &#x3D; 2.0;gl_TessLevelOuter[1] &#x3D; 3.0;gl_TessLevelOuter[2] &#x3D; 2.0;gl_TessLevelOuter[3] &#x3D; 4.0; 四边形细分 三角形细分 三角形细分只使用数组 gl_TessLevelOuter 前三个元素，使用数组 gl_TessLevelInner 第一个元素。 12345gl_TessLevelInner[0] &#x3D; 5.0;gl_TessLevelOuter[0] &#x3D; 6.0;gl_TessLevelOuter[1] &#x3D; 5.0;gl_TessLevelOuter[2] &#x3D; 8.0; 而且，内侧细分层级数值的奇偶性对细分形式有影响。当内侧细分层级数值为奇数时，会在三角形细分域的中心创建一个小三角形；当内侧细分层级数值为偶数时，则会在其中心创建一个独立的细分坐标。 三角形细分 细分计算着色器细分计算着色器使用 layout 布局限定符来设置图元类型（quads、triangles 以及 isolines，对应细分控制着色器的细分域类型）、图元的面朝向（cw、ccw，顺时针和逆时针）等等。 在细分计算着色器中的内置变量主要使用 gl_TessCoord 变量来获取细分顶点的局部坐标。 四边形细分可以使用插值计算或贝塞尔曲面来实现顶点位置的计算。 贝塞尔曲面计算： 123456789101112131415161718192021222324252627282930313233343536#version 400 corelayout (quads, equal_spacing, ccw) in;uniform mat4 projection;uniform mat4 view;uniform mat4 model;&#x2F;&#x2F;----------------------------------------------------------------------------floatB( int i, float u )&#123; const vec4 bc &#x3D; vec4( 1, 3, 3, 1 ); return bc[i] * pow( u, i ) * pow( 1.0 - u, 3 - i ); &#125;&#x2F;&#x2F;----------------------------------------------------------------------------voidmain()&#123; vec4 pos &#x3D; vec4( 0.0 ); float u &#x3D; gl_TessCoord.x; float v &#x3D; gl_TessCoord.y; for ( int j &#x3D; 0; j &lt; 4; ++j ) &#123; for ( int i &#x3D; 0; i &lt; 4; ++i ) &#123; pos +&#x3D; B( i, u ) * B( j, v ) * gl_in[4*j+i].gl_Position; &#125; &#125; gl_Position &#x3D; projection * view * model * pos;&#125; 三角形细分可以使用三角形的重心坐标公式来计算顶点位置。 123456789101112131415161718192021222324#version 400 corelayout (triangles, equal_spacing, cw) in;uniform mat4 projection;uniform mat4 view;uniform mat4 model;&#x2F;&#x2F;----------------------------------------------------------------------------voidmain()&#123; vec4 pos &#x3D; vec4( 0.0 ); float u &#x3D; gl_TessCoord.x; float v &#x3D; gl_TessCoord.y; pos &#x3D; u * gl_in[0].gl_Position + v * gl_in[1].gl_Position + (1.0 - u - v) * gl_in[2].gl_Position; gl_Position &#x3D; projection * view * model * pos;&#125; 茶壶实例在 《OpenGL编程指南（第九版）》中的茶壶实例只有一半的坐标，它采用四边形细分，4x4个顶点的贝塞尔曲面计算顶点位置。可以看到随着细分层次变大，茶壶的形状也变得圆滑。 茶壶实例 在茶壶实例的细分计算着色器中，B 函数为简单地伯恩斯坦多项式的实现。 立方体实例 立方体实例","categories":[{"name":"图形学","slug":"图形学","permalink":"https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/tags/OpenGL/"}]},{"title":"LearnRayTracing01——并行处理像素点计算","slug":"LearnRayTracing01","date":"2021-09-08T05:42:48.000Z","updated":"2021-09-08T05:45:35.859Z","comments":true,"path":"2021/09/08/LearnRayTracing01/","link":"","permalink":"https://www.chaguake.com/2021/09/08/LearnRayTracing01/","excerpt":"","text":"LearnRayTracing01 前言在学习 Ray Tracing in One Weekend Book Series 中第一章 Ray Tracing in One Weekend 的时候，感觉在原代码中输出结果上并不能实时预览，而且也没有多线程并发渲染。 结合之前学习 LearnOpenGL 的教程，可以将原来的颜色数据当作纹理渲染到窗口上。参考代码在这里。 正文首先，在 Ray Tracing in One Weekend 中可以看到，像素是从上往下、从左到右来处理的。所以在 while (!glfwWindowShouldClose(window)) 这个渲染循环中，需要实时更新texture的数据。那么，使用到 glTexSubImage2D 这个API。 12glBindTexture(GL_TEXTURE_2D, texture); glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, data); 现在，就只用关心 data 变量的值计算填充了。 原来渲染代码片段如下： 12345678910111213for (int j &#x3D; image_height-1; j &gt;&#x3D; 0; --j) &#123; std::cerr &lt;&lt; &quot;\\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; std::flush; for (int i &#x3D; 0; i &lt; image_width; ++i) &#123; color pixel_color(0,0,0); for (int s &#x3D; 0; s &lt; samples_per_pixel; ++s) &#123; auto u &#x3D; (i + random_double()) &#x2F; (image_width-1); auto v &#x3D; (j + random_double()) &#x2F; (image_height-1); ray r &#x3D; cam.get_ray(u, v); pixel_color +&#x3D; ray_color(r, world, max_depth); &#125; write_color(std::cout, pixel_color, samples_per_pixel); &#125;&#125; 现在，从原来 write_color 中将数据输出到 std::cout 变成输出到 data 变量。代码片段如下： 12345678910for (int j &#x3D; SCR_HEIGHT - 1; j &gt;&#x3D; 0; --j) &#123; std::cerr &lt;&lt; &quot;\\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; std::flush; std::vector&lt;std::shared_ptr&lt;std::future&lt;void&gt;&gt;&gt; list; for (int i &#x3D; 0; i &lt; SCR_WIDTH; ++i) &#123; std::shared_ptr&lt;std::future&lt;void&gt;&gt; ptr &#x3D; std::make_shared&lt;std::future&lt;void&gt;&gt;(std::async(render_color, world, cam, samples_per_pixel, max_depth, i, j)); list.push_back(ptr); &#x2F;&#x2F;render_color(world, cam, samples_per_pixel, max_depth, i, j); &#125; deal_future(list);&#125; 将对每个像素的操作封装到 render_color 函数中。然后使用C++关键字 std::future 来封存每个像素处理得状态，将一行像素的操作先推进容器 std::vector 中，然后再一起处理（其实就是 std::future::wait 函数的调用）。 当然，在对每个future对象遍历调用 wait 函数时，还可以使用 OpenMP 的特性。使得每个for子循环并行处理。 1234567void deal_future(std::vector&lt;std::shared_ptr&lt;std::future&lt;void&gt;&gt;&gt; &amp;list)&#123;#pragma omp parallel for schedule(dynamic, 1) for (int i &#x3D; 0; i &lt; list.size(); i++)&#123; list[i]-&gt;wait(); &#125;&#125; 最终，渲染一张1600x900的照片只需392s（GTX 1050），而原来需要2075s。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"https://www.chaguake.com/tags/Ray-Tracing/"}]},{"title":"译文：Ray Marching and Signed Distance Functions","slug":"RayMarchingAndSDF","date":"2021-09-07T08:00:39.000Z","updated":"2021-09-08T05:50:12.903Z","comments":true,"path":"2021/09/07/RayMarchingAndSDF/","link":"","permalink":"https://www.chaguake.com/2021/09/07/RayMarchingAndSDF/","excerpt":"","text":"原文 Signed Distance FunctionsSDF，符号距离函数，用于计算点和平面的位置关系，根据返回值的符号，来判断点是在平面内部还是外部。 （原文这里使用了一个圆心在原点、半径为1的球体做示例。） 对一些常见的3D物体的SDF函数，参见Modeling with Distance Functions。 The Raymarching Algorithm与光线跟踪一样，我们为相机选择一个位置，在其前面放置一个网格，通过网格中的每个点从相机发送光线，每个网格点对应于输出图像中的一个像素。 From \"Ray tracing\" on Wikipedia 在光线跟踪中，整个场景是根据有符号距离函数定义的。使用SDF可以快速而安全地让光线前进最大步伐（maximum step），直至物体表面（surface）。 如图，$p_0$ 是摄像机。蓝色线段是从摄像机穿过视图平面的光线。 From [GPU Gems 2: Chapter 8.](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-8-pixel-displacement-mapping-distance-functions) 在GLSL的伪代码如下： 12345678910111213141516float depth &#x3D; start;for (int i &#x3D; 0; i &lt; MAX_MARCHING_STEPS; i++) &#123; float dist &#x3D; sceneSDF(eye + depth * viewRayDirection); if (dist &lt; EPSILON) &#123; &#x2F;&#x2F; We&#39;re inside the scene surface! return depth; &#125; &#x2F;&#x2F; Move along the view ray depth +&#x3D; dist; if (depth &gt;&#x3D; end) &#123; &#x2F;&#x2F; Gone too far; give up return end; &#125;&#125;return end; 其实就是每次前进当前光点与球表面的距离，知道值小于0.001。 shadertoy：Ray Marching: Part 1。 Surface Normals and Lighting计算机图形学中的大多数照明模型都使用曲面法线的一些概念来计算曲面上给定点处材质的颜色。当曲面由显式几何体（如多边形）定义时，通常会为每个顶点指定法线，并且可以通过插值周围顶点法线找到面上任何给定点的法线。 在使用SDF时，用梯度（gradient）来定义曲面法线。在点 $(x,y,z)$ 上的梯度函数 $f$ ，表示的是沿着某个方向，使得移动点 $(x,y,z)$ 变化最快的值。 $f(x,y,z)$ 的梯度写作 $\\nabla f$ 。 \\nabla f = \\left( \\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z} \\right)但是没有必要在这里进行微积分运算。我们将通过采样曲面上点周围的点来进行近似，而不是取函数的实导数，这很像在学习如何进行导数之前，如何计算函数中的斜率。 \\overset{\\to}{n} = \\begin{bmatrix} f(x + \\varepsilon,y,z) - f(x - \\varepsilon,y,z) \\\\ f(x ,y+ \\varepsilon,z) - f(x,y - \\varepsilon,z) \\\\ f(x ,y,z+ \\varepsilon) - f(x ,y,z- \\varepsilon) \\end{bmatrix}GLSL的代码： 12345678910&#x2F;** * Using the gradient of the SDF, estimate the normal on the surface at point p. *&#x2F;vec3 estimateNormal(vec3 p) &#123; return normalize(vec3( sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)), sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)), sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)) ));&#125; shadertoy：Ray Marching: Part 2。 Moving the Camera在GLSL中，实现类似gluLookAt函数的功能，提供一个变换矩阵。 123456789101112131415161718&#x2F;** * Return a transformation matrix that will transform a ray from view space * to world coordinates, given the eye point, the camera target, and an up vector. * * This assumes that the center of the camera is aligned with the negative z axis in * view space when calculating the ray marching direction. *&#x2F;mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) &#123; vec3 f &#x3D; normalize(center - eye); vec3 s &#x3D; normalize(cross(f, up)); vec3 u &#x3D; cross(s, f); return mat4( vec4(s, 0.0), vec4(u, 0.0), vec4(-f, 0.0), vec4(0.0, 0.0, 0.0, 1) );&#125; shadertoy：Ray Marching: Part 3。 Constructive Solid GeometryCSG，构建实体几何，使用简单几何体通过集合运算得到的复杂几何体。集合运算有交集（intersection）、并集（union）以及差集（difference）。 From \"Constructive solid geometry\" on Wikipedia 当组合表示为SDF的两个曲面时，这些操作都可以简洁地表达。 1234567891011float intersectSDF(float distA, float distB) &#123; return max(distA, distB);&#125;float unionSDF(float distA, float distB) &#123; return min(distA, distB);&#125;float differenceSDF(float distA, float distB) &#123; return max(distA, -distB);&#125; 几何体组合函数如下： 12345float sceneSDF(vec3 samplePoint) &#123; float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2; float cubeDist &#x3D; cubeSDF(samplePoint) * 1.2; return intersectSDF(cubeDist, sphereDist);&#125; shadertoy：Ray Marching: Part 4。 Model TransformationsRotation and Translation 对一个SDF表面进行平移或变换，可以在计算SDF之前对这个点进行逆变换。 12345float sceneSDF(vec3 samplePoint) &#123; float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2; float cubeDist &#x3D; cubeSDF(samplePoint + vec3(0.0, sin(iGlobalTime), 0.0)); return intersectSDF(cubeDist, sphereDist);&#125; shadertoy：Ray Marching: Part 5。 进一步来说，添加一个旋转矩阵： 1234567891011121314151617181920mat4 rotateY(float theta) &#123; float c &#x3D; cos(theta); float s &#x3D; sin(theta); return mat4( vec4(c, 0, s, 0), vec4(0, 1, 0, 0), vec4(-s, 0, c, 0), vec4(0, 0, 0, 1) );&#125;float sceneSDF(vec3 samplePoint) &#123; float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2; vec3 cubePoint &#x3D; (invert(rotateY(iGlobalTime)) * vec4(samplePoint, 1.0)).xyz; float cubeDist &#x3D; cubeSDF(cubePoint); return intersectSDF(cubeDist, sphereDist);&#125; 应用到sceneSDF函数就是： 12345678float sceneSDF(vec3 samplePoint) &#123; float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2; vec3 cubePoint &#x3D; (rotateY(-iGlobalTime) * vec4(samplePoint, 1.0)).xyz; float cubeDist &#x3D; cubeSDF(cubePoint); return intersectSDF(cubeDist, sphereDist);&#125; Uniform Scaling 缩放会改变两点之间的距离，引起距离场失真。 所以在缩放之后的点，经过SDF判断之后，需要对结果进行校准。 1float dist &#x3D; someSDF(samplePoint &#x2F; scalingFactor) * scalingFactor; Non-uniform scaling and beyond 首先计算下不均匀变换时导致的失真值： sphereSDF(x,y,z) = \\sqrt{(2x)^2 + y ^2 +z^2} - 1经过变换之后，可以乘以他们之间最小值： 1float dist &#x3D; someSDF(samplePoint &#x2F; vec3(s_x, s_y, s_z)) * min(s_x, min(s_y, s_z)); shadertoy：Ray Marching: Part 6。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"SDF","slug":"SDF","permalink":"https://www.chaguake.com/tags/SDF/"}]},{"title":"smallpt：经典光线追踪实现（C++）","slug":"smallpt-classic-ray-tracing-for-c-plus","date":"2021-09-03T07:09:07.000Z","updated":"2021-09-07T08:07:36.114Z","comments":true,"path":"2021/09/03/smallpt-classic-ray-tracing-for-c-plus/","link":"","permalink":"https://www.chaguake.com/2021/09/03/smallpt-classic-ray-tracing-for-c-plus/","excerpt":"","text":"原文：http://www.kevinbeason.com/smallpt/ 翻译：https://samuel92.blog.csdn.net/article/details/108189198 文章：https://zhuanlan.zhihu.com/p/148759248 global illumination renderer smallpt 是一个全局光照渲染器，基于无偏蒙特卡洛路径追踪算法。 首先，蒙特卡洛路径追踪算法知识可看GAMES101教程的第16节。然后，无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。 一、特征 基于无偏蒙特卡罗路径跟踪的全局照明。 多线程使用OpenMP。 漫反射的软阴影。 镜面反射、漫反射和玻璃BRDF。 通过重要性采样的超采样（2x2子像素）来抗锯齿。 射线球交点。 场景使用改进的Cornell box。 半球漫反射的余弦重要性采样。 俄罗斯轮盘赌实现路径终止。 俄罗斯轮盘赌和分割，用于选择玻璃BRDF的反射和（或）折射。 显式灯光采样和非分支光线树。 CUDA和BSGP的端口具有交互式显示和场景编辑功能。 二、源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;math.h&gt; &#x2F;&#x2F; smallpt, a Path Tracer by Kevin Beason, 2008#include &lt;stdlib.h&gt; &#x2F;&#x2F; Make : g++ -O3 -fopenmp smallpt.cpp -o smallpt#include &lt;stdio.h&gt; &#x2F;&#x2F; Remove &quot;-fopenmp&quot; for g++ version &lt; 4.2struct Vec &#123; &#x2F;&#x2F; Usage: time .&#x2F;smallpt 5000 &amp;&amp; xv image.ppm double x, y, z; &#x2F;&#x2F; position, also color (r,g,b) Vec(double x_&#x3D;0, double y_&#x3D;0, double z_&#x3D;0)&#123; x&#x3D;x_; y&#x3D;y_; z&#x3D;z_; &#125; Vec operator+(const Vec &amp;b) const &#123; return Vec(x+b.x,y+b.y,z+b.z); &#125; Vec operator-(const Vec &amp;b) const &#123; return Vec(x-b.x,y-b.y,z-b.z); &#125; Vec operator*(double b) const &#123; return Vec(x*b,y*b,z*b); &#125; Vec mult(const Vec &amp;b) const &#123; return Vec(x*b.x,y*b.y,z*b.z); &#125; Vec&amp; norm()&#123; return *this &#x3D; *this * (1&#x2F;sqrt(x*x+y*y+z*z)); &#125; double dot(const Vec &amp;b) const &#123; return x*b.x+y*b.y+z*b.z; &#125; &#x2F;&#x2F; cross: Vec operator%(Vec&amp;b)&#123;return Vec(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);&#125;&#125;;struct Ray &#123; Vec o, d; Ray(Vec o_, Vec d_) : o(o_), d(d_) &#123;&#125; &#125;;enum Refl_t &#123; DIFF, SPEC, REFR &#125;; &#x2F;&#x2F; material types, used in radiance()struct Sphere &#123; double rad; &#x2F;&#x2F; radius Vec p, e, c; &#x2F;&#x2F; position, emission, color Refl_t refl; &#x2F;&#x2F; reflection type (DIFFuse, SPECular, REFRactive) Sphere(double rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_): rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125; double intersect(const Ray &amp;r) const &#123; &#x2F;&#x2F; returns distance, 0 if nohit Vec op &#x3D; p-r.o; &#x2F;&#x2F; Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 &#x3D; 0 double t, eps&#x3D;1e-4, b&#x3D;op.dot(r.d), det&#x3D;b*b-op.dot(op)+rad*rad; if (det&lt;0) return 0; else det&#x3D;sqrt(det); return (t&#x3D;b-det)&gt;eps ? t : ((t&#x3D;b+det)&gt;eps ? t : 0); &#125;&#125;;Sphere spheres[] &#x3D; &#123;&#x2F;&#x2F;Scene: radius, position, emission, color, material Sphere(1e5, Vec( 1e5+1,40.8,81.6), Vec(),Vec(.75,.25,.25),DIFF),&#x2F;&#x2F;Left Sphere(1e5, Vec(-1e5+99,40.8,81.6),Vec(),Vec(.25,.25,.75),DIFF),&#x2F;&#x2F;Rght Sphere(1e5, Vec(50,40.8, 1e5), Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Back Sphere(1e5, Vec(50,40.8,-1e5+170), Vec(),Vec(), DIFF),&#x2F;&#x2F;Frnt Sphere(1e5, Vec(50, 1e5, 81.6), Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Botm Sphere(1e5, Vec(50,-1e5+81.6,81.6),Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Top Sphere(16.5,Vec(27,16.5,47), Vec(),Vec(1,1,1)*.999, SPEC),&#x2F;&#x2F;Mirr Sphere(16.5,Vec(73,16.5,78), Vec(),Vec(1,1,1)*.999, REFR),&#x2F;&#x2F;Glas Sphere(600, Vec(50,681.6-.27,81.6),Vec(12,12,12), Vec(), DIFF) &#x2F;&#x2F;Lite&#125;;inline double clamp(double x)&#123; return x&lt;0 ? 0 : x&gt;1 ? 1 : x; &#125;inline int toInt(double x)&#123; return int(pow(clamp(x),1&#x2F;2.2)*255+.5); &#125;inline bool intersect(const Ray &amp;r, double &amp;t, int &amp;id)&#123; double n&#x3D;sizeof(spheres)&#x2F;sizeof(Sphere), d, inf&#x3D;t&#x3D;1e20; for(int i&#x3D;int(n);i--;) if((d&#x3D;spheres[i].intersect(r))&amp;&amp;d&lt;t)&#123;t&#x3D;d;id&#x3D;i;&#125; return t&lt;inf;&#125;Vec radiance(const Ray &amp;r, int depth, unsigned short *Xi)&#123; double t; &#x2F;&#x2F; distance to intersection int id&#x3D;0; &#x2F;&#x2F; id of intersected object if (!intersect(r, t, id)) return Vec(); &#x2F;&#x2F; if miss, return black const Sphere &amp;obj &#x3D; spheres[id]; &#x2F;&#x2F; the hit object Vec x&#x3D;r.o+r.d*t, n&#x3D;(x-obj.p).norm(), nl&#x3D;n.dot(r.d)&lt;0?n:n*-1, f&#x3D;obj.c; double p &#x3D; f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; &#x2F;&#x2F; max refl if (++depth&gt;5) if (erand48(Xi)&lt;p) f&#x3D;f*(1&#x2F;p); else return obj.e; &#x2F;&#x2F;R.R. if (obj.refl &#x3D;&#x3D; DIFF)&#123; &#x2F;&#x2F; Ideal DIFFUSE reflection double r1&#x3D;2*M_PI*erand48(Xi), r2&#x3D;erand48(Xi), r2s&#x3D;sqrt(r2); Vec w&#x3D;nl, u&#x3D;((fabs(w.x)&gt;.1?Vec(0,1):Vec(1))%w).norm(), v&#x3D;w%u; Vec d &#x3D; (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1-r2)).norm(); return obj.e + f.mult(radiance(Ray(x,d),depth,Xi)); &#125; else if (obj.refl &#x3D;&#x3D; SPEC) &#x2F;&#x2F; Ideal SPECULAR reflection return obj.e + f.mult(radiance(Ray(x,r.d-n*2*n.dot(r.d)),depth,Xi)); Ray reflRay(x, r.d-n*2*n.dot(r.d)); &#x2F;&#x2F; Ideal dielectric REFRACTION bool into &#x3D; n.dot(nl)&gt;0; &#x2F;&#x2F; Ray from outside going in? double nc&#x3D;1, nt&#x3D;1.5, nnt&#x3D;into?nc&#x2F;nt:nt&#x2F;nc, ddn&#x3D;r.d.dot(nl), cos2t; if ((cos2t&#x3D;1-nnt*nnt*(1-ddn*ddn))&lt;0) &#x2F;&#x2F; Total internal reflection return obj.e + f.mult(radiance(reflRay,depth,Xi)); Vec tdir &#x3D; (r.d*nnt - n*((into?1:-1)*(ddn*nnt+sqrt(cos2t)))).norm(); double a&#x3D;nt-nc, b&#x3D;nt+nc, R0&#x3D;a*a&#x2F;(b*b), c &#x3D; 1-(into?-ddn:tdir.dot(n)); double Re&#x3D;R0+(1-R0)*c*c*c*c*c,Tr&#x3D;1-Re,P&#x3D;.25+.5*Re,RP&#x3D;Re&#x2F;P,TP&#x3D;Tr&#x2F;(1-P); return obj.e + f.mult(depth&gt;2 ? (erand48(Xi)&lt;P ? &#x2F;&#x2F; Russian roulette radiance(reflRay,depth,Xi)*RP:radiance(Ray(x,tdir),depth,Xi)*TP) : radiance(reflRay,depth,Xi)*Re+radiance(Ray(x,tdir),depth,Xi)*Tr);&#125;int main(int argc, char *argv[])&#123; int w&#x3D;1024, h&#x3D;768, samps &#x3D; argc&#x3D;&#x3D;2 ? atoi(argv[1])&#x2F;4 : 1; &#x2F;&#x2F; # samples Ray cam(Vec(50,52,295.6), Vec(0,-0.042612,-1).norm()); &#x2F;&#x2F; cam pos, dir Vec cx&#x3D;Vec(w*.5135&#x2F;h), cy&#x3D;(cx%cam.d).norm()*.5135, r, *c&#x3D;new Vec[w*h];#pragma omp parallel for schedule(dynamic, 1) private(r) &#x2F;&#x2F; OpenMP for (int y&#x3D;0; y&lt;h; y++)&#123; &#x2F;&#x2F; Loop over image rows fprintf(stderr,&quot;\\rRendering (%d spp) %5.2f%%&quot;,samps*4,100.*y&#x2F;(h-1)); for (unsigned short x&#x3D;0, Xi[3]&#x3D;&#123;0,0,y*y*y&#125;; x&lt;w; x++) &#x2F;&#x2F; Loop cols for (int sy&#x3D;0, i&#x3D;(h-y-1)*w+x; sy&lt;2; sy++) &#x2F;&#x2F; 2x2 subpixel rows for (int sx&#x3D;0; sx&lt;2; sx++, r&#x3D;Vec())&#123; &#x2F;&#x2F; 2x2 subpixel cols for (int s&#x3D;0; s&lt;samps; s++)&#123; double r1&#x3D;2*erand48(Xi), dx&#x3D;r1&lt;1 ? sqrt(r1)-1: 1-sqrt(2-r1); double r2&#x3D;2*erand48(Xi), dy&#x3D;r2&lt;1 ? sqrt(r2)-1: 1-sqrt(2-r2); Vec d &#x3D; cx*( ( (sx+.5 + dx)&#x2F;2 + x)&#x2F;w - .5) + cy*( ( (sy+.5 + dy)&#x2F;2 + y)&#x2F;h - .5) + cam.d; r &#x3D; r + radiance(Ray(cam.o+d*140,d.norm()),0,Xi)*(1.&#x2F;samps); &#125; &#x2F;&#x2F; Camera rays are pushed ^^^^^ forward to start in interior c[i] &#x3D; c[i] + Vec(clamp(r.x),clamp(r.y),clamp(r.z))*.25; &#125; &#125; FILE *f &#x3D; fopen(&quot;image.ppm&quot;, &quot;w&quot;); &#x2F;&#x2F; Write image to PPM file. fprintf(f, &quot;P3\\n%d %d\\n%d\\n&quot;, w, h, 255); for (int i&#x3D;0; i&lt;w*h; i++) fprintf(f,&quot;%d %d %d &quot;, toInt(c[i].x), toInt(c[i].y), toInt(c[i].z));&#125; 三、用法123g++ -O3 -fopenmp smallpt.cpp -o smallpt time .&#x2F;smallpt 5000display image.ppm 四、细节 2.4 GHz 两核四线程，每个像素的不同采样数（spp）的计时和结果图像 通过使用数值积分求解渲染方程来计算图像。具体的算法是蒙特卡罗路径跟踪与俄罗斯轮盘赌路径终止。由于尺寸限制和简单性，不使用显式灯光采样，也不使用任何光线相交加速数据结构。 #pragma omp parallel for schedule(dynamic, 1) private(r) 语句，使用OpenMP动态地将映像行分配给不同的线程，每个处理器或内核有一个线程。 变量 Xi 用于存储随机数生成器 erand48 的状态，使用行数来做随机值种子，这样子序列就是跟行数有关，与并行计算的先后顺序等无关。 抗锯齿是使用超级采样完成的，超级采样将删除除灯光周围以外的所有锯齿。通过使用2x2子像素进行处理，这些子像素先被clamp操作，然后求平均。 扩展一、Vec 类123456789101112131415&#x2F;&#x2F; 定义struct Vec &#123; &#x2F;&#x2F; Usage: time .&#x2F;smallpt 5000 &amp;&amp; xv image.ppm double x, y, z; &#x2F;&#x2F; position, also color (r,g,b) Vec(double x_&#x3D;0, double y_&#x3D;0, double z_&#x3D;0)&#123; x&#x3D;x_; y&#x3D;y_; z&#x3D;z_; &#125; Vec operator+(const Vec &amp;b) const &#123; return Vec(x+b.x,y+b.y,z+b.z); &#125; Vec operator-(const Vec &amp;b) const &#123; return Vec(x-b.x,y-b.y,z-b.z); &#125; Vec operator*(double b) const &#123; return Vec(x*b,y*b,z*b); &#125; Vec mult(const Vec &amp;b) const &#123; return Vec(x*b.x,y*b.y,z*b.z); &#125; Vec&amp; norm()&#123; return *this &#x3D; *this * (1&#x2F;sqrt(x*x+y*y+z*z)); &#125; double dot(const Vec &amp;b) const &#123; return x*b.x+y*b.y+z*b.z; &#125; &#x2F;&#x2F; cross: Vec operator%(Vec&amp;b)&#123;return Vec(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);&#125;&#125;;&#x2F;&#x2F; 应用Vec cx&#x3D;Vec(w*.5135&#x2F;h), cy&#x3D;(cx%cam.d).norm()*.5135, r, *c&#x3D;new Vec[w*h]; Vec 类实现了向量的运算。 成员 norm 函数的计算公式其实是将三个分量分别乘以比例系数，从而达到归一化操作。 成员 dot 函数对应的是向量的点乘运算： \\vec{a} \\cdot \\vec{b} = \\begin{pmatrix} x_{a} \\\\ y_{a} \\\\ z_{a} \\end{pmatrix} \\cdot \\begin{pmatrix} x_{b} \\\\ y_{b} \\\\ z_{b} \\end{pmatrix} = x_{a}x_{b} + y_{a}y_{b} + z_{a}z_{b}% 操作运算符对应的是向量的叉乘运算： \\vec{a} \\times \\vec{b} = \\begin{pmatrix} x_{a} \\\\ y_{a} \\\\ z_{a} \\end{pmatrix} \\times \\begin{pmatrix} x_{b} \\\\ y_{b} \\\\ z_{b} \\end{pmatrix} = \\begin{pmatrix} y_{a}z_{b} - y_{b}z_{a} \\\\ z_{a}x_{b} - x_{a}z_{b} \\\\ x_{a}y_{b} - y_{a}x_{b} \\end{pmatrix} \\vec{a} \\times \\vec{b} = A^{*}b = \\underset{\\text{dual matrix of vector a}}{ \\begin{pmatrix} 0 & -z_{a} & y_{a} \\\\ z_{a} & 0 & -x_{a} \\\\ -y_{a} & x_{a} & 0 \\end{pmatrix} } \\begin{pmatrix} x_{b} \\\\ y_{b} \\\\ z_{b} \\end{pmatrix}应用上，变量 cx 为摄像机在 x 轴上的方向分量（右轴），同理变量 cy 是摄像机在 y 轴上的方向分量（上轴）。0.5135是视场系数，控制摄像机看到的范围，变量 cx 通过对输出图像的分辨率比例求得，而变量 cy 是通过摄像机方向和变量 cx 叉乘得到（见：LearnOpenGL-摄像机）。 变量 r 是当前像素点的光照辐射值，通过对子像素点计算累加求得。 变量 c 是输出图像的数据数组，记录每个像素点的颜色值。 二、main 函数的5个 for 循环 第一个 for 循环 1for (int y&#x3D;0; y&lt;h; y++) 遍历输出像素分辨率的每一行。 第二个 for 循环 1for (unsigned short x&#x3D;0, Xi[3]&#x3D;&#123;0,0,y*y*y&#125;; x&lt;w; x++) 遍历每一行分辨率的每一个像素（每一列）。 第三个 for 循环 1for (int sy&#x3D;0, i&#x3D;(h-y-1)*w+x; sy&lt;2; sy++) 从右下角开始，由于采用的是2x2超级采样，所以每个像素分为四个子像素。这一层对应每个像素。 第四个 for 循环 1for (int sx&#x3D;0; sx&lt;2; sx++, r&#x3D;Vec()) 由于采用的是2x2超级采样，所以每个像素分为四个子像素。这一层对应每个子像素。 这一层主要做两件事情，多次采样以及将每一个子像素计算结果累加到该像素点的数值上。 第五个 for 循环 1for (int s&#x3D;0; s&lt;samps; s++) 每个子像素采样 samps 次。 在该循环中，首先采用 Tent Filter 实现抗锯齿，然后计算该子像素点的光线方向 d，最后求得该子像素点的辐射值，并累加到像素点的辐射值变量 r 上。 三、Tent Filter先看 Tent Filter 的函数定义： f_{tent}(x) = \\begin{cases} 1- \\vert x \\vert , & \\vert x \\vert < 1 \\\\[2ex] 0, & \\text{otherwise} \\end{cases}低通滤波，只输出 x 的绝对值小于时的结果，再看代码的实现方式： 12double r1&#x3D;2*erand48(Xi), dx&#x3D;r1&lt;1 ? sqrt(r1)-1: 1-sqrt(2-r1);double r2&#x3D;2*erand48(Xi), dy&#x3D;r2&lt;1 ? sqrt(r2)-1: 1-sqrt(2-r2); 变量 r1 和 r2 的取值在 $[0,2)$，然后变量 dx 和 dy 的取值根据 变量 r1 和 r2 的取值不同有着不同的取值，但总体范围在 $[-1,1]$： d(r) = \\begin{cases} \\sqrt{r} - 1, & 0 \\leq r < 1 \\\\[2ex] 1- \\sqrt{2 - r}, & 1 \\leq r < 2 \\end{cases}可以看到与原生 Tent Filter 的取值范围不同，先看下怎么使用结果： 12Vec d &#x3D; cx*( ( (sx+.5 + dx )&#x2F;2 + x)&#x2F;w - .5) + cy*( ( (sy+.5 + dy )&#x2F;2 + y)&#x2F;h - .5) + cam.d; 子像素的光线方向 d 与摄像机在 xy 轴上的方向分量、当前子像素序号以及摄像机的方向有关。sx+.5 或 sy+.5 是将采样点移动到子像素的中心点，然后再加上 Tent Filter 值。 最终，cx*( ( (sx+.5 + dx )/2 + x)/w - .5) 或 cy*( ( (sy+.5 + dy )/2 + y)/h - .5) 对应分量的取值范围在 $[-0.5,0.5)$。也就是在当前像素点的面积内做偏移。 上面解释的有问题，得看下面截图： 四、OpenMP1#pragma omp parallel for schedule(dynamic, 1) private(r) 实现并行计算。 五、Sphere 类12345678910111213struct Sphere &#123; double rad; &#x2F;&#x2F; radius Vec p, e, c; &#x2F;&#x2F; position, emission, color Refl_t refl; &#x2F;&#x2F; reflection type (DIFFuse, SPECular, REFRactive) Sphere(double rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_): rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125; double intersect(const Ray &amp;r) const &#123; &#x2F;&#x2F; returns distance, 0 if nohit Vec op &#x3D; p-r.o; &#x2F;&#x2F; Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 &#x3D; 0 double t, eps&#x3D;1e-4, b&#x3D;op.dot(r.d), det&#x3D;b*b-op.dot(op)+rad*rad; if (det&lt;0) return 0; else det&#x3D;sqrt(det); return (t&#x3D;b-det)&gt;eps ? t : ((t&#x3D;b+det)&gt;eps ? t : 0); &#125;&#125;; 定义场景各种物体的球体类。 成员变量 rad 定义球体半径，变量 p 定义球心位置，变量 e 定义物体自发光属性，变量 c 定义物体颜色，结构体变量 refl 定义物体散射性质（漫反射、镜面反射、折射）。 成员 intersect 函数判断物体与光线是否相交，相交则返回交点与光线原点的距离。而其判断方法为参数方程法。 五、radiance 函数1Vec radiance(const Ray &amp;r, int depth, unsigned short *Xi) radiance 函数接受三个参数，第一个是光线，第二个是光线追踪的深度，第三个是随机值种子。 在 main 函数中调用如下： 1radiance(Ray(cam.o+d*140,d.norm()),0,Xi) 因为重新计算了光线的方向，所以传入初始的光线位置和方向也需要对应改变。 判断是否与物体相交，否则直接返回 123double t; &#x2F;&#x2F; distance to intersectionint id&#x3D;0; &#x2F;&#x2F; id of intersected objectif (!intersect(r, t, id)) return Vec(); &#x2F;&#x2F; if miss, return black 全局 intersect 函数遍历每一个球体物体，然后判断光线是否与它们相交，并且返回最近的一个物体的交点距离。 计算/定义一些相交之后的信息 12const Sphere &amp;obj &#x3D; spheres[id]; &#x2F;&#x2F; the hit objectVec x&#x3D;r.o+r.d*t, n&#x3D;(x-obj.p).norm(), nl&#x3D;n.dot(r.d)&lt;0?n:n*-1, f&#x3D;obj.c; 变量 obj 为本次光线路径追踪相交的物体。 变量 x 是通过光线函数表达式计算得到的交点坐标。 变量 n 是物体在交点上的表面法线。 变量 nl 是朝向法线（oriented normal），通过计算光线方向与物体交点表面法线之间的夹角余弦值，判断其正负来决定光线是打在物体表面还是从物体内部穿出来。 变量 f 为物体颜色。 俄罗斯轮盘赌，决定光线追踪是否结束 12double p &#x3D; f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; &#x2F;&#x2F; max reflif (++depth&gt;5) if (erand48(Xi)&lt;p) f&#x3D;f*(1&#x2F;p); else return obj.e; &#x2F;&#x2F;R.R. 变量 p 是取当前物体颜色三个分量中的最大值。 只有在深度大于5之后，才进行俄罗斯轮盘赌。 计算漫反射 123456if (obj.refl &#x3D;&#x3D; DIFF)&#123; &#x2F;&#x2F; Ideal DIFFUSE reflection double r1&#x3D;2*M_PI*erand48(Xi), r2&#x3D;erand48(Xi), r2s&#x3D;sqrt(r2); Vec w&#x3D;nl, u&#x3D;((fabs(w.x)&gt;.1?Vec(0,1):Vec(1))%w).norm(), v&#x3D;w%u; Vec d &#x3D; (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1-r2)).norm(); return obj.e + f.mult(radiance(Ray(x,d),depth,Xi));&#125; 变量 r1 是随机抽样半球散射光线中一条的角度，变量 r2 和 r2s 是一个距离中心点的随机长度。 变量 w 和 u 和 v 则分别是局部坐标系的三个轴。变量 w 取朝向法线的方向。变量 u 根据变量 w 的 x 轴分量来决定是以哪个垂直轴来做叉乘变量 w ，这样子使得叉乘结果更好（感觉没啥用）。变量 v 则是另外两个轴叉乘得到。 变量 d 是求出随机抽样半球散射光线中一条光线的方向。由于局部坐标系是通过世界坐标系的朝向法线建立起来的，那么分别求出光线在各个方向的分量之后，合起来的结果便是该光线在世界坐标系上的坐标。 w*sqrt(1-r2) 中的 1-r2 这个随机值是因为 z 轴跟 xy 轴不同，随着角度增大， z 轴的值是减少的。 这篇文章解释了变量 r2s 的定义。 使用了概率密度函数的概念。 返回结果则是继续递归。 计算镜面反射 12else if (obj.refl &#x3D;&#x3D; SPEC) &#x2F;&#x2F; Ideal SPECULAR reflection return obj.e + f.mult(radiance(Ray(x,r.d-n*2*n.dot(r.d)),depth,Xi)); 镜面反射就一句代码。 与漫反射不同之处在于镜面反射之后的光线方向由 r.d-n*2*n.dot(r.d) 求得。 计算折射（同样包含反射） 1234567891011Ray reflRay(x, r.d-n*2*n.dot(r.d)); &#x2F;&#x2F; Ideal dielectric REFRACTIONbool into &#x3D; n.dot(nl)&gt;0; &#x2F;&#x2F; Ray from outside going in?double nc&#x3D;1, nt&#x3D;1.5, nnt&#x3D;into?nc&#x2F;nt:nt&#x2F;nc, ddn&#x3D;r.d.dot(nl), cos2t;if ((cos2t&#x3D;1-nnt*nnt*(1-ddn*ddn))&lt;0) &#x2F;&#x2F; Total internal reflection return obj.e + f.mult(radiance(reflRay,depth,Xi));Vec tdir &#x3D; (r.d*nnt - n*((into?1:-1)*(ddn*nnt+sqrt(cos2t)))).norm();double a&#x3D;nt-nc, b&#x3D;nt+nc, R0&#x3D;a*a&#x2F;(b*b), c &#x3D; 1-(into?-ddn:tdir.dot(n));double Re&#x3D;R0+(1-R0)*c*c*c*c*c,Tr&#x3D;1-Re,P&#x3D;.25+.5*Re,RP&#x3D;Re&#x2F;P,TP&#x3D;Tr&#x2F;(1-P);return obj.e + f.mult(depth&gt;2 ? (erand48(Xi)&lt;P ? &#x2F;&#x2F; Russian roulette radiance(reflRay,depth,Xi)*RP:radiance(Ray(x,tdir),depth,Xi)*TP) : radiance(reflRay,depth,Xi)*Re+radiance(Ray(x,tdir),depth,Xi)*Tr); 玻璃材质的物体既有折射也有反射，根据全反射原理，有可能会出现完全反射的情况。所以，先进行反射计算，然后再进行折射计算。 变量 reflRay 为反射方向光线。 变量 into 判定光线是从外部进入物体，还是从物体内部照射出来。 变量 nc 为空气介质密度，变量 nt 为物体介质密度。变量 nnt 则为折射率，变量 ddn 为光线方向与朝向法线角度的余弦值。 表达式 (cos2t=1-nnt*nnt*(1-ddn*ddn))&lt;0 判断是否全反射。如果满足全反射，则不用计算折射，直接返回反射递归调用。 接下来计算折射部分。 变量 tdir 为 折射光方向。 接下来使用菲涅尔项来计算校准之后的折射光的反射比。 变量 Re 为折射光的菲涅尔项。 最后，再进行一次俄罗斯轮盘赌，变量 RP 是产生菲涅尔项效果的概率，变量 TP 是不产生菲涅尔项效果的概率。当深度大于2时，启动俄罗斯轮盘赌，判断为真则启用反射计算（叠加菲涅尔项），判断为假则进行折射计算（叠加对立比例）。当深度小于2时，则是反射和折射两者的叠加效果计算（当然没有俄罗斯轮盘赌）。 其他 可以看到，在每个 return 语句上，都是当前相交点的物体的辐射值加上物体颜色乘以下一次光线追踪返回结果的值。这样子一直递归到最后一层，这样子反递归的时候，就会将源头的结果叠加回来。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"https://www.chaguake.com/tags/Ray-Tracing/"}]},{"title":"OpenGL入门（十）——深度测试","slug":"OpenGL-introduction-10","date":"2021-05-20T03:27:17.000Z","updated":"2021-05-20T07:26:21.599Z","comments":true,"path":"2021/05/20/OpenGL-introduction-10/","link":"","permalink":"https://www.chaguake.com/2021/05/20/OpenGL-introduction-10/","excerpt":"","text":"渲染管线的过程在文章中有提过，顶点数据通过glBufferData等一系列函数传递进CPU，然后经过顶点着色器、图元装配、几何着色器、光栅化、片段着色器和最后的测试与混合，最后输出到屏幕。 本节所讲的深度测试位于片段着色器后面的测试与混合阶段，具体可看下图： 深度测试（Depth Testing）深度缓冲用于防止被阻挡的面渲染到其他面的前面，它在每个片段中存储了信息，由窗口系统自动创建，以16、24或32位float的类型存储它的深度值（默认是24位）。 深度测试默认是禁用的，开启使用函数glEnable实现： 12glEnable(GL_DEPTH_TEST);glClear(GL_DEPTH_BUFFER_BIT); 在某些情况下，可能不需要更新深度缓冲，这意味着要禁用深度缓冲的写入，那么，可以设置深度缓冲的深度掩码（Depth Mask）为FALSE实现： 1glDepthMask(GL_FALSE); OpenGL使用深度函数glDepthFunc，修改深度测试的比较运算符，来控制片段的丢弃方式。 1glDepthFunc(GL_LESS); 比较运算符有以下这些： 比较运算符号 描述 GL_ALWAYS 永远通过深度测试 GL_NEVER 永远不通过深度测试 GL_LESS 在片段深度值小于缓冲的深度值时通过测试 GL_EQUAL 在片段深度值等于缓冲区的深度值时通过测试 GL_LEQUAL 在片段深度值小于等于缓冲区的深度值时通过测试 GL_GREATER 在片段深度值大于缓冲区的深度值时通过测试 GL_NOTEQUAL 在片段深度值不等于缓冲区的深度值时通过测试 GL_GEQUAL 在片段深度值大于等于缓冲区的深度值时通过测试 默认情况下使用的深度比较符号是GL_LESS，输出效果如下： 使用GL_ALWAYS的输出效果如下： 可以在这里找到例子源码。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（九）——模型加载","slug":"OpenGL-introduction-09","date":"2021-05-20T03:22:19.000Z","updated":"2021-05-31T02:18:44.314Z","comments":true,"path":"2021/05/20/OpenGL-introduction-09/","link":"","permalink":"https://www.chaguake.com/2021/05/20/OpenGL-introduction-09/","excerpt":"","text":"模型加载库AssimpAssimp是一个非常流行的模型导入库，它是以场景为主导的模型： 网格（Mesh）网格是组成模型的基本单位，是我们在OpenGL中绘制物体所需要的最小单位，通常包含顶点数据、索引和材质属性。 顶点至少包含一个位置向量、一个法向量和一个纹理坐标向量： 12345struct Vertex &#123; glm::vec3 Position; glm::vec3 Normal; glm::vec2 TexCoords;&#125;; 纹理则包含一个纹理ID和纹理类型（漫反射贴图或镜面光贴图）： 1234struct Texture &#123; unsigned int id; string type;&#125;; 那么，最简单的Mesh类结构如下： 123456789101112131415class Mesh &#123; public: &#x2F;* 网格数据 *&#x2F; vector&lt;Vertex&gt; vertices; vector&lt;unsigned int&gt; indices; vector&lt;Texture&gt; textures; &#x2F;* 函数 *&#x2F; Mesh(vector&lt;Vertex&gt; vertices, vector&lt;unsigned int&gt; indices, vector&lt;Texture&gt; textures); void Draw(Shader shader); private: &#x2F;* 渲染数据 *&#x2F; unsigned int VAO, VBO, EBO; &#x2F;* 函数 *&#x2F; void setupMesh();&#125;; 最终的Mesh类代码在这里。 模型（Model）原文翻译文章看这里。 Model类的源码在这里。 最终，例子实现了加载模型文件的操作，输出如下： 根据光照教程，添加光线之后的效果如下：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（八）——光照贴图和多光源","slug":"OpenGL-introduction-08","date":"2021-05-18T07:40:22.000Z","updated":"2021-05-18T08:51:57.896Z","comments":true,"path":"2021/05/18/OpenGL-introduction-08/","link":"","permalink":"https://www.chaguake.com/2021/05/18/OpenGL-introduction-08/","excerpt":"","text":"光照贴图我们可以为物体的材质添加贴图，在贴图上实现光照效果（主要应用在冯氏光照模型中的漫反射光照和镜面光照上）。 贴图的方式与纹理的使用相似，首先，加载和绑定纹理： 1234567&#x2F;&#x2F; bind diffuse mapglActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, diffuseMap);&#x2F;&#x2F; bind specular mapglActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, specularMap); 然后，片段着色器中，修改材质属性的结构体，使用sampler2D封装贴图： 12345struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; 最后，应用到漫反射光照和镜面光照计算中： 1234vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords));vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords));FragColor &#x3D; vec4(ambient + diffuse + specular, 1.0); 输出的结果如下： 投光物平行光 平行光的每一条光线互相平行，例如太阳光。 1 平行光中，物体与光源的位置不重要了，只关心光的方向： 1234567891011121314struct Light &#123; &#x2F;&#x2F; vec3 position; &#x2F;&#x2F; 使用定向光就不再需要了 vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;...void main()&#123; vec3 lightDir &#x3D; normalize(-light.direction); ...&#125; 输出结果如下： 点光 点光的光源是某一个点，然后光线从这个点向四周散发，并且随着距离组件衰减，例如灯泡和火把。 衰减的计算公式如下： \\begin{equation} F_{att} = \\frac{1.0}{K_c + K_l * d + K_q * d^2} \\end{equation}用图表显示如下： 实现衰减需要添加三个参数： 1234567891011struct Light &#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular; float constant; float linear; float quadratic;&#125;; 然后通过公式计算出衰减因子： 123float distance &#x3D; length(light.position - FragPos);float attenuation &#x3D; 1.0 &#x2F; (light.constant + light.linear * distance + light.quadratic * (distance * distance)); 最终，将这个衰减因子计算到每一个光照计算中： 123ambient *&#x3D; attenuation; diffuse *&#x3D; attenuation;specular *&#x3D; attenuation; 输出结果如下： 聚光 聚光是具有方向和角度的光，它由某一个点发射光线，光线范围在一个圆锥体中，例如手电筒。 在片段着舍弃的光结构体中，需要聚光的位置向量、聚光的方向向量和聚光的切光角： 123456struct Light &#123; vec3 position; vec3 direction; float cutOff; ...&#125;; 然后计算片段与聚光的角度，来决定是否在聚光的内部： 12345678float theta &#x3D; dot(lightDir, normalize(-light.direction));if(theta &gt; light.cutOff) &#123; &#x2F;&#x2F; 执行光照计算&#125;else &#x2F;&#x2F; 否则，使用环境光，让场景在聚光之外时不至于完全黑暗 color &#x3D; vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0); 最终输出的结果如下： 可以看到，聚光的边界十分的清晰，这不符合现实，我们需要将聚光的边缘平滑下，实现衰减效果。 我们可以定义内圆锥和外圆锥，在内圆锥，光线强度恒为1，外光锥则随着偏移越大，光线强度而逐渐减少为0，计算公式如下。 \\begin{equation} I = \\frac{\\theta - \\gamma}{\\epsilon} \\end{equation}在片段着色器不需要if-else的判断了： 12345678float theta &#x3D; dot(lightDir, normalize(-light.direction));float epsilon &#x3D; light.cutOff - light.outerCutOff;float intensity &#x3D; clamp((theta - light.outerCutOff) &#x2F; epsilon, 0.0, 1.0); ...&#x2F;&#x2F; 将不对环境光做出影响，让它总是能有一点光diffuse *&#x3D; intensity;specular *&#x3D; intensity;... 最终，输出结果如下： 多光源多光源其实是在片段着色器中对每个光照的叠加，具体实现代码在这里可以找到。 实现的效果如下： 顶点着色器 我们来看下这个多光源场景中物体的顶点着色器源码： 123456789101112131415161718192021#version 330 corelayout (location &#x3D; 0) in vec3 aPos;layout (location &#x3D; 1) in vec3 aNormal;layout (location &#x3D; 2) in vec2 aTexCoords;out vec3 FragPos;out vec3 Normal;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos &#x3D; vec3(model * vec4(aPos, 1.0)); Normal &#x3D; mat3(transpose(inverse(model))) * aNormal; TexCoords &#x3D; aTexCoords; gl_Position &#x3D; projection * view * vec4(FragPos, 1.0);&#125; 绑定了三个数据源，顶点位置、法向量和纹理位置。 片段着色器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#version 330 coreout vec4 FragColor;struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; struct DirLight &#123; vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;struct PointLight &#123; vec3 position; float constant; float linear; float quadratic; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;struct SpotLight &#123; vec3 position; vec3 direction; float cutOff; float outerCutOff; float constant; float linear; float quadratic; vec3 ambient; vec3 diffuse; vec3 specular; &#125;;#define NR_POINT_LIGHTS 4in vec3 FragPos;in vec3 Normal;in vec2 TexCoords;uniform vec3 viewPos;uniform DirLight dirLight;uniform PointLight pointLights[NR_POINT_LIGHTS];uniform SpotLight spotLight;uniform Material material;&#x2F;&#x2F; function prototypesvec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);void main()&#123; &#x2F;&#x2F; properties vec3 norm &#x3D; normalize(Normal); vec3 viewDir &#x3D; normalize(viewPos - FragPos); &#x2F;&#x2F; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F; Our lighting is set up in 3 phases: directional, point lights and an optional flashlight &#x2F;&#x2F; For each phase, a calculate function is defined that calculates the corresponding color &#x2F;&#x2F; per lamp. In the main() function we take all the calculated colors and sum them up for &#x2F;&#x2F; this fragment&#39;s final color. &#x2F;&#x2F; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F; phase 1: directional lighting vec3 result &#x3D; CalcDirLight(dirLight, norm, viewDir); &#x2F;&#x2F; phase 2: point lights for(int i &#x3D; 0; i &lt; NR_POINT_LIGHTS; i++) result +&#x3D; CalcPointLight(pointLights[i], norm, FragPos, viewDir); &#x2F;&#x2F; phase 3: spot light result +&#x3D; CalcSpotLight(spotLight, norm, FragPos, viewDir); FragColor &#x3D; vec4(result, 1.0);&#125;&#x2F;&#x2F; calculates the color when using a directional light.vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)&#123; vec3 lightDir &#x3D; normalize(-light.direction); &#x2F;&#x2F; diffuse shading float diff &#x3D; max(dot(normal, lightDir), 0.0); &#x2F;&#x2F; specular shading vec3 reflectDir &#x3D; reflect(-lightDir, normal); float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); &#x2F;&#x2F; combine results vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords)); return (ambient + diffuse + specular);&#125;&#x2F;&#x2F; calculates the color when using a point light.vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)&#123; vec3 lightDir &#x3D; normalize(light.position - fragPos); &#x2F;&#x2F; diffuse shading float diff &#x3D; max(dot(normal, lightDir), 0.0); &#x2F;&#x2F; specular shading vec3 reflectDir &#x3D; reflect(-lightDir, normal); float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); &#x2F;&#x2F; attenuation float distance &#x3D; length(light.position - fragPos); float attenuation &#x3D; 1.0 &#x2F; (light.constant + light.linear * distance + light.quadratic * (distance * distance)); &#x2F;&#x2F; combine results vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords)); ambient *&#x3D; attenuation; diffuse *&#x3D; attenuation; specular *&#x3D; attenuation; return (ambient + diffuse + specular);&#125;&#x2F;&#x2F; calculates the color when using a spot light.vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)&#123; vec3 lightDir &#x3D; normalize(light.position - fragPos); &#x2F;&#x2F; diffuse shading float diff &#x3D; max(dot(normal, lightDir), 0.0); &#x2F;&#x2F; specular shading vec3 reflectDir &#x3D; reflect(-lightDir, normal); float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); &#x2F;&#x2F; attenuation float distance &#x3D; length(light.position - fragPos); float attenuation &#x3D; 1.0 &#x2F; (light.constant + light.linear * distance + light.quadratic * (distance * distance)); &#x2F;&#x2F; spotlight intensity float theta &#x3D; dot(lightDir, normalize(-light.direction)); float epsilon &#x3D; light.cutOff - light.outerCutOff; float intensity &#x3D; clamp((theta - light.outerCutOff) &#x2F; epsilon, 0.0, 1.0); &#x2F;&#x2F; combine results vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords)); ambient *&#x3D; attenuation * intensity; diffuse *&#x3D; attenuation * intensity; specular *&#x3D; attenuation * intensity; return (ambient + diffuse + specular);&#125; 片段着色器中可以看到，其GLSL的语法与C差不多。 在main函数中，首先是对平行定向光线的计算： 12&#x2F;&#x2F; phase 1: directional lightingvec3 result &#x3D; CalcDirLight(dirLight, norm, viewDir); 然后，遍历计算每一个点光： 123&#x2F;&#x2F; phase 2: point lightsfor(int i &#x3D; 0; i &lt; NR_POINT_LIGHTS; i++) result +&#x3D; CalcPointLight(pointLights[i], norm, FragPos, viewDir); 最后，计算聚光： 12&#x2F;&#x2F; phase 3: spot lightresult +&#x3D; CalcSpotLight(spotLight, norm, FragPos, viewDir);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（七）——材质","slug":"OpenGL-introduction-07","date":"2021-05-14T08:50:12.000Z","updated":"2021-05-14T09:25:57.346Z","comments":true,"path":"2021/05/14/OpenGL-introduction-07/","link":"","permalink":"https://www.chaguake.com/2021/05/14/OpenGL-introduction-07/","excerpt":"","text":"英文原文地址 中文翻译地址 材质由于每个物体对光的反应是不一样的，所以我们需要为每个物体分别定义一个材质（Material）属性。 可以使用环境光照（Ambient Lighting）、漫反射光照（Diffuse Lighting）、镜面光照（Specular Lighting）和反光度（Shininess）来定义物体的材质属性。 在片段着色器上，使用结构体封装物体的材质属性。 123456789#version 330 corestruct Material &#123; vec3 ambient; vec3 diffuse; vec3 specular; float shininess;&#125;; uniform Material material; 向量ambient定义了在环境光照下这个物体反射的颜色，通常来说是物体的固有色。向量diffuse定义了在漫反射光照下物体的颜色。向量specular设置了镜面光照对物体颜色的影响（有可能物体反射的是光的颜色，有可能物体反射的是自身特定的高光颜色）。变量shininess影响镜面高光的散射/半径。 光照光的属性我们还需要对每一种光照添加强度属性，毕竟每一种关照对物体的影响是不一样的。并且关照的位置也会影响物体的最终颜色。 可以定义一个光照的光的属性的结构体： 123456789struct Light &#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;uniform Light light; 我们可以改变光源的环境光颜色和漫反射光照颜色，使得物体随光源的颜色变换而变换。 12345678910glm::vec3 lightColor;lightColor.x &#x3D; sin(glfwGetTime() * 2.0f);lightColor.y &#x3D; sin(glfwGetTime() * 0.7f);lightColor.z &#x3D; sin(glfwGetTime() * 1.3f);glm::vec3 diffuseColor &#x3D; lightColor * glm::vec3(0.5f); &#x2F;&#x2F; 降低影响glm::vec3 ambientColor &#x3D; diffuseColor * glm::vec3(0.2f); &#x2F;&#x2F; 很低的影响lightingShader.setVec3(&quot;light.ambient&quot;, ambientColor);lightingShader.setVec3(&quot;light.diffuse&quot;, diffuseColor); 输出结果如下：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（六）——基本光照","slug":"OpenGL-introduction-06","date":"2021-05-13T07:28:38.000Z","updated":"2021-05-14T07:13:48.023Z","comments":true,"path":"2021/05/13/OpenGL-introduction-06/","link":"","permalink":"https://www.chaguake.com/2021/05/13/OpenGL-introduction-06/","excerpt":"","text":"英文原文地址 中文翻译地址 物体颜色物体所呈现的颜色是因为物体吸收了光照的其他子颜色，反射了不被吸收的子颜色，所以物体看起来就是这个不被吸收的颜色。 在OpenGL中，我们将光照颜色和物体颜色作分量相乘，得到的就是物体在某种光照下最终的颜色： 123glm::vec3 lightColor(0.33f, 0.42f, 0.18f);glm::vec3 toyColor(1.0f, 0.5f, 0.31f);glm::vec3 result &#x3D; lightColor * toyColor; &#x2F;&#x2F; &#x3D; (0.33f, 0.21f, 0.06f); 基础光照下面基于冯氏光照模型（Phong Lighting Model）来学习基础光照的知识。 冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子： 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。 环境光照全局照明（Global Illumination）算法非常复杂，现在使用简化的方式来实现环境光照——用一个简单的颜色，添加到物体片段的最终颜色中。 12345678void main()&#123; float ambientStrength &#x3D; 0.1; vec3 ambient &#x3D; ambientStrength * lightColor; vec3 result &#x3D; ambient * objectColor; FragColor &#x3D; vec4(result, 1.0);&#125; 漫反射光照漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。 如上图所示，垂直于片段表面的叫法向量（Normal Vector），根据光线与法向量的夹角决定光线对物体颜色的影响。夹角采用两个向量对应的单位向量的点乘结果作为与夹角对应的影响标量。 法向量 法向量是一个垂直有顶点表面的单位向量，是通过该顶点与周围的顶点叉乘计算得到的向量。 具体代码可以看这里，输出结果如下： 法线矩阵 物体的不等比缩放会破坏法向量，所以需要在顶点着色器上，使用函数inverse和transpose生成法线矩阵来处理法向量： 1Normal &#x3D; mat3(transpose(inverse(model))) * aNormal; 镜面光照在漫反射光照中，没涉及到物体的反射，如下图，反射向量与视线的夹角决定了镜面光照的影响。 反光度 平常我们可以注意到，有些物体反光很厉害。这个在OpenGL中使用反光度来反映，通过对视线方向与反射方向的点乘结果取幂次数来决定： 12float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), 32);vec3 specular &#x3D; specularStrength * spec * lightColor; 上面代码就是取32次幂，下面展示不同次幂的视觉效果： 最终源码在这里，输出如下：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（五）——坐标系统与摄像机","slug":"OpenGL-introduction-05","date":"2021-05-12T02:00:11.000Z","updated":"2021-05-14T07:12:42.994Z","comments":true,"path":"2021/05/12/OpenGL-introduction-05/","link":"","permalink":"https://www.chaguake.com/2021/05/12/OpenGL-introduction-05/","excerpt":"","text":"英文原文地址 中文翻译地址 坐标系统将物体的坐标最后转换成屏幕最后输出的结果，需要经过几次坐标系统的叠加转换，如下图： 1、局部坐标（Local Space）是物体相对于局部原点的坐标，也是物体其实的坐标。 2、下一步是将局部坐标变换成世界控件坐标（World Space），世界控件坐标是处于一个更大的空间范畴。物体相对于物体原点的坐标变换成相对于世界原点的坐标。 3、接下来将世界坐标变换成观察空间坐标（View Space），使得每一个物体的坐标都是从摄像机的角度进行观察。 4、然后需要将其投影到裁剪坐标（Clip Space）。坐标会被处理在-1.0到1.0之间的范围，由此判断哪些顶点将会出现在屏幕上。 5、最后，将裁剪坐标变换成屏幕坐标（Screen Space），这是一个视口变换（Viewport transform）的过程。视口变换将位于-1.0到1.0范围内的坐标变换到由函数glViewport所定义的坐标范围内。最后变换出来的坐标会被送到光栅器，将其转化为片段。 公式如下： V_{clip} = M_{projection} \\cdot M_{view} \\cdot M_{model} \\cdot V_{local}右手坐标系OpenGL使用右手坐标系。正X轴方向指向右边，正Y轴指向上方，正Z轴由屏幕内部指向外面。 也可以伸出右手，大拇指（正X轴）指向右边，食指（正Y轴）指向上方，中指（正Z轴）指向自己。 左手坐标系在DirectX中广泛应用，并且在标准化设备坐标系中OpenGL也是使用左手坐标系（投影矩阵交换了左右手）。 Z缓冲（深度缓冲）OpenGL使用Z缓冲来存储深度信息，它决定何时是否覆盖一个像素。 深度值存储在每个片段中（片段的z值），当片段要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前片段在其他片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试，由OpenGL自动完成。 深度测试默认是关闭的，可使用函数glEnable来开启，使用函数glDisable来禁用： 12glEnable(GL_DEPTH_TEST);glDisable(GL_DEPTH_TEST); 同时，需要使用函数glClear来清理上一帧的深度缓冲： 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 摄像机从世界空间坐标系转变成观察空间坐标，首先需要知道观察者，即摄像机相对于世界空间的坐标，还有就是摄像机方向。 摄像机位置摄像机位置简单来说就是世界空间中一个指向摄像机位置的变量，例如： 1glm::vec3 cameraPos &#x3D; glm::vec3(0.0f, 0.0f, 3.0f); 值得注意的是，正Z轴是从屏幕指向你的，如果要摄像机向后移动，把它沿着Z轴正方向移动即可。 摄像机方向下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量： 12glm::vec3 cameraTarget &#x3D; glm::vec3(0.0f, 0.0f, 0.0f);glm::vec3 cameraDirection &#x3D; glm::normalize(cameraPos - cameraTarget); 方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。 Look At我们知道了摄像机的位置和方向，可以使用GLM库的函数lookAt来得到观察矩阵。 1234glm::mat4 view;view &#x3D; glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f)); 函数glm::LookAt需要三个参数——摄像机位置、目标位置和世界空间中的上向量。 欧拉角欧拉角表示三维控件中旋转的三个角——俯仰角（Pitch）、偏航角（Yaw）和滚转角（Roll）。 万向节死锁文章【Unity编程】欧拉角与万向节死锁（图文版）解释得很清楚，出现万向节死锁的原因，简单来说就是，当一个轴转动了某一个角度，使得与另一个轴处于一个平面上后，这时对那个轴的操作得不到预期的效果。 借助工具（这里）来加深对万向节死锁的理解。 首先我们先了解下工具的使用情况。 红色轴为X轴，绿色轴为Y轴，蓝色轴为Z轴，有实心圆点的一端是正方向。如下图： 俯仰角（Pitch）改变的方向是垂直于X轴，平行于YZ平面。如下图： 偏航角（Yaw）改变的方向是垂直于Y轴，平行于XZ平面。如下图： 滚转角（Roll）改变的方向是垂直于Z轴，平行于XY平面。如下图： 下面开始实现万向节死锁，第一步，我们先将目标朝上扬起90°，即俯仰角（Pitch）添加90°。如下图： 1、假设我们第二步将目标向右旋转90°，即偏航角（Yaw）添加90°。如下图，对于目标来说，它是滚动旋转了90°。 2、假设我们第二步将目标向右滚动旋转90°，即滚转角（Roll）添加90°，如下图，跟第一种假设情况一样，对于目标来说，它是滚动旋转了90°，但是它运动的方向并没有垂直于Z轴，平行于XY轴。 显然，自由度从原来的三个自由度变成了两个自由度（俯仰角和偏航角）。因为X轴和Y轴平行了，如下图： 四元数摄像机类的使用记录概述 在这里可以找到教程中的摄像机类的实现。 可以看到，Camera类接受四个参数（position, up, yaw, pitch）。 1glm::lookAt(Position, Position + Front, Up); Camera类将lookAt函数的第二个目标位置参数变成Position+Front，Front变量存储摄像机朝向的向量（前轴）。 1234567glm::vec3 front;front.x &#x3D; cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));front.y &#x3D; sin(glm::radians(Pitch));front.z &#x3D; sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));Front &#x3D; glm::normalize(front);Right &#x3D; glm::normalize(glm::cross(Front, WorldUp));Up &#x3D; glm::normalize(glm::cross(Right, Front)); 通过鼠标控制改变俯仰角和偏航角，进而改变摄像机的前轴和上轴，最后改变lookAt的位置。 值得注意的是，假设俯仰角和偏航角的值都为0，那么Front值为(1,0,0)，一个向右的正X轴方向，即摄像机默认看向X轴正方向。一般地，我们需要将摄像机设置成垂直看向XY平面，所以需要默认给摄像机一个偏航角-90°，使得摄像机从朝向右变成朝向里。 摄像机位置 1、摄像机位于正Z轴上，看向原点(0,0,0) 1Camera camera(glm::vec3(0.0f, 0.0f, 45.0f), glm::vec3(0.0f, 1.0f, 0.0f), -90.0f, 0.0f); 这时，计算出来的Front为(0,0,-1)，看向负Z轴，这里可以计算出lookAt点为(0,0,44)。但为什么不是原点(0,0,0)呢？其实，这里无论是(0,0,44)还是(0,0,0)，都是一样的视角，只因为摄像机(0,0,45)本身也在Z轴上，这三个点都在同一条垂直于XY平面的直线上，而摄像机默认视角是垂直于XY平面的。 假如把Up值改成(0,-1,0)，这时的视角就是倒立看到的视角。 2、摄像机处于45°视角，看向原点(0,0,0) 1Camera camera(glm::vec3(0.0f, 45.0f, 45.0f), glm::vec3(0.0f, 1.0f, 0.0f), -90.0f, -45.0f); Front值为(0,-0.7,-0.7)（向量的长度不会改变向量的方向，它跟(0,45,45)平行反向）。 可以看到俯仰角倾斜了45°，因为需要摄像机的视角与XY轴的夹角为45°。 3、摄像机围绕原点(0,0,0)旋转 我们选择摄像机的视角是位于XY平面看向原点(0,0,0)，处于(0,-45,0)位置。 1Camera camera(glm::vec3(0.0f, -45.0f, 0.0f), glm::vec3(0.0f, 0.0f, -1.0f), -90.0f, 90.0f); 那么需要设置摄像机的俯仰角固定为90°，偏航角起始值为-90°，且世界上向量应为(0,0,1)或(0,0,-1)。 然后，需要把Camera类中的目标坐标从Position + Front改成glm::vec3(0.0f, 0.0f, 0.0f)，使得摄像机一直看向原点。 最后，需要添加一个函数，在每个周期更新摄像机的位置和偏航角。 12345678910void auto_cycle()&#123; static float angle &#x3D; -90.0; angle +&#x3D; 0.001; float camX &#x3D; cos(angle) * 45; float camY &#x3D; sin(angle) * 45; float offsety &#x3D; camera.Position.y - camY; camera.Position &#x3D; glm::vec3(camX, camY, 0.0f); camera.Yaw -&#x3D; 0.001; camera.updateCameraVectors();&#125; 更改位置的原因很简单，更改偏航角的原因是要让摄像机一直面向原点。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"Blender官方源码文档——RNA","slug":"Blender-source-code-study-07","date":"2021-05-10T02:23:35.000Z","updated":"2021-05-11T01:41:03.309Z","comments":true,"path":"2021/05/10/Blender-source-code-study-07/","link":"","permalink":"https://www.chaguake.com/2021/05/10/Blender-source-code-study-07/","excerpt":"","text":"最新的官方文档：目录 本文的原文在这里 RNA 这是一份数据API实现的文档。 实现（Implementation）RNA的实现在模块makesrna。其中，几个重要的文件如下： 123RNA_types.h: The important RNA data structures are defined here.RNA_access.h: API for accessing structs and properties at runtime.RNA_define.h: API for defining structs and properties. 定义结构体和属性（Defining Structs and Properties）结构体和属性都定义在makesrna模块的rna_*.c这一类文件中，其定义作为构建系统的一部分生成。错误信息会在构建期间打印出来。 结构体（Struct） 如果你没有在已存在的文件中添加它： 拷贝已存在的文件，重命名并清理它。 在文件makesrna.c中，把它添加到列表PROCESS_ITEMS。 在文件rna_access.h中，添加结构体StructRNA的extern描述。 对于数据块，在文件rna_ID.c中添加正确的ID_case到函数rna_ID_refine()。 接下来，在函数RNA_def_*类函数中，对应的结构体将会被定义。函数RNA_def_struct定义了结构体本身。我们必须定义一个唯一名称且人类能理解的标识符去标识这些结构体。 系统就会自动尝试找到与标识符同名的DNA结构体。假如一个相应的结构体拥有不同的名称，函数RNA_def_struct_sdna可以找到正确的名称，这对于以后更加自动地定义属性很重要。 对于每一个结构体都尽可能地把其名称设置为字符串属性，这个名称将用于UI，并且可以在集合（collections）中使用字符串搜索。 对于ID数据块结构体（ID struct），它需要满足： 在文件rna_main.c中，将“lists”数组中现有项改成正确的类型以代替“ID”，或者是添加新项。 在文件rna_ID.c中，使用函数rna_ID_refine添加改结构体。 属性（Property）对于每一个属性，始于函数RNA_def_property。其标识符一定要跟对应的结构体类似。然后我们必须定义一个类型和子类型。类型确定了数据类型，子类型则是对数据的解释，举个例子，一个float数组属性可以是颜色、向量或者矩阵。 同样地，系统会使用跟标识符一样的字符串在DNA结构体中查找属性，如果它有不一样的名称，下一步要做的是使用函数RNA_def_*_sdna正确指向它。DNA信息用于衍生各种各样的事物，比如说，get/set函数、集合的迭代器、数组长度、限制器等等，下一节将解释映射的工作规则。 如果这些自动值（the automatic values）不正确，则可以后置覆盖。文件RNA_define.h为不同的类型提供信息概括。重要的定义是数组长度、数字范围和枚举项。 接下来，我们需要定义默认值。如果没有显式定义，则数字的默认值为0，字符串的默认值为“”，指针的默认值为NULL，集合的默认值则为空。 为了构建更加自动的用户界面，需要为工具定义通俗易懂的名称和描述。对于可伸缩的数值，定义可拖拽的步长和精度。这些将是从RNA属性中生成按钮时的默认值。 在很多情况下，自动DNA的匹配会解决这个问题，但在某些情况下，我们必须为get/set函数设置回调函数。它们的名称可以使用函数RNA_def_property_*_funcs传递，参数请参见文件RNA_type.h。集合（collections）是最困难的，尽管可以自动支持ListBase和特定数组。请注意，有些函数调用是可选的，它们只对优化有帮助，举个例子，列表的查找函数。 DNA匹配（DNA Matching） Booleans/Ints/Floats：数组长度基于在float member[x]中的数值x。举个例子，只支持一维数组。如果变量本身不是数组，它会假设连续变量是数组的一部分。举个例子，指定变量r来自浮点型变量r、g和b，那么，可以假设数组的地址为&amp;r。 Booleans可以使用函数RNA_def_property_boolean_sdna指定为一个bit。如果定义了数组长度但没有数组成员SDNA，那么可以假设这个数组是通过由指定bit开始的bit标志位定义的。 Ints：数值值范围见INT_MIN/INT_MAX，如果检测出是char或者short，则使用对应的值范围。非负数类型现在并没有自动检测（SDNA不支持），所以，应该使用子类型PROP_UNSIGNED或者手动限制其值范围。 Enums：函数RNA_def_property_enum_sdna有一个参数去判断枚举是否是bit标志位的，在与其他标志位混用时应当被设置。 Strings：char数组，最大长度取决于数组大小。 Pointers：如果指针类型未定义，则会根据结构体对应的DNA自动定义，对于定义为指向数组指针的集合，也是使用指针。 Collections：基于ListBase，函数begin/next/get会自动生成。 Collections：当将包含集合长度的变量的名称传递给SDNA函数时，假设正在使用一个数组，则会为这个数组自动生成函数begin/next/get/end。如果成员的指针是像MVert *mvert;这样的简单指针，它会返回&amp;mvert[i]这样的items，如果它是像Material **mat;这样指向指针的指针，他就会返回mat[i]这样的items。 在嵌套结构体中的成员也可以被识别，举个例子，使用函数RNA_def_property_*_sdna传递一个值。 命名约束（Naming Conventions）运行时接入（Runtime Access） 运行时接入属性值是通过定义在文件RNA_access.h的函数。支持函数get/set和集合迭代器。 这也是使用函数去检查属性是否可编辑的或已计算的。如果属性是可编辑的，这就意味着它可以被用户修改。如果它是可计算的，这就意味着它可以将一些函数设置为计算的一部分，例如：修改器、约束器或者动画系统的一部分。 指针（Pointers） 一个RNA结构体的指针总是包裹在结构体PointerRNA中。结构体PointerRNA包含实际的数据指针和结构体类型。它也包含了数据指针和数据所属的ID数据块类型。这在某种情况下是有需要的，举个例子，一个顶点自身是提供不了足够的信息去更新依赖关系图，我们需要知道顶点所在的网格（mesh）。 在运行时中创建指针，使用函数RNA_main_pointer_create、RNA_id_pointer_create和RNA_pointer_create。 属性的回调函数使用PointerRNA们来代替直接指向数据的指针，因此，它们在需要的时候可以使用ID数据。指针和集合的get/set回调函数返回数据指针，类型和ID则会在回调的外部自动填充。 ID属性（ID Properties） RNA同样支持ID属性，有两个方法： 如果一个RNA属性是在运行时中定义，或者有PROP_IDPROPERTY标记，ID属性将会通过RNA API被首次创建。RNA API初始化时返回默认值，直到创建ID属性，然后，返回ID属性值。值得注意的是，如果RNA定义了相同名称但不用类型的ID属性，那它会移除和重写，以匹配上RNA的类型。 如果存在一个ID属性但它没有对应的RNA属性，当遍历结构体的属性时，依旧通过RNA暴露。RNA信息会得到默认值：像用户界面名称这类物体将从ID属性名称得到，数值范围则会根据其类型得到默认值。 为了简化没有对应RNA属性的ID属性的API，可使用函数RNA_property_*得到实际的PropertyRNA*，或者使用IDProperty*强制转换得到PropertyRNA*。内置函数会检测出哪个数据结构体被使用。因此，对成员PropertyRNA*的访问必须通过访问器函数，而不是直接访问该成员。","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"Blender官方源码文档——ID Datablocks","slug":"Blender-source-code-study-06","date":"2021-05-08T09:50:42.000Z","updated":"2021-05-10T02:21:58.106Z","comments":true,"path":"2021/05/08/Blender-source-code-study-06/","link":"","permalink":"https://www.chaguake.com/2021/05/08/Blender-source-code-study-06/","excerpt":"","text":"最新的官方文档：目录 本文的原文在这里 ID数据块（ID Datablocks）对象（objects）、网格（meshes）、材料（materials）、场景（scenes），它们都是ID数据块的例子。它们通常定义在头文件DNA_&#123;some type&#125;_typed.h中。 ID数据块是以一组公共属性开始的内存块。在C中，它被定义为结构体，并且会嵌入一个ID结构体类型作为第一个字段。如果它有存放动画数据的动画数据结构体，则这个动画数据结构体会是第二个字段。 12345typedef struct Mesh &#123; ID id; struct AnimData *adt; …&#125;; 数据块的名称（pointer-&gt;id.name）标识了数据块的类型。举个例子，一个Blender用户界面中显示的网格，它叫“Suzanne”，但在数据块中实际叫“MESuzanne”。可以使用ID *id得到正确的类型。函数GS(id-&gt;name)可以获取名称对应的ID数据类型常量——if (GS(id-&gt;name) == ID_SC) ...，可以用于检测场景中ID数据块。 ID数据类型的运行时注册（Runtime Registration of ID Types）2020年以前，ID数据块类型在Blender中是硬编码的。作为“代码清理日” 的一部分，它被转换成运行时的数据结构。本节介绍ID数据块类型新的注册方法。 运行时类型信息存储在结构体IDTypeInfo中。它包含结构体的元数据，以及一些指向通用函数的指针（创建、拷贝、删除、本地化等等）。下面举个例子，用于实现一个对象： 123456789101112131415IDTypeInfo IDType_ID_OB &#x3D; &#123; .id_code &#x3D; ID_OB, .id_filter &#x3D; FILTER_ID_OB, .main_listbase_index &#x3D; INDEX_ID_OB, .struct_size &#x3D; sizeof(Object), .name &#x3D; &quot;Object&quot;, .name_plural &#x3D; &quot;objects&quot;, .translation_context &#x3D; BLT_I18NCONTEXT_ID_OBJECT, .flags &#x3D; 0, .init_data &#x3D; object_init_data, .copy_data &#x3D; object_copy_data, .free_data &#x3D; object_free_data, .make_local &#x3D; object_make_local,&#125;; 添加一个新的ID数据块类型（Adding a new ID Type）要添加一个新的IDTypeInfo，你需要： 在相关BKE的实现文件（比如ID_ME的实现文件是mesh.c）中定义IDTypeInfo。 在该文件的开头添加静态回调函数和IDTypeInfo结构体定义。 如果你需要额外的帮手，只添加它们的前置声明，然后在它们的定义下方实现它们。这使得每个ID数据块类型实现文件的公共信息和特定API分离。 这个新的IDTypeInfo应该根据它的识别码来命名。 在文件BKE_idtype.h中为这个新的ID数据块类型添加extern声明。 在文件idtype.c中调用函数id_type_init()来注册这个新的IDTypeInfo。 处理ID数据块类型的函数（Functions for Handling ID Types）这里有有各种各样的函数可用于ID数据块。在这里列出来必然会出现过时的情况，所以只需阅读文件BKE_idtype.h即可。","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"Blender官方源码文档——Dependency Graph","slug":"Blender-source-code-study-05","date":"2021-05-08T07:18:14.000Z","updated":"2021-05-08T09:48:34.391Z","comments":true,"path":"2021/05/08/Blender-source-code-study-05/","link":"","permalink":"https://www.chaguake.com/2021/05/08/Blender-source-code-study-05/","excerpt":"","text":"最新的官方文档：目录 本文的原文在这里 Blender 2.8：依赖关系图 本文档涵盖了依赖关系图的所有设计规范，以支持Blender 2.8项目的所有新功能。 简介（Introduction）首先，我们得了解依赖关系图是什么，在任何情况下它应该做什么和不应该做什么。依赖关系图的主要目标是确保场景数据在发生任何更改时，以最有效的方式正确地更新。这意味着依赖关系图只更新依赖于修改后的数值，而不会更新那些没有更改的数据。这样子，艺术家（artists）总是以最大帧更新速率让场景处于有意义的状态。依赖关系图通过预处理场景来实现的——创建一个图，其节点是场景的实体（例如，对象），边则是这些对象之间的关系（例如，当对象A拥有一个父对象B，这个图就有一条处于两个对象之间的边）。 简单来说，依赖关系图负责场景的动态更新（dynamic updates），其中一些数值随着时间而变化。它不负责一次性的改变（one-time changes）。举个例子，依赖关系图负责f曲线的求值，但不负责网格编辑模式下边的细分操作。 概述（Overview）最新的设计概述相当简单，如下图所示： 与2.7x系列的差别如下： DNA数据直接从.blend文件中传递，它简单小巧，只需在外部存储中代表场景。 DNA数据没有运行时字段。 依赖关系图将所有必需的更改（modifiers, constraints, etc）应用到DNA数据的副本上。我们称它们为生成数据（generated data）。 依赖关系图存储自身的评估结果。任何的改变都不会应用到源DNA数据（original DNA）。 渲染引擎使用依赖关系图提供的生成数据（generated data），并且不会接触源DNA数据（original DNA）。 渲染引擎将具有通用且集中的API，用于存储引擎特定的数据。 这些更改都需要支持像在不同窗口不同状态下实现覆盖和场景这样的特性。它看起来简单，但是它会引导一些重大的设计决定，去尽可能地覆盖所有工具和边缘情况（corner cases）。 依赖关系图的所有权（Dependency graph ownership）在回答是谁拥有依赖关系图的问题之前，让我们简单地讨论下工作区（workspaces）。 工作区是组织艺术家（artists）工作流程的一种方式。活动工作区指针存储在每一个窗口（window）中，因此，窗口始终有且仅有一个活动工作区。工作区本身定义了渲染引擎（可以说是与场景渲染引擎相同，但又不完全一样）。工作区还定义了活动场景层（active scene layer），即在工作区编辑器中皆可见。 这些都是非常重要的声明，理由是渲染引擎和活动场景层都定义了如何去计算对象的最终状态。因此，渲染引擎可以设置一些简单的配置，活动场景层可以拥有覆盖（overrides）。 这里的决定代表着是窗口（window）拥有依赖关系图（对于交互操作和最终呈现，请看下文）。当艺术家（artists）改变了工作区，或者选择了另一个渲染引擎和场景层，窗口就会被要求重新创建它的依赖关系图，对应新的窗口/工作区状态。 对于最终的F12渲染所有权则更简单些，依赖关系图由渲染结构拥有。 通过这个方式，我们尽可能快地对可见数据（visible data）进行场景评估，并支持所有需要上下文关联的覆盖。 生成数据与写入时复制（Generated data and copy on write）","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"Blender官方源码文档——Context","slug":"Blender-source-code-study-04","date":"2021-05-07T09:12:07.000Z","updated":"2021-05-08T09:33:34.842Z","comments":true,"path":"2021/05/07/Blender-source-code-study-04/","link":"","permalink":"https://www.chaguake.com/2021/05/07/Blender-source-code-study-04/","excerpt":"","text":"最新的官方文档：目录 本文的原文在这里 Context在2.5中，bContext结构体被添加进来，作为全局变量的替代品，更明确地去创建上下文（make context）。比如，操作类、Python脚本和绘制代码，它们都能在定义好的上下文（context）中正常使用。 Blender的上下文（Context）由bContext结构体表示，其API定义在BKE_context.h文件中。获取上下文（context）信息几乎都是使用CTX_data_*或者CTX_wm_*这些类型的函数（它们将bContext结构体对象作为参数），而设置上下文（context）则可以在screens、areas或者regions中懒设置（done lazily）。 What’s in the context?在以下那张图中，值得注意是，它并不反映谁调用谁，而是反映出有哪些不同类型的数据是在上下文（context）中的。 User Preferences是全局的、且并非是真正意义上的上下文，所有的代码都可以访问它。紧接着是Main，是一个拥有自己数据块的.blend文件，还包括了相关联的.blend文件的数据块。我们应该假设有很多个这样子的文件同时被打开，但现在还未能实现。 接下来出现了分歧，绘制（drawing）和交互式编辑代码（interactive editing code）可假设是跑在Window Manager下。他们总是工作在某一层级（Screen、Area或者Region）中。随着这些层级有了一定的数据，屏幕（the screen）就会拥有一个活动场景（active Scene），并且区域（areas and regions）可以额外地将其他的数据放进上下文（context），当然，这取决于区域的类型。 此外，我们有一些代码不能设定是窗口管理（window manager）控制的。但也不意味着它们不能被窗口管理调用，只是表示这些代码不属于窗口管理，也不需要使用窗口管理的方式调用它。这些代码可以不需要窗口选项而直接在后台运行，通常是用于渲染（rendering）、求值（Evalution）。渲染通常是通过一个场景和一些不在bContext结构体中的数据。 文件读写、内核函数以及窗口管理代码这些并没有显示在图中。但事实上，它们或多或少都存在上下文中，或者根本不包含在上下文指针中。 Setting Context首先我们得知道上下文（context）并不是持久化的。如果你想改变一个活动物体（active object），并非是通过上下文（context）设置它来实现。应当在场景（Scene）中设置对应的属性，然后再在上下文（context）中查找使用。上下文是进行操作（operator）或者绘制（drawing）时的临时本地状态。 Callbacks 上下文（context）主要由回调（callbacks）组成。屏幕（the Scene）、空间类型（space types）和区域类型（region types）都拥有一个上下文回调函数。这个函数接受一个上下文成员的名称，然后检查这个上下文是否知道这个成员，如果有，则返回一个RNA指针或者一个RNA指针集合。另外，每一个上下文回调都应该提供一个上下文成员列表。 举个例子，一个图片窗口空间类型的回调： 123456789101112131415static int image_context(const bContext *C, const char *member, bContextDataResult *result)&#123; SpaceImage *sima&#x3D; CTX_wm_space_image(C); if(CTX_data_dir(member)) &#123; static const char *dir[] &#x3D; &#123;&quot;edit_image&quot;, NULL&#125;; CTX_data_dir_set(result, dir); &#125; else if(CTX_data_equals(member, &quot;edit_image&quot;)) &#123; CTX_data_id_pointer_set(result, (ID*)ED_space_image(sima)); return 1; &#125; return 0;&#125; UI Layouts 此外，还可以为UI布局指定更具体的上下文。主要用于修改器（modifiers）或者约束（constraints）。对于每一个修改器UI布局箱（modifier UI layout box），“修改器”设置进上下文，然后所有来自这个UI布局箱按钮的操作都可以从它的上下文中找到。 1box.set_context_pointer(&quot;group&quot;, group) Lookups 当一个上下文成员被请求，UI布局的上下文首先会被查找，接下来是区域回调（region callback,area callback）和屏幕回调（screen callback）。如果它被找到，就会返回对应的指针，假如找不到，则会返回一个空指针或者空集合。 Getting ContextWindow Manager 窗口管理上下文是最简单的，它仅仅是一些screen、area、space data、region和region data的指针。主要是你得确保它们应该被包含在上下文中。对于绘制函数，它们是相当清晰的，对于操作函数，在poll函数中进行检查或者在运行时验证是很重要的。如果不这样子做，用于在使用配置密钥映射时会导致崩溃。 Data 数据上下文就比较复杂了，重要的一点是要理解它是基于RNA指针集合的。这也可以使得python脚本自动用得了上下文。 在C中有两种方法去获取上下文的数据。某些访问器早已定义。请注意，在内部依旧是使用“edit_object”字符串来获取值，毕竟这很方便。 1Object *obedit&#x3D; CTX_data_edit_object(C); 其它的那些可能没被定义，需要使用字符串去查找上下文成员。这并不能确保数据类型是正确的，所以需要指定想要的数据类型。下面例子返回一个RNA指针（注意看函数后面的.data）。 1Object *obedit&#x3D; CTX_data_pointer_get_type(C, &quot;edit_object&quot;, &amp;RNA_Object).data; 在Python中更简单了，上下文的成员相当于它的属性（properties）。 1obedit &#x3D; context.object_edit 集合（collections）也可以使用的，使用内部提供的宏会更加便捷。 1234CTX_DATA_BEGIN(C, Base*, base, selected_editable_bases) &#123; printf(&quot;object: %s\\n&quot;, base-&gt;object-&gt;id.name);&#125;CTX_DATA_END; Where to look 并没有一个地方可以看到列表中所有的上下文成员。但可以找到某一个上下文成员，最好的方法是查找其相关的回调。也就是说，如果你正在使用图片窗口（image window），可以在space_image.c文件中查找上下文回调函数。 在Python中，可以实时地查找上下文： 1print(dir(context)) Always Available 一些上下文成员总是被设置，它们不需要使用poll函数去检查。 12345678CTX_wm_managerCTX_wm_windowCTX_wm_screenCTX_data_mainCTX_data_sceneCTX_data_tool_settings API更多的信息，可以在以下的文件中找到： 12source&#x2F;blender&#x2F;blenkernel&#x2F;BKE_context.hsource&#x2F;blender&#x2F;blenkernel&#x2F;intern&#x2F;context.c","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"Blender源码学习（三）——Blender工具窗口和控件实现的调用过程","slug":"Blender-source-code-study-03","date":"2021-04-30T09:27:17.000Z","updated":"2021-05-08T09:33:59.372Z","comments":true,"path":"2021/04/30/Blender-source-code-study-03/","link":"","permalink":"https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/","excerpt":"","text":"在Blender源码学习（一）——blender项目，Blender main()入口一文中讲解了Blender工具的程序入口，以及在文章末尾给出Blender源码层级布局。 Blender工具涉及的模块很多，可以从“窗口是如何做到跨平台实现”这一点作为切入点，先学习工具的“骨架”，然后再学习其他各个模块的实现。 涉及模块ghost ghost位于intern目录下，是blender标准的跨平台操作系统工具（Stands for General Handy Operating System Toolkit）。 ghost主要负责窗口管理行为（window management actions）、OpenGL上下文和鼠标键盘事件（也包括一些不常见的硬件设备），底层使用继承多态方式实现调用对应操作系统的API。 值得注意的是，ghost是C++编写的，而blender是C编写的，所以ghost封装了一层，满足C调用C++代码的需求。 windowmanager windowmanager位于source/blender目录下，负责blender窗口管理、事件系统、操作管理、线程管理等，作为窗口和功能的逻辑调度者。 editors editors位于source/blender目录下，负责图形、工具和图形的绘制。 窗口实现流程Blender工具实现主要分两个部分，第一部分是用ghost创建的窗口（window），另一部分是使用OpenGL绘制的屏幕（screen）。 前者是框架，使用操作系统API创建的空白窗口；后者是内容，使用OpenGL的glew库绘制。 ghost窗口 调用路径如下： main函数（creator.c） -&gt; WM_init函数（wm_init_exit.c） -&gt; wm_homefile_read函数（wm_files.c） -&gt; WM_check函数（wm.c） -&gt; wm_window_ghostwindows_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_add（wm_window.c） -&gt; GHOST_CreateWindow函数。 screen 调用路径如下： main函数（creator.c） -&gt; WM_main函数（wm.c） -&gt; wm_window_process_events函数（wm_window.c） -&gt; GHOST_DispatchEvents函数（GHOST_C-api.cpp） -&gt; dispatchEvents函数（GHOST_System.cpp） -&gt; dispatchEvents函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; processEvent函数 -&gt; ghost_event_proc函数（wm_window.c）-&gt; wm_draw_update（wm_window.c） -&gt; wm_draw_window函数（wm_draw.c）···。 到wm_draw_update这一步的时候，wm_draw_window函数实现窗口绘制，wm_window_swap_buffers函数实现双缓冲，交换前后台数据。 12345678910void wm_draw_update(bContext *C)&#123;... wm_draw_window(C, win); wm_draw_update_clear_window(C, win); wm_window_swap_buffers(win);...&#125; wm_draw_window函数有两个操作，首先将所有的regions绘制出来，然后再把regions绘制在screen中。 12345678910111213141516static void wm_draw_window(bContext *C, wmWindow *win)&#123; bScreen *screen &#x3D; WM_window_get_active_screen(win); ... &#x2F;* Draw area regions into their own framebuffer. This way we can redraw * the areas that need it, and blit the rest from existing framebuffers. *&#x2F; wm_draw_window_offscreen(C, win, stereo); ... &#x2F;* Now we draw into the window framebuffer, in full window coordinates. *&#x2F; wm_draw_window_onscreen(C, win, -1); ...&#125; What’s in the context?官方文档 上面图片展示了Blender模块之间的层级关系。 最顶层User Preferences为Main函数中创建的全局的bContext对象。 第二层Main表示一个.blender文件数据，包含其关联的其他.blender文件。 接下来分成两大块——Window Manager和Scene，前者负责窗口事件一类，后者负责场景数据块和渲染，这一类的操作数据可以不经过bContext进行数据传递。","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"Blender源码学习（二）——一些重要的结构体","slug":"Blender-source-code-study-02","date":"2021-04-30T02:35:03.000Z","updated":"2021-05-07T08:28:12.872Z","comments":true,"path":"2021/04/30/Blender-source-code-study-02/","link":"","permalink":"https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/","excerpt":"","text":"bContext结构体定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;&#x2F;context.cstruct bContext &#123; int thread; &#x2F;* windowmanager context *&#x2F; struct &#123; struct wmWindowManager *manager; struct wmWindow *window; struct WorkSpace *workspace; struct bScreen *screen; struct ScrArea *area; struct ARegion *region; struct ARegion *menu; struct wmGizmoGroup *gizmo_group; struct bContextStore *store; &#x2F;* Operator poll. *&#x2F; &#x2F;** * Store the reason the poll function fails (static string, not allocated). * For more advanced formatting use &#96;operator_poll_msg_dyn_params&#96;. *&#x2F; const char *operator_poll_msg; &#x2F;** * Store values to dynamically to create the string (called when a tool-tip is shown). *&#x2F; struct bContextPollMsgDyn_Params operator_poll_msg_dyn_params; &#125; wm; &#x2F;* data context *&#x2F; struct &#123; struct Main *main; struct Scene *scene; int recursion; &#x2F;** True if python is initialized. *&#x2F; bool py_init; void *py_context; &#x2F;** * If we need to remove members, do so in a copy * (keep this to check if the copy needs freeing). *&#x2F; void *py_context_orig; &#125; data;&#125;; bContext结构体是Blender程序的上下文（整个程序只有一个），包含窗口管理者上下文（windowmanager context）和数据上下文（data context）。 bContext结构体中的对象通常使用CTX_data_*和CTX_wm_*函数中获取，并且其参数通常是延迟初始化。 bContext结构体对象在creator.c文件的main函数中创建，在main函数中使用情况如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849...bContext *C;...C &#x3D; CTX_create();...main_args_setup(C, ba);...WM_init(C, argc, (const char **)argv);...CTX_py_init_set(C, true);...WM_keyconfig_init(C);...FRS_set_context(C);...main_args_setup_post(C, ba);...#ifndef WITH_PYTHON_MODULE if (G.background) &#123; &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F; WM_exit(C); &#125; else &#123; if (!G.file_loaded) &#123; WM_init_splash(C); &#125; WM_main(C); &#125;#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;... Global定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x2F;&#x2F;BKE_global.htypedef struct Global &#123; &#x2F;** Active pointers. *&#x2F; struct Main *main; &#x2F;** Strings: last saved *&#x2F; char ima[1024], lib[1024]; &#x2F;* 1024 &#x3D; FILE_MAX *&#x2F; &#x2F;** When set: &#96;G_MAIN-&gt;name&#96; contains valid relative base path. *&#x2F; bool relbase_valid; bool file_loaded; bool save_over; &#x2F;** Strings of recent opened files. *&#x2F; struct ListBase recent_files; &#x2F;** Has escape been pressed or Ctrl+C pressed in background mode, used for render quit. *&#x2F; bool is_break; bool background; bool factory_startup; short moving; &#x2F;** To indicate render is busy, prevent render-window events etc. *&#x2F; bool is_rendering; &#x2F;** * Debug value, can be set from the UI and python, used for testing nonstandard features. * DO NOT abuse it with generic checks like &#96;if (G.debug_value &gt; 0)&#96;. Do not use it as bitflags. * Only precise specific values should be checked for, to avoid unpredictable side-effects. * Please document here the value(s) you are using (or a range of values reserved to some area). * * -16384 and below: Reserved for python (add-ons) usage. * * -1: Disable faster motion paths computation (since 08&#x2F;2018). * * 1 - 30: EEVEE debug&#x2F;stats values (01&#x2F;2018). * * 101: Enable UI debug drawing of fullscreen area&#39;s corner widget (10&#x2F;2014). * * 666: Use quicker batch delete for outliners&#39; delete hierarchy (01&#x2F;2019). * * 777: Enable UI node panel&#39;s sockets polling (11&#x2F;2011). * * 799: Enable some mysterious new depsgraph behavior (05&#x2F;2015). * * 1112: Disable new Cloth internal springs handling (09&#x2F;2014). * * 1234: Disable new dyntopo code fixing skinny faces generation (04&#x2F;2015). * * 3001: Enable additional Fluid modifier (Mantaflow) options (02&#x2F;2020). * * 4000: Line Art state output and debugging logs (03&#x2F;2021). * * 16384 and above: Reserved for python (add-ons) usage. *&#x2F; short debug_value; &#x2F;** Saved to the blend file as #FileGlobal.globalf, * however this is now only used for runtime options. *&#x2F; int f; struct &#123; &#x2F;** Logging vars (different loggers may use). *&#x2F; int level; &#x2F;** FILE handle or use stderr (we own this so close when done). *&#x2F; void *file; &#125; log; &#x2F;** debug flag, #G_DEBUG, #G_DEBUG_PYTHON &amp; friends, set python or command line args *&#x2F; int debug; &#x2F;** This variable is written to &#x2F; read from #FileGlobal.fileflags *&#x2F; int fileflags; &#x2F;** Message to use when auto execution fails. *&#x2F; char autoexec_fail[200];&#125; Global;&#x2F;&#x2F;blender.cGlobal G; Global结构体主要是存放一些全局定义的变量、处于激活状态的节点（Active pointers）对象指针以及已经打开的文件链表（Strings of recent opened files）对象指针。","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"Blender源码学习（一）——blender项目，Blender main()入口","slug":"Blender-source-code-study-01","date":"2021-04-29T02:52:14.000Z","updated":"2021-04-30T01:32:20.369Z","comments":true,"path":"2021/04/29/Blender-source-code-study-01/","link":"","permalink":"https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/","excerpt":"","text":"blender项目概括blender项目是Blender整个工程的入口，该项目输出文件为blender.exe。 blender项目位于/blender/source/creator目录下，文件只有几个：creator_intern.h、buildinfo.c、creator.c、creator_args.c、creator_signals.c。 其中，creator.c是关键文件，而其主要是包含一个main函数。 main函数主要工作是： 解析启动参数 根据启动参数启动各个子系统 检查是否后台运行，如果是，则使用Less-UI后台运行，否则，使用Use-UI运行。 主要的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#x2F;** * Blender&#39;s main function responsibilities are: * - setup subsystems. * - handle arguments. * - run #WM_main() event loop, * or exit immediately when running in background-mode. *&#x2F;int main(int argc,#ifdef WIN32 const char **UNUSED(argv_c)#else const char **argv#endif)&#123; bContext *C; &#x2F;* Ensure we free data on early-exit. *&#x2F; struct CreatorAtExitData app_init_data &#x3D; &#123;NULL&#125;; BKE_blender_atexit_register(callback_main_atexit, &amp;app_init_data); &#x2F;* NOTE: Special exception for guarded allocator type switch: * we need to perform switch from lock-free to fully * guarded allocator before any allocation happened. *&#x2F; &#123; int i; for (i &#x3D; 0; i &lt; argc; i++) &#123; if (STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)) &#123; printf(&quot;Switching to fully guarded memory allocator.\\n&quot;); MEM_use_guarded_allocator();&#x2F;&#x2F;使用守卫式内存分配器 break; &#125; if (STREQ(argv[i], &quot;--&quot;)) &#123; break; &#125; &#125; MEM_init_memleak_detection();&#x2F;&#x2F;初始化内存检测模块 &#125; &#x2F;* Initialize logging. *&#x2F; CLG_init(); CLG_fatal_fn_set(callback_clg_fatal); C &#x3D; CTX_create(); #ifdef WITH_LIBMV &#x2F;&#x2F;libmv为多视图重建库（LMV），是Blender运动跟踪能力的计算机视觉后端。 libmv_initLogging(argv[0]);#elif defined(WITH_CYCLES_LOGGING) CCL_init_logging(argv[0]);#endif &#x2F;* Error output from the guarded allocation routines. *&#x2F; main_callback_setup(); &#x2F;*start initialize subsystem*&#x2F; ... &#x2F;*end initialiize subsystem*&#x2F;#if defined(WITH_PYTHON_MODULE) || defined(WITH_HEADLESS) &#x2F;* Python module mode ALWAYS runs in background-mode (for now). *&#x2F; G.background &#x3D; true;#else if (G.background) &#123; main_signal_setup_background(); &#125;#endif &#x2F;* Background render uses this font too. *&#x2F; BKE_vfont_builtin_register(datatoc_bfont_pfb, datatoc_bfont_pfb_size); &#x2F;* Explicitly free data allocated for argument parsing: * - &#39;ba&#39; * - &#39;argv&#39; on WIN32. *&#x2F; callback_main_atexit(&amp;app_init_data); BKE_blender_atexit_unregister(callback_main_atexit, &amp;app_init_data); &#x2F;* End argument parsing, allow memory leaks to be printed. *&#x2F; MEM_use_memleak_detection(true);#ifndef WITH_PYTHON_MODULE if (G.background) &#123; &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F; WM_exit(C); &#125; else &#123; if (!G.file_loaded) &#123; WM_init_splash(C); &#125; WM_main(C); &#125;#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F; return 0;&#125; 知识点1、UNUSED宏12345678910111213141516171819202122&#x2F;&#x2F;BLI_memory_utils.h&#x2F;* UNUSED macro, for function argument *&#x2F;#if defined(__GNUC__) || defined(__clang__)# define UNUSED(x) UNUSED_##x __attribute__((__unused__))#else# define UNUSED(x) UNUSED_##x#endif#if defined(__GNUC__) || defined(__clang__)# define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_##x#else# define UNUSED_FUNCTION(x) UNUSED_##x#endif&#x2F;&#x2F;creator.cint main(int argc,#ifdef WIN32 const char **UNUSED(argv_c)#else const char **argv#endif) 在main函数中使用了GNU C 的一个特性——__attribute__((__unused__))，用于编译时忽略未使用的警告。 2、setvbuf(stdout, NULL, _IONBF, 0)123456789&#x2F;&#x2F;creator.c &#x2F;* Un-buffered &#96;stdout&#96; makes &#96;stdout&#96; and &#96;stderr&#96; better synchronized, and helps * when stepping through code in a debugger (prints are immediately * visible). However disabling buffering causes lock contention on windows * see T76767 for details, since this is a debugging aid, we do not enable * the un-buffered behavior for release builds. *&#x2F;#ifndef NDEBUG setvbuf(stdout, NULL, _IONBF, 0);#endif 使用setvbuf函数将输出缓冲去掉，信息可以更快的同步。 3、_putenv_s函数123# if defined(_MSC_VER) _putenv_s(&quot;OMP_WAIT_POLICY&quot;, &quot;PASSIVE&quot;);&#x2F;&#x2F;添加程序的环境变量# endif _putenv_s函数可添加程序的环境变量（并非加在电脑全局环境变量中），对应获取程序的环境变量的函数是getenv_s。 4、宏实现N个参数同时对比1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#x2F;&#x2F;BLI_utildefines_variadic.h#define _VA_NARGS_GLUE(x, y) x y#define _VA_NARGS_RETURN_COUNT(\\ _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _10_, _11_, _12_, _13_, _14_, _15_, _16_, \\ _17_, _18_, _19_, _20_, _21_, _22_, _23_, _24_, _25_, _26_, _27_, _28_, _29_, _30_, _31_, _32_, \\ _33_, _34_, _35_, _36_, _37_, _38_, _39_, _40_, _41_, _42_, _43_, _44_, _45_, _46_, _47_, _48_, \\ _49_, _50_, _51_, _52_, _53_, _54_, _55_, _56_, _57_, _58_, _59_, _60_, _61_, _62_, _63_, _64_, \\ count, ...) count#define _VA_NARGS_EXPAND(args) _VA_NARGS_RETURN_COUNT args#define _VA_NARGS_OVERLOAD_MACRO2(name, count) name##count#define _VA_NARGS_OVERLOAD_MACRO1(name, count) _VA_NARGS_OVERLOAD_MACRO2(name, count)#define _VA_NARGS_OVERLOAD_MACRO(name, count) _VA_NARGS_OVERLOAD_MACRO1(name, count)&#x2F;* --- expose for re-use --- *&#x2F;&#x2F;* 64 args max *&#x2F;#define VA_NARGS_COUNT(...) _VA_NARGS_EXPAND((__VA_ARGS__, \\ 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, \\ 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, \\ 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, \\ 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))#define VA_NARGS_CALL_OVERLOAD(name, ...) \\ _VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))&#x2F;&#x2F;BLI_string.h&#x2F;* Manual line breaks for readability. *&#x2F;&#x2F;* clang-format off *&#x2F;&#x2F;* STR_ELEM#(v, ...): is the first arg equal any others? *&#x2F;&#x2F;* Internal helpers. *&#x2F;#define _VA_STR_ELEM2(v, a) (strcmp(v, a) &#x3D;&#x3D; 0)#define _VA_STR_ELEM3(v, a, b) \\ (_VA_STR_ELEM2(v, a) || (_VA_STR_ELEM2(v, b)))#define _VA_STR_ELEM4(v, a, b, c) \\ (_VA_STR_ELEM3(v, a, b) || (_VA_STR_ELEM2(v, c)))#define _VA_STR_ELEM5(v, a, b, c, d) \\ (_VA_STR_ELEM4(v, a, b, c) || (_VA_STR_ELEM2(v, d)))#define _VA_STR_ELEM6(v, a, b, c, d, e) \\ (_VA_STR_ELEM5(v, a, b, c, d) || (_VA_STR_ELEM2(v, e)))#define _VA_STR_ELEM7(v, a, b, c, d, e, f) \\ (_VA_STR_ELEM6(v, a, b, c, d, e) || (_VA_STR_ELEM2(v, f)))#define _VA_STR_ELEM8(v, a, b, c, d, e, f, g) \\ (_VA_STR_ELEM7(v, a, b, c, d, e, f) || (_VA_STR_ELEM2(v, g)))#define _VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) \\ (_VA_STR_ELEM8(v, a, b, c, d, e, f, g) || (_VA_STR_ELEM2(v, h)))#define _VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) \\ (_VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) || (_VA_STR_ELEM2(v, i)))#define _VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) \\ (_VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) || (_VA_STR_ELEM2(v, j)))#define _VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) \\ (_VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) || (_VA_STR_ELEM2(v, k)))#define _VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) \\ (_VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) || (_VA_STR_ELEM2(v, l)))#define _VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) \\ (_VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) || (_VA_STR_ELEM2(v, m)))#define _VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) \\ (_VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) || (_VA_STR_ELEM2(v, n)))#define _VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) \\ (_VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) || (_VA_STR_ELEM2(v, o)))#define _VA_STR_ELEM17(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) \\ (_VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) || (_VA_STR_ELEM2(v, p)))&#x2F;* clang-format on *&#x2F;&#x2F;* reusable STR_ELEM macro *&#x2F;#define STR_ELEM(...) VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)&#x2F;&#x2F;creator.cSTR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;) STR_ELEM宏实现了第一个参数与其他每个参数对比的能力，最后一层宏为_VA_STR_ELEM5(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)，最终展开为(((strcmp(argv[i], &quot;-d&quot;) == 0) || (strcmp(argv[i], &quot;--debug&quot;) == 0)) || (strcmp(argv[i], &quot;--debug-memory&quot;) == 0)))...。 这个宏有两个限制，其一是_VA_STR_ELEM系列宏的数量，在源码中只能处理16个参数的对比；其二是VA_NARGS_COUNT和_VA_NARGS_RETURN_COUNT宏枚举的数字，源码中最大值是64，超过64个参数的宏调用会报错。 下面解释下STR_ELEM宏的展开过程： 首先，STR_ELEM(...)展开成VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)，_VA_STR_ELEM是字符串，用于拼接_VA_STR_ELEM系列宏的前缀，__VA_ARGS__为可变参数的宏。 然后，VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)展开成_VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))，_VA_NARGS_GLUE宏接受两个参数，然后将他们并排拼接（就比如f(x)中的f和(x)）。第一个参数是_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))，第二个参数是(__VA_ARGS__)。 _VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))中，_VA_NARGS_OVERLOAD_MACRO和VA_NARGS_COUNT宏的层级是一样的，前者是将参数name和VA_NARGS_COUNT(__VA_ARGS__)拼接，后者返回参数的个数。 Blender code layout","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"}]},{"title":"blender快捷键汇总","slug":"blender-hot-key","date":"2021-04-28T03:09:11.000Z","updated":"2021-04-28T07:34:26.934Z","comments":true,"path":"2021/04/28/blender-hot-key/","link":"","permalink":"https://www.chaguake.com/2021/04/28/blender-hot-key/","excerpt":"","text":"文章参考： Blender2.9入门篇 模拟游戏引擎角色操作（第一人称视角）快捷键：Shift + ~ 在blender下面的状态栏会有操作按键提示。 常用快捷键1、快捷键：Ctrl + Tab 弹出模式选择导航，鼠标移动选择（也可以左上角点击下拉框选择）。 2、快捷键：Tab 快速进入编辑模式，再按一次返回物体模式。 3、快捷键：G 移动选中物体，左键确认，右键取消。 再点击X或Y或Z键，可沿对应轴水平移动。 按住鼠标中键，可以在xyz轴上，快速实现物体从一个轴跳到另一个轴，并且带上对原点的偏移量。 4、快捷键：Alt + G 物体位置回归原点(0,0,0)。 5、快捷键：Shift + A 打开Add菜单。 6、快捷键：Ctrl + N 打开New File菜单。 7、快捷键：长按Shift + 其他 微调操作，使得数值增值步长变小。 8、快捷键：Shift + R 重复上一个命令。 9、快捷键：Ctrl + Z 撤销操作。 10、快捷键：F3 弹出操作搜索窗口。 11、快捷键：F2 选中物体重命名。 12、快捷键：Ctrl + Space 视图最大化（右侧停靠窗隐藏）。 13、快捷键：Ctrl + Shift + Space 视图全屏。 14、快捷键：Z 弹出着色方式选择导航，鼠标移动选择（也可以右上角点击选择）。 15、快捷键：Shift + Z 线框显示和实体显示切换。 16、快捷键：Ctrl + ~ 显示/隐藏Gizmo（视图右上角竖着排列的控件）。 17、快捷键：鼠标中键 + 上下移动 自由切换视角。 18、快捷键：Alt + 鼠标中键 + 上下移动 切换六个正视角（顶、底、前、后、左、右）。 也可以用数字键盘来切换视角： 操作 快捷键 切换到顶视角 7 切换到底视角 Ctrl + 7 切换到前视角 1 切换到后视角 Ctrl + 1 切换到右视角 3 切换到左视角 Ctrl + 3 切换到摄像机视角 0 正交视图和透视图切换 5 四视图和透视图切换 Ctrl + Alt + Q 上下旋转视角 8或2 左右旋转视角 6或4 视角旋转180° 9 19、快捷键：N 显示/隐藏视图右侧停靠窗口。 20、快捷键：Shift + 鼠标中键 自由移动视图。 21、快捷键：H 隐藏选中项。 22、快捷键：Shift + H 隐藏未选中项。 23、快捷键：Alt + H 显示所有隐藏对象。 24、快捷键：数字键盘/ 居中放大选中对象，再次点击返回原来视角。 25、快捷键：数字键盘. 居中放大选中对象，不会返回原来视角。 26、快捷键：Home 或者 Shift + C 完整显示场景所有对象（被隐藏除外）。 27、快捷键：Ctrl + A 打开Apply菜单。 28、快捷键：T 显示/隐藏视图左侧工具菜单。 29、快捷键：Shift + Space 打开工具菜单，跟视图左侧工具菜单一样。 30、快捷键：Shift + 鼠标右键 放置游标在鼠标位置。 31、快捷键：Shift + C 将游标放在原点(0,0,0)。 32、快捷键：Shift + S 打开游标菜单导航。 33、快捷键：&lt; 变换坐标系。同样可在视图上方点击下拉框切换。 34、快捷键：&gt; 变换轴心点。同样可在视图上方点击下拉框切换。 35、快捷键：Shift + D 复制。 36、快捷键：Alt + D 关联复制。 37、快捷键：Ctrl + J 将选中的所有对象模型合并成一个对象模型。 38、快捷键：W 框选、套索、圈选工具切换。 39、快捷键：Ctrl + M 镜像（反向翻转），需要再输入轴键（X或Y或Z）。","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender工具","slug":"blender工具","permalink":"https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"}]},{"title":"OpenGL入门（四）——着色器","slug":"OpenGL-introduction-04","date":"2021-04-22T08:53:15.000Z","updated":"2021-04-23T02:03:07.418Z","comments":true,"path":"2021/04/22/OpenGL-introduction-04/","link":"","permalink":"https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/","excerpt":"","text":"英文原文地址 中文翻译地址 着色器（Shader）是运行在GPU上的小程序，用于图形渲染管线的某个特定部分。 而在OpenGL使用GLSL这一门着色器语言来实现着色器程序。 GLSL着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。 着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。 一个典型的着色器有下面的结构： 123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123; &#x2F;&#x2F; 处理输入并进行一些图形操作 ... &#x2F;&#x2F; 输出处理过的结果到输出变量 out_variable_name &#x3D; weird_stuff_we_processed;&#125; 向量GLSL包含C语言大部分默认的基础数据类型。 向量是GLSL中比较常用的数据类型，常见的类型形式如下（n代表分量的数量）： 类型 含义 vecn 包含n个float分量的默认向量 bvecn 包含n个bool分量的向量 ivecn 包含n个int分量的向量 uvecn 包含n个unsigned int分量的向量 dvecn 包含n个double分量的向量 向量支持重组特性，一个向量的分量可以由其他的向量组成： 123vec2 vect &#x3D; vec2(0.1, 0.1)vec4 result &#x3D; vec4(vect, 0.0, 0.0)vec4 result2 &#x3D; vec4(result.xyz, 1.0) 输入与输出GLSL定义了in和out关键字实现着色器的输入和输出。 下面举个例子，顶点着色器接收一个3个分量的顶点位置向量，然后输出一个4个分量的顶点颜色向量，它会作为片段着色器的输入。 顶点着色器代码： 12345678910#version 330 corelayout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为0out vec4 vertexColor; &#x2F;&#x2F; 为片段着色器指定一个颜色输出void main()&#123; gl_Position &#x3D; vec4(aPos, 1.0); &#x2F;&#x2F; 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor &#x3D; vec4(0.5, 0.0, 0.0, 1.0); &#x2F;&#x2F; 把输出变量设置为暗红色&#125; 片段着色器代码： 123456789#version 330 coreout vec4 FragColor;in vec4 vertexColor; &#x2F;&#x2F; 从顶点着色器传来的输入变量（名称相同、类型相同）void main()&#123; FragColor &#x3D; vertexColor;&#125; uniformuniform提供了从CPU应用程序向GPU着色器程序发送数据的能力。 并且，uniform变量是全局的，它必须在每个着色器程序对象中有且只有一个，并且它可以被着色器程序的任意着色器在任意阶段访问。 使用方法如下： 在片段着色器中定义uniform变量。 123456789#version 330 coreout vec4 FragColor;uniform vec4 ourColor; &#x2F;&#x2F; 在OpenGL程序代码中设定这个变量void main()&#123; FragColor &#x3D; ourColor;&#125; 在C/C++代码中，使用glGetUniformLocation函数获取该uniform变量，然后使用glUniform4f函数对其赋值。 12345float timeValue &#x3D; glfwGetTime();float greenValue &#x3D; (sin(timeValue) &#x2F; 2.0f) + 0.5f;int vertexColorLocation &#x3D; glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); 值得注意的是，如果glGetUniformLocation返回-1就代表没有找到这个位置值。 而且，glUniform4f函数是属于设置uniform函数族中的一个，因为OpenGL底层是C库，不支持重载。 传递多个属性在上面的例子中，只是传递了顶点位置的属性到顶点着色器上，那怎样才能传递多个属性呢？ 首先，先给出顶点属性数据： 123456float vertices[] &#x3D; &#123; &#x2F;&#x2F; 位置 &#x2F;&#x2F; 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, &#x2F;&#x2F; 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, &#x2F;&#x2F; 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f &#x2F;&#x2F; 顶部&#125;; 然后再顶点着色器代码中接收多个输入，每个输入使用(location = n)来做绑定： 1234567891011#version 330 corelayout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为 0 layout (location &#x3D; 1) in vec3 aColor; &#x2F;&#x2F; 颜色变量的属性位置值为 1out vec3 ourColor; &#x2F;&#x2F; 向片段着色器输出一个颜色void main()&#123; gl_Position &#x3D; vec4(aPos, 1.0); ourColor &#x3D; aColor; &#x2F;&#x2F; 将ourColor设置为我们从顶点数据那里得到的输入颜色&#125; (location = n)对应C/C++代码中glVertexAttribPointer函数的第一个参数： 123456&#x2F;&#x2F; 位置属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);&#x2F;&#x2F; 颜色属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));glEnableVertexAttribArray(1); 给出顶点数据的存储结构图： 最后输出结果如下：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"第一章 Go语言基础——函数、方法和接口","slug":"Go-base-knowledge-02","date":"2021-04-21T02:59:56.000Z","updated":"2021-04-21T07:20:07.507Z","comments":true,"path":"2021/04/21/Go-base-knowledge-02/","link":"","permalink":"https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/","excerpt":"","text":"1.4 函数、方法和接口函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口定义了方法的集合。 Go语言通过隐式接口机制实现鸭子面向对象模型（所谓鸭子就是走路像鸭子，叫声像鸭子，那么它就可以当作鸭子）。 1.4.1 函数函数是一个操作序列，可以把它赋值给变量。 12345678910111213141516&#x2F;&#x2F;具名函数func Add(a, b int) &#123; return a+b&#125;var add &#x3D; Addadd(1, 2)Add(1, 2)&#x2F;&#x2F;匿名函数var Add &#x3D; func(a, b int) &#123; return a+b&#125;Add(1, 2) 函数的参数和返回值可以有多个，支持可变参数。 123456789101112func Swap(a, b int) &#123; return b, a&#125;func Sum(a int, more ...int) int &#123; for _, v :&#x3D; range more &#123; a +&#x3D; v &#125; return a&#125;sum :&#x3D; Sum(1, []int&#123;2, 3&#125;...) 可以给返回值命名，这样子返回值变量就可以在函数中使用，并且return语句可以不用带返回值（假如return语句带了变量，这是将变量赋值给返回值）。 1234567func Sum(a int, more ...int) (sum int) &#123; sum +&#x3D; a for _, v :&#x3D; range more &#123; sum +&#x3D; v &#125; return&#125; defer关键字 defer语句可以延迟执行一个函数，并且以栈的方式执行多个defer语句。 12345678910func main() &#123; for i :&#x3D; 0; i &lt; 3; i++ &#123; defer func()&#123;fmt.Println(i)&#125;() &#125;&#125;&#x2F;&#x2F; Output:&#x2F;&#x2F; 3&#x2F;&#x2F; 3&#x2F;&#x2F; 3 Go语言中指针不是固定不变的 Goroutine启动时只会分配很小的栈（4KB或8KB），在运行过程中才会不断扩充自己的栈空间，在增长过程中会拷贝之前的数据到新的内存空间。 并且，无法得知函数参数或局部变量到底是保存在栈中还是堆中。 1.4.2 方法方法是关联类型的函数。 1234567func (v *vType) Funcname() &#123; ...&#125;var v vTypev.Funcname() 方法表达式特性 可以使用方法表达式将方法还原为普通函数。 123&#x2F;&#x2F;func Funcname(v *vType)()&#123;...&#125;var Func &#x3D; (*vType).FuncnameFunc(v) 方法的继承 Go语言不支持传统面向对象中的继承特性，但可通过组合的方式支持方法的继承——通过在结构体内置匿名的成员来实现。 123456789101112import &quot;image&#x2F;color&quot;type Point struct &#123; X, Y float64 &#125;type ColoredPoint struct &#123; Point Color color.RGBA&#125;var cp ColoredPointcp.X &#x3D; 1cp.Point.X &#x3D; 2 看似cp.X中X是属于ColoredPoint类型的，实际上X依旧是属于匿名成员Point的。因为在编译期间，cp.X会被展开成cp.Point.X。 1.4.3 接口Go语言的接口类型是对其他类型行为的抽象和概括。而且，Go语言的借口类型是延迟绑定，可以实现类似虚函数的多态功能。 12345678910111213141516type UpperString stringfunc (s UpperString) String() string &#123; return strings.ToUpper(string(s))&#125;&#x2F;*接口在fmt包中有定义：type fmt.Stringer interface &#123; String() string&#125;*&#x2F;func main() &#123; fmt.Fprintln(os.Stdout, UpperString(&quot;hello, world&quot;))&#125; Go语言对接口类型的转换很灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。 123456var ( a io.ReadCloser &#x3D; (*os.File)(f) &#x2F;&#x2F;隐式转换 b io.Reader &#x3D; a &#x2F;&#x2F;隐式转换 c io.Closer &#x3D; a &#x2F;&#x2F;隐式转换 d io.Reader &#x3D; c.(io.Reader) &#x2F;&#x2F;显式转换)","categories":[{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《Go语言高级编程》","slug":"《Go语言高级编程》","permalink":"https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"}]},{"title":"第一章 Go语言基础——数组、字符串和切片","slug":"Go-base-knowledge-01","date":"2021-04-20T09:14:25.000Z","updated":"2021-04-21T02:58:25.031Z","comments":true,"path":"2021/04/20/Go-base-knowledge-01/","link":"","permalink":"https://www.chaguake.com/2021/04/20/Go-base-knowledge-01/","excerpt":"","text":"1.3 数组、字符串和切片这三种数据类型，在底层，原始数据有着相同的内存结构；在上层，因为语法的限制而有着不同的行为表现。 数组是一种值类型，虽然数组的元素可以修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理。 字符串底层是对应的字节数组，但是字符串的只读属性禁止了程序中对底层字节数组元素的修改。而且字符串赋值只是复制了数据地址和对应的长度。 切片的结构和字符串的结构相似，但是解除了只读限制。底层结构多了cap字段，用于表示切片的容量。 Go语言的赋值和函数传参规则很简单，除闭包函数以引用的方式对外部变量访问之外，其他赋值和函数传参都是以传值的方式处理。 1.3.1 数组数组是一个由固定长度的特定类型元素组成的序列，一个数组由零个或多个元素组成。 数组的长度是数组类型的组成部分，不同长度或不同类型的数据组成的数组都是不同的类型。 数组定义方式： 1234var a [3]int &#x2F;&#x2F;[0, 0, 0]var b &#x3D; [...]int&#123;1, 2, 3&#125; &#x2F;&#x2F;[1, 2, 3]var c &#x3D; [...]int&#123;2:3, 1:2&#125; &#x2F;&#x2F;[0, 2, 3]var d &#x3D; [...]int&#123;1, 2, 4:5, 6&#125; &#x2F;&#x2F;[1, 2, 0, 0, 5, 6] 数组是值语义，一个数组变量即整个数组，不能隐式地指向第一个元素的地址。 可以传递一个指向数组的指针，数组指针在使用上与数组变量差别不大： 123456789101112131415161718var a &#x3D; [...]int&#123;1, 2, 3&#125;var b &#x3D; &amp;afmt.Println(a[0])fmt.Println(b[0])for i :&#x3D; range a &#123; fmt.Println(i, a[i])&#125;for i, v :&#x3D; range b &#123; fmt.Println(i, v)&#125;&#x2F;&#x2F;效率性能比for range差for i :&#x3D; 0; i &lt; len(a); i++ &#123; fmt.Println(i, a[i])&#125; 使用for range方式迭代，还可以忽略迭代时的下标： 1234var times [5][0]intfor range times &#123; fmt.Println(&quot;hello&quot;)&#125; times是一个[5][0]int的二维数组，即[[], [], [], [], []]，整个数组的内存大小为0。 数组的类型可以是任意的，接口、结构体、函数都行。 长度为0的数组不占空间，可以用于占位或者类型声明。 123c1 :&#x3D; make(chan [0]int)&#x2F;&#x2F;等同于&#x2F;&#x2F;c1 :&#x3D; make(chan sttruct&#123;&#125;) 使用fmt.Printf打印数组的类型和详细信息： 123var b &#x3D; [...]int&#123;1, 2, 3&#125;fmt.Printf(&quot;b: %T\\n&quot;, b) &#x2F;&#x2F;b: [3]intfmt.Printf(&quot;b: %#v\\n&quot;, b) &#x2F;&#x2F;b: [3]int&#123;1, 2, 3&#125; 1.3.2 字符串字符串是不可改变的字符序列。 Go语言字符串的底层结构在reflect.StringHeader中定义： 1234type StringHeader struct &#123; Data uintptr Len int&#125; 对于字符串，与对应的byte数组的底层数据内存结构是一致的： 12345s :&#x3D; &quot;hello, world&quot;var data &#x3D; [...]byte &#123; &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;&#125; 字符串支持切片操作，不同位置的切片底层访问的是同一块内存数据。 1234567s :&#x3D; &quot;hello, world&quot;hello :&#x3D; s[:5]world :&#x3D; s[7:]s1 :&#x3D; &quot;hello, world&quot;[:5] &#x2F;&#x2F;&quot;hello, world&quot;[:5]与s[:5]指向的是用一个字符串常量s2 :&#x3D; &quot;hello, world&quot;[7:] 除了使用len函数获取字符串长度之外，也可以使用reflect.StringHeader结构访问字符串的长度。 1fmt.Println(&quot;len(s):&quot;, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len) 1.3.3 切片切片可以说是一种简化版的动态数组。底层数据结构reflect.SliceHeader如下： 12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; Cap表示切片指向的内存空间的最大容量，会按照规则实现自动扩充。 切片的定义方式： 1234567891011var ( a []int &#x2F;&#x2F;nil切片，和nil相等 b &#x3D; []int&#123;&#125; &#x2F;&#x2F;空切片 c &#x3D; []int&#123;1, 2, 3&#125; &#x2F;&#x2F;有3个元素的切片，len和cap都为3 d &#x3D; c[:2] &#x2F;&#x2F;有2个元素的切片，len为2，cap为3 e &#x3D; c[0:2:cap(c)] &#x2F;&#x2F;有2个元素的切片，len为2，cap为3 f &#x3D; c[:0] &#x2F;&#x2F;有0个元素的切片，len为0，cap为3 g &#x3D; make([]int, 3) &#x2F;&#x2F;有三个元素的切片，len和cap都为3 h &#x3D; make([]int, 2, 3) &#x2F;&#x2F;有2个元素的切片，len为2，cap为3 i &#x3D; make([]int, 0, 3) &#x2F;&#x2F;有0个元素的切片，len为0，cap为3) 添加切片元素 使用内置的append函数。值得注意的是，append函数有可能导致重新分配内存。 123456789101112var a []int&#x2F;&#x2F;切片尾部添加N个元素a &#x3D; append(a, 1)a &#x3D; append(a, 2, 3)a &#x3D; append(a, []int&#123;5, 6&#125;...)&#x2F;&#x2F;切片头部添加N个元素a &#x3D; append([]int&#123;0&#125;, a...)&#x2F;&#x2F;切片中间添加N个元素a &#x3D; append(a[:4], append([]int&#123;4&#125;, a[4:]...)...) 在切片中间添加元素时，append会创建临时切片。可使用copy函数和append函数组合，避免创建临时切片： 123a &#x3D; append(a, 0) &#x2F;&#x2F;扩充空间，需要插入N个就扩充Ncopy(a[5:], a[4:]) &#x2F;&#x2F;a[4:]后移一个位置a[4] &#x3D; 4 删除切片元素 删除头部和尾部的元素，可直接重新赋值范围即可： 123456789var a &#x3D; []int&#123;1, 2, 3&#125;&#x2F;&#x2F;删除尾部a &#x3D; a[:len(a)-1]a &#x3D; a[:len(a)-N]&#x2F;&#x2F;删除头部a &#x3D; a[1:]a &#x3D; a[N:] 删除头部元素或中间元素也可以用append函数或copy函数。 123456789a :&#x3D; []int&#123;1, 2, 3&#125;&#x2F;&#x2F;头部元素a &#x3D; append(a[:0], a[1:]...)a &#x3D; a[:copy(a, a[1:])]&#x2F;&#x2F;中间元素a &#x3D; append(a[:i], a[i+1:]...)a &#x3D; a[:i + copy(a[i], a[i+1:])] 切片高效操作的要点是降低内存分配的次数，尽量保证append函数操作不会超出cap的容量。 切片使用中，假如只使用了切片的一部分数据，应当拷贝到一个新的变量，避免切片底层数据的长期引用。 切片类型强制转换 通过切片底层结构reflect.SliceHeader来做指针的强制赋值。 12345678a :&#x3D; []float64&#123;&#125;c :&#x3D; []int&#123;&#125;aHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))cHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;c))*cHdr &#x3D; *aHdr","categories":[{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《Go语言高级编程》","slug":"《Go语言高级编程》","permalink":"https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"}]},{"title":"Mysql常用SQL命令集合","slug":"mysql-common-command","date":"2021-04-15T03:27:46.000Z","updated":"2021-04-15T06:22:49.391Z","comments":true,"path":"2021/04/15/mysql-common-command/","link":"","permalink":"https://www.chaguake.com/2021/04/15/mysql-common-command/","excerpt":"","text":"show engines命令用于查看当前Mysql使用的数据库存储引擎。 show variables命令用于查看当前Mysql的配置情况。 show status like ‘Table%’命令用于查看当前表使用状态，有两个关键的字段：Table_locks_immediate为表立即释放锁的次数，Table_locks_waited为表等待释放锁的次数。 show status like ‘innodb_row_lock%’命令用于查看行锁争夺情况。 lock table/unlock table命令MyISAM数据库引擎加锁（解锁）操作。 InnoDB Monitors可创建InnoDB Monitors来观察发生锁冲突的表、数据行等信息。 123CREATE TABLE innodb_monitor(a INT) ENGINE&#x3D;INNODB;Show innodb status \\G;DROP TABLE innodb_monitor; SELECT … LOCK IN SHARE MODE命令用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。 但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁。 SELECT … FOR UPDATE命令对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。 其他session可以查询，但是不能加共享锁。 InnoDB的行锁与表锁当使用索引来检索数据时，就会使用到行级锁，否则，将会使用表级锁。 比如，SELECT …WHERE … FOR UPDATE语句，如果where后面使用的是索引，那么这条语句就是行锁，否则是表锁。 而且，假如另一个session的SELECT …WHERE … FOR UPDATE语句通过另一个索引找到对应行，那还是会等待锁。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chaguake.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.chaguake.com/tags/Mysql/"}]},{"title":"Sunday字符串匹配算法","slug":"Sunday-alg","date":"2021-04-15T00:45:40.000Z","updated":"2021-04-15T01:14:42.265Z","comments":true,"path":"2021/04/15/Sunday-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/15/Sunday-alg/","excerpt":"","text":"参考文献： 字符串匹配——Sunday算法 Sunday算法比BM算法更快，并且方便不少。与KMP算法一样，迭代方向和字符比较方向都是从左到右。但匹配失效时取未参与匹配的第一个字符来做位数移动的判断依据。 如果该字符没有在搜索字符串中出现则直接跳过，即移动位数 = 搜索字符串长度 + 1； 否则，其移动位数 = 搜索字符串长度 - 该字符最右出现的位置（以0开始） = 搜索字符串中该字符最右出现的位置到尾部的距离 + 1。（其实就是将搜索字符串最右出现的位置与该字符位置对齐） 下面举例说明： 1.匹配失效时，判断字符i是否在模式串中出现，没有则移动模式串到字符i后面。 2.匹配失效时，判断字符r是否在模式串中出现，有则将模式串中最右出现字符r的位置与字符r的位置对齐。 3.完成匹配。 可以看出，Sunday算法十分快速地实现了匹配。 代码： 12345678910111213141516171819202122232425262728293031323334353637int Sunday(const string&amp; T, const string&amp; P) &#123; int n &#x3D; T.length(); int m &#x3D; P.length(); int shift[MAXNUM]; &#x2F;&#x2F; 默认值，移动m+1位 for (size_t i &#x3D; 0; i &lt; MAXNUM; i++)&#123; shift[i] &#x3D; m + 1; &#125; &#x2F;&#x2F; 模式串P中每个字母出现的最后的下标 &#x2F;&#x2F; 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数 for (int i &#x3D; 0; i &lt; m; i++) &#123; shift[P[i]] &#x3D; m - i; &#125; &#x2F;&#x2F; 模式串开始位置在主串的哪里 int s &#x3D; 0; &#x2F;&#x2F; 模式串已经匹配到的位置 int j; while (s &lt;&#x3D; n - m) &#123; j &#x3D; 0; while (T[s + j] &#x3D;&#x3D; P[j]) &#123; j++; &#x2F;&#x2F; 匹配成功 if (j &gt;&#x3D; m) &#123; return s; &#125; &#125; &#x2F;&#x2F; 找到主串中当前跟模式串匹配的最末字符的下一个字符 &#x2F;&#x2F; 在模式串中出现最后的位置 &#x2F;&#x2F; 所需要从(模式串末尾+1)移动到该位置的步数 s +&#x3D; shift[T[s + m]]; &#125; return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"}]},{"title":"BM字符串匹配算法","slug":"Boyer-Moore-alg","date":"2021-04-14T05:44:16.000Z","updated":"2021-04-14T09:19:27.946Z","comments":true,"path":"2021/04/14/Boyer-Moore-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/14/Boyer-Moore-alg/","excerpt":"","text":"参考文献有: BM字符串匹配算法论文 Boyer-Moore algorithm BM（Boyer-Moore）算法比KMP算法高效不少。KMP算法只有一个匹配规则，而BM算法有两个匹配规则，更加优化了迭代索引，减少不必要的比较次数。 BM算法的主要思想是：源字符串迭代方向依旧是从左到右，源字符串与搜索字符串的比较方向是从左到右。遇到不匹配情况时，根据两个匹配规则，定位下一次源字符串与搜索字符串比较的位置。 匹配规则BM算法定义了两个匹配规则，在每一次调整搜索字符串位置时，移动位数由两个匹配规则判断返回值中的最大值决定。 坏字符规则（bad-character shift）。当源字符串中的某个字符与搜索字符串中的某个字符不匹配时，则源字符串中的那个字符称之为坏字符。 这时，搜索字符串向右移动的位数 = 已完成匹配字符集合（从右到左）的最后一个字符索引（从0开始） - 坏字符在搜索字符串中最右边出现的位置索引（从0开始）。 假如坏字符在搜索字符串中未出现，则移动位数值为-1。 坏字符规则下的两种判断情况： 当搜索字符串不包含坏字符时，直接将搜索字符串移动到坏字符索引+1的位置（符合上面的计算公式）。 当搜索字符串包含坏字符时，将搜索字符串中最右出现的位置与坏字符位置对齐。这就意味着可能出现搜索字符串位置回退的情况，不过没关系，最后计算的移动位数由两个匹配规则决定的。 好后缀规则（good-suffix shift）。当字符无法继续匹配时，称已完成匹配字符集合为好后缀， 搜索字符串向右移动的位数 = 搜索字符串最右的好后缀索引 - 搜索字符串倒数第二次出现的好后缀索引。 假如好后缀在搜索字符串中只出现一次，则移动位数值为-1。 好后缀规则下的三种判断情况： 搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配且没有其他前缀子字符串与好后缀的后缀子字符串适配时，直接将搜索字符串移动到好后缀后面的字符位置。 搜索字符串中除了已经匹配上好后缀的那一个子字符串，还存在其他子字符串与好后缀适配时，则将搜索字符串倒数第二个适配的子字符串与好后缀对齐。 搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配，但存在其他前缀子字符串与好后缀的后缀子字符串适配时，则将它们对齐。 实例下面以实例来进行详解，如何用代码实现BM算法。 现在有一个源字符串cbcccacacabccabc，和一个搜索字符串cabcca，想要得到源字符串是否包含搜索字符串，有则输出位置索引。 根据坏字符规则，需要创建一个字符位置映射表，用于记录坏字符在搜索字符串中最右边的位置。 12345678&#x2F;&#x2F;char_table大小要大于等于会出现的所有字符种类数&#x2F;&#x2F;int char_table[MAXNUM + 1];&#x2F;&#x2F;memset(char_table, -1, sizeof(char) *(MAXNUM + 1));void InitCharTable(const char *search, unsigned int len, int *char_table) &#123; for (int i &#x3D; 0; i &lt; len; i++) &#123; char_table[search[i]] &#x3D; i; &#125;&#125; 根据好后缀规则，需要创建前缀子字符串索引表和后缀子字符串索引表。 123456789101112131415161718void InitGoodSuffixTable(const char *search, int len, int *suffix, bool *prefix) &#123; for (int i &#x3D; 0; i &lt; len - 1; i++) &#123; &#x2F;&#x2F;范围从第一个字符到倒数第二个字符 int j &#x3D; i; int k &#x3D; 0; while (j &gt;&#x3D; 0 &amp;&amp; search[j] &#x3D;&#x3D; search[len - 1 - k]) &#123;&#x2F;&#x2F;通过j、k同时往前回朔找相同的字符 suffix[++k] &#x3D; --j + 1;&#x2F;&#x2F;在后缀子字符串的后一个字符标记偏移量，兼容a[0]的情况 &#125; if (j &#x3D;&#x3D; -1) &#123; prefix[k] &#x3D; true;&#x2F;&#x2F;前缀子字符串最多只有一个，在结束的字符上标记结束符号（设为true） &#125; &#125;&#125;&#x2F;*输出结果：suffix：[-1, 1, 0, -1, -1, -1]。prefix：[false, false, true, false, false, false]。*&#x2F; 移动位数的函数需要跟前缀子字符串索引表和后缀子字符串索引表的生成方式绑定使用。 123456789101112int MoveIndexByGS(int bcindex, int len, int *suffix, bool *prefix) &#123; int gslen &#x3D; len - 1 - bcindex; if (suffix[gslen] !&#x3D; -1) &#123; return bcindex - suffix[gslen] + 1; &#125; for (int r &#x3D; bcindex + 2; r &lt;&#x3D; len - 1; r++) &#123; if (prefix[len - r]) return r; &#125; return len;&#125; BM算法的实现逻辑函数： 123456789101112131415161718192021222324252627282930313233343536373839404142int BM(const char *str, int len,const char *search, int slen) &#123; &#x2F;&#x2F;bad char rule tables int char_table[MAXNUM + 1]; memset(char_table, -1, sizeof(char_table)); InitCharTable(search, slen, char_table); &#x2F;&#x2F;good suffix rule tables int suffix[MAXNUM + 1]; bool prefix[MAXNUM + 1]; memset(suffix, -1, sizeof(suffix)); memset(prefix, false, sizeof(prefix)); InitGoodSuffixTable(search, slen, suffix, prefix); int i &#x3D; 0; while (i &lt;&#x3D; len - slen) &#123; int j; for (j &#x3D; slen - 1; j &gt;&#x3D; 0; j--) &#123; &#x2F;&#x2F;fine bad char if (str[i + j] !&#x3D; search[j]) break; &#125; if (j &lt; 0) &#123; return i; &#125; &#x2F;&#x2F; find bad char position int x &#x3D; j - char_table[(int)str[i + j]]; &#x2F;&#x2F; find good suffix position int y &#x3D; 0; if (j &lt; slen - 1) &#123; y &#x3D; MoveIndexByGS(j, slen, suffix, prefix); &#125; &#x2F;&#x2F;get the max offset i &#x3D; i + max(x, y); &#125; return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"}]},{"title":"KMP字符串匹配算法","slug":"knuth-morris-pratt-alg","date":"2021-04-12T06:07:04.000Z","updated":"2021-04-12T07:23:08.137Z","comments":true,"path":"2021/04/12/knuth-morris-pratt-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/12/knuth-morris-pratt-alg/","excerpt":"","text":"在日常工作中，我们经常需要在文本中搜寻某些特定的字符串，那作为使用者的你，有没有想过其算法的实现呢？ 举个例子，假如有一个源字符串“ablshvaabcadababcskilils”，如何判断其是否包含搜索字符串“abcadaba”？ 一般想到的做法是暴力遍历匹配方法：遍历源字符串，然后取出与搜索字符串相同长度的子字符串做比较，不匹配就将迭代索引+1，再取出与搜索字符串相同长度的子字符串做比较，直到迭代结束。时间复杂度为$O(m*n)$，取决于源字符串和搜索字符串的长度。 不难发现，在子字符串与搜索字符串做比较时，很大程度上，有部分操作是与上一次比较时重复的，那能否设计一种模式，减少这部分的重复工作呢？ KMP算法（Knuth-Morris-Pratt算法）KMP算法是通过添加部分匹配表（Partial Match Table）来减少重复搜索工作的算法，它其实是对暴力遍历匹配方法的优化算法，在搜索字符串没有部分匹配字符串的时候，会退化成暴力遍历匹配方法。 如上图，在匹配失败时，无须回退到上一迭代器+1的位置，而是从下一个部分匹配字符串的位置开始迭代。 部分匹配字符串和部分匹配表 首先，先理解“前缀子字符串”和“后缀子字符串”的概念。 前缀子字符串：把搜索字符串的最后一个字符去掉，所有包含搜索字符串第一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的前缀字符串是a、ab、abc、abca、abcad、abcada、abcadab。 后缀子字符串：把搜索字符串的第一个字符去掉，所有包含搜索字符串最后一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的后缀字符串是bcadaba、cadaba、adaba、daba、aba、ba、a。 把同时出现在所有前缀字符串和后缀字符串中的，包含搜索字符串第一个字符且连续的子字符串称为部分匹配字符串，所有部分匹配字符串的集合称为部分匹配表。如上面的搜索字符串“abcadaba”，它的部分匹配表的元素有：a、ab。 代码实现部分匹配表 我们需要记录部分匹配字符串第二次出现的位置。 创建一个与搜索字符串相同长度的整型数组，默认初始化值为0，用于存储在搜索字符串对应位置上，部分匹配字符串的长度。如上面的搜索字符串“abcadaba”，它的部分匹配表最终为：[0, 0, 0, 1, 0, 1, 2, 0]。 123456789101112131415void GetPartialMatch(const std::string &amp;strTarget, int *arr)&#123; int max_pre_size &#x3D; strTarget.length() - 1; for (size_t i &#x3D; 0; i &lt; max_pre_size; i++)&#123; std::string strTmp1 &#x3D; strTarget.substr(0, i + 1); for (size_t j &#x3D; 1; j &lt; max_pre_size; j++)&#123; std::string strTmp2 &#x3D; strTarget.substr(j, i + 1); if (strTmp1 &#x3D;&#x3D; strTmp2) &#123; arr[j + i] &#x3D; i + 1; &#125; &#125; &#125;&#125; KMP算法实现 1234567891011121314151617181920212223void KMP(const std::string &amp;strSrc, const std::string &amp;strTarget, const int *arr)&#123; int match_index &#x3D; 0; for (size_t i &#x3D; 0; i &lt; strSrc.length();)&#123; if (strSrc[i] &#x3D;&#x3D; strTarget[match_index]) &#123; if (match_index + 1 &#x3D;&#x3D; strTarget.length()) &#123; printf(&quot;match success,sub str index[%d].\\n&quot;, i - match_index); return; &#125; i++; match_index++; &#125; else &#123; if (match_index &gt; 0) &#123; match_index &#x3D; arr[match_index]; &#125; else &#123; i++; &#125; &#125; &#125; printf(&quot;match fail.\\n&quot;);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"}]},{"title":"C/C++如何获取不定数量的输入参数？","slug":"C-knowledge-cin","date":"2021-04-09T09:15:26.000Z","updated":"2021-04-09T09:22:45.559Z","comments":true,"path":"2021/04/09/C-knowledge-cin/","link":"","permalink":"https://www.chaguake.com/2021/04/09/C-knowledge-cin/","excerpt":"","text":"刷题时偶尔会出现输入不定数量的参数，主要是使用std::cin来实现。 使用Ctrl Z（Windows）或Ctrl D（UNIX）结束输入： 12345std::vector&lt;int&gt; vec;int value;while(std::cin&gt;&gt;value)&#123; vec.push_back(value);&#125; 使用回车结束输入： 123456789std::vector&lt;int&gt; vec;int value;while(std::cin&gt;&gt;value)&#123; vec.push_back(value); if(std::cin.get() &#x3D;&#x3D; &#39;\\n&#39;)&#123; break; &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"}],"tags":[{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"}]},{"title":"TCP对接异常——Server端宕机","slug":"tcp-docking-problem-01","date":"2021-04-08T00:42:22.000Z","updated":"2021-04-09T08:51:45.652Z","comments":true,"path":"2021/04/08/tcp-docking-problem-01/","link":"","permalink":"https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/","excerpt":"","text":"背景介绍问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。 Server端使用boost的asio库，性能应该有保障的。 首先，查看日志，排查对应代码片段，未发现有出现”死锁“的逻辑，只能从wireshark抓包分析了。 现场同事把抓包发回一看，好家伙，一堆的”TCP ZeroWindow”和”RST“！ 问题排查1、统计一下http请求情况， 才三百多次http请求，远远没达到正常水平，排除Server端处理瓶颈问题。 2、输入筛选条件tcp.flags.syn，看看tcp三次握手情况。 Client新连接都直接被Server端拒绝了，Server端的连接数已经达到了极限。 而Server端在处理完http请求之后都会断开当前连接，并非长连接模式。并且，根据Server端的http处理耗时来看，还算正常。 问题估计在已建立但是未正常关闭的连接上，粗略看下，基本都会出现”TCP ZeroWindow“标记。 3、随机追踪一条出现”TCP ZeroWindow“的tcp连接， 统计了下，出现这情况的连接大概有两百条，那就有可能出现同时并发的连接数大于CPU数量*2+1的情况。 而且，100个tcp包就出现滑动窗口占满的情况是不可能的，问题肯定出现在这里了。 经过排查，终于发现问题所在： 如上图，Server端最后回复给Client端包中，Win的值为5632，表示Server端还能接收5632个包。 并且Ack值为126929，希望Client下一个包的Seq序号值从126929开始。果不其然，Client端紧接着的包中Seq序号值为126929。 看Server端回复“TCP ZeroWindow”包的前一个由Client端发出的包LAST，它的Seq值为131273。 不难看出，131273 - 126929 = 4344 &lt; 5632，这时还可以正常接收。 但是展开那个包LAST中的Next Seq值是132609，132609 - 126929 = 5680 &gt; 5632，已经超出Win大小，所以，Server端接收到包LAST之后就返回“TCP ZeroWindow”包。 解决办法1、Client端更改Seq的生成规则，使得Seq自增步长减少。 抓包中可以看出，Client端Seq的自增步长是1448。 2、Server端将滑动窗口变大。 由于Client端会发送PSH包通知Srever端清空缓冲，那么Server端可以将滑动窗口变大，避免出现“TCP ZeroWindow”情况。 3、优化Srever端“接收请求-&gt;回复请求”的耗时，避免同时出现异常连接并发数大于CPU数量*2+1的情况。 这种方法依旧是没办法解决问题所在的，只是尽量避免宕机情况出现。 4、Server端添加tcp连接的timeout处理。 Server端主动关闭超过timeout时间没有接收到http请求的连接。","categories":[{"name":"问题排查","slug":"问题排查","permalink":"https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"问题排查之TCP","slug":"问题排查之TCP","permalink":"https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"}]},{"title":"TCP的三次握手","slug":"tcp-three-way-handshake","date":"2021-04-07T02:13:50.000Z","updated":"2021-04-07T07:03:49.700Z","comments":true,"path":"2021/04/07/tcp-three-way-handshake/","link":"","permalink":"https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/","excerpt":"","text":"最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。 参考文献有： TCP三次握手、四次挥手出现意外情况时，为保证稳定，是如何处理的？ 面试官，不要再问我三次握手和四次挥手 三次握手正常流程三次是TCP建立连接的最小次数，因为在三次握手中，双方都经历了”请求-&gt;应答“的过程。 三次握手流程步骤： 在初始时，双端处于CLOSE状态，服务端(Server)为了提供服务，会主动监听某个端口，进入LISTEN状态。 客户端(Client)主动发送连接的SYN包，之后进入SYN-SENT状态，服务端在收到客户端发来的SYN包后，回复SYN,ACK包，之后进入SYN-RCVD状态。 客户端收到服务端发来的SYN,ACK包后，可以确认对方存在，此时回复ACK包，并进入ESTABLISHED状态。 服务端收到最后一个ACK包后，也进入ESTABLISHED状态。 三次握手重点是客户端和服务端的状态变化过程，比如：客户端在发送第三个ACK包的时候，状态就会变更成ESTABLISHED，而服务端需要在接收到客户端发出的第三个ACK包的时候，才将状态转换成ESTABLISHED。 三次握手异常情况计算机网络的异常处理有时比正常处理得流程更为重要，毕竟，需要花费更大的消耗去判断是网络故障还是连接异常。 1. SYN包丢失 对于服务端，客户端还是”不存在的“。 对于客户端，无法清楚服务端是否接收到SYN包，所以客户端会进行重传SYN包的操作，一般重传三次，三次加起来大约是76s（采用指数退避算法）。 在代码层次上，客户端会阻塞在connect函数上，失败会返回异常信息。 可通过更改系统配置（Linux点击这里、Windows点击这里）来实现配置重连次数和重连耗时。 也可以通过”ioctl(1)+select(timeout)“方式来间接实现连接超时控制。TCP/IP Connect时间自主设定 2. SYN+ACK包丢失 对于客户端，跟SYN包丢失的处理流程是一样的。 对于服务端，会触发重传操作，毕竟无法确定客户端是否收到SYN+ACK包，此时服务端的状态是SYN_RCVD。 当超过重传次数之后，服务端系统会发送RST包。 3. ACK包丢失 对于服务端，跟SYN+ACK包丢失的处理流程是一样的，处于SYN-RCVD状态。 对于客户端，connect函数已经正常返回，客户端已经进入ESTABLISHED状态，可以发送/接收数据了。 现在，服务端和客户端的状态不对等，那么客户端发给服务端的数据会怎么处理呢？ 结合文章来看，假如客户端发送的第一个数据包的Seq确认序号跟ACK包的Seq确认序号一样，那么，服务端将进入ESTABLISHED状态，正常连接。假如不一样，服务端会发送RST包，结束该连接。而在代码实现中，connect函数是在客户端回复ACK包之后就返回了，这时三次握手还没完成。 所以，可以在conenct函数返回之后，立即发送一个跟ACK包相同Seq确认序号的数据包（默认第一个数据包的Seq是跟ACK一样），哪怕服务端没有接收到ACK包，也可以正常进入ESTABLISHED状态。并且也可以验证连接是否成功，假如服务端返回RST包，则连接失败。 应用层上，使用select、poll或者epoll机制判断socket是否可写来确认连接是否已经建立。非阻塞socket 的连接","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://www.chaguake.com/tags/TCP/"}]},{"title":"Reservoir Sampling 抽样算法","slug":"reservoir-sampling-alg","date":"2021-04-04T16:20:31.000Z","updated":"2021-04-06T08:23:01.651Z","comments":true,"path":"2021/04/05/reservoir-sampling-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/","excerpt":"","text":"“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。 但是，当m不是确定值呢？ 可以使用Reservoir Sampling 抽样算法。 由于m是不确定的，那么使用[0,m]范围内随机产生数的方式就没办法使用。所以，需要设计一种方法，使得每个数被抽取的概率都是$\\frac{n}{m}$。 一、”每次都是 $\\frac{1}{i}$”问题对于n(n&gt;=1)，如果每次（基数k从0到n递增）以$\\frac{1}{i}$的概率决定是否替换选中元素直到n，那么最后每个元素被选中的概率相等，即为$\\frac{1}{n}。$ 证明： 假设最后被选中的元素a(a&lt;=n)，它是在第k(k&lt;=n)次被选中。也就是说在第k次之后都不会有元素被选中，这样子才能确保最后选中的元素是a。 那么它被选中的概率等于第k次被选中的概率*第k次以后都没有元素选中。 \\frac{1}{k} × \\frac{k}{k+1} × \\frac{k+1}{k+2} × ··· × \\frac{n-1}{n} = \\frac{1}{n}可以得到结论：在未知样本空间n中，随机抽取一个数a，它的概率是$\\frac{1}{n}$。 代码实现： 1234567void Sampling(std::vector&lt;int&gt; &amp;vec, int &amp;num)&#123; for (size_t i &#x3D; 1; i &lt; vec.size(); i++)&#123; int random &#x3D; rand() % i; num &#x3D; vec[random]; &#125;&#125; 二、如何从未知样本空间m随机抽取n个数假如按照第一点中的方法，抽取n个数。的确也是能实现$\\frac{n}{m}$的概率，但是要遍历n次，时间复杂度就顶不住了。 换个角度，假设，先取出前n个元素组成一个集合N，把第n+1个元素放进集合N，从集合N中抽取n个元素重新组成集合N，直至最后一个元素。 也就是说，第n+1个元素随机替换集合N中的一个元素。下面证明最后得出的集合N中，每个元素的概率是$\\frac{n}{m}$。 证明： 假设集合N中的任意一个元素a，它是第k(n&lt;=k&lt;=m)次被放进集合N，它最后留在集合N的概率 = 在它后面的元素都没有被抽中的概率 + 在它后面的元素被抽中的概率 * 没有替换元素a的概率。 根据第一点中的方法，第k(k&gt;=n)次某元素被选中并替换到集合N的概率是$\\frac{1}{k} × n = \\frac{n}{k}$。 \\frac{n}{k} × (\\frac{k+1-n}{k+1} + \\frac{n}{k+1} × \\frac{n-1}{n}) × (\\frac{k+2-n}{k+2} + \\frac{n}{k+2} × \\frac{n-1}{n}) × ··· × \\frac{m-n}{m} + \\frac{n}{m} × \\frac{n-1}{n} = \\frac{n}{k} × \\frac{k}{k+1} × \\frac{k+1}{k+2} × ··· × \\frac{m-1}{m} = \\frac{n}{m}证明成立，这个实现就是蓄水池抽样算法（Reservoir Sampling）。 代码实现： 123456789void ReservoirSampling(std::vector&lt;int&gt; &amp;vec,int n)&#123; for (size_t i &#x3D; n; i &lt; vec.size(); i++) &#123; int random &#x3D; rand() % i; if(random &lt; n)&#123; std::swap(vec[random], vec[i]); &#125; &#125;&#125; 分布式实现： 12345678910&#x2F;&#x2F;up-low&gt;nvoid ReservoirSampling(std::vector&lt;int&gt; &amp;vec, int n, int low, int up)&#123; for (size_t i &#x3D; low + n; i &lt; up; i++) &#123; int random &#x3D; rand() % (up - low) + low; if (random &lt; low + n) &#123; std::swap(vec[random], vec[i]); &#125; &#125;&#125; 可以看出，Reservoir Sampling 抽样算法的空间复杂度$O(1)$，时间复杂度$O(n)$。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"抽样算法","slug":"抽样算法","permalink":"https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"}]},{"title":"Fisher Yates 洗牌算法","slug":"fisher-yates-shuffle-alg","date":"2021-04-02T06:29:14.000Z","updated":"2021-04-06T08:20:16.075Z","comments":true,"path":"2021/04/02/fisher-yates-shuffle-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/","excerpt":"","text":"洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。 不加权模式Fisher Yates洗牌算法凭借着$O(1)$空间、$O(n)$时间复杂度，实现了“在n个不同的数中随机取出m个数”一类的问题。 实现大致是将从未抽取集合中随机抽中的数x与未抽取集合中的最后一个数交换，未抽取集合个数-1。不断重复，直至未抽取集合个数为0。 实现细节： 已知原始数组长度为n，将原始数组分为未抽取数组（长度为n）和取出数组（长度为0）。 在未抽取数组中，随机（算法依赖这个’随机‘是否够随机）选中一个数p，将数p的位置与原始数组最后一位（首位也行）交换。 重复上一个步骤，直到未抽取数组的个数为0。 有点像选择排序，差异在于每次在’未排序‘区中找的不是最小（或最大）的，而是随机选一个。 实现代码如下： 12345678void shuffle(int *arr,int nLen)&#123; for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123; int num &#x3D; rand() % i; std::swap(arr[i], arr[num]); &#125;&#125; 算法脱离数学是不讲武德的，下面就证明：集合set有n个不同的数字，第i次抽取到的数字p的概率是否是都是$\\frac{1}{n}$ 。 第i次才抽中数字p，那么前i-1次都是没抽到数字p的。 第一次抽取，没抽到数字p的概率是$\\frac{n-1}{n}$。 第二次抽取，没抽到数字p的概率是$\\frac{n-1}{n} × \\frac{n-2}{n-1}$。 …… 第i-1次抽取，没抽到数字p的概率是$\\frac{n-1}{n} × \\frac{n-2}{n-1} × ··· × \\frac{n-i}{n-i+1}$。 第i次抽取，抽到数字p的概率是$\\frac{n-1}{n} × \\frac{n-2}{n-1} × ··· × \\frac{n-i}{n-i+1} × \\frac{1}{n-i} = \\frac{1}{n}$。 Fisher Yates洗牌算法有两个随机因子，一个是每一次从未抽取集合抽取的元素，另一个是每一次未抽取集合最后一个元素，但最关键是第一个随机因子。 假如为每个元素加上权重，使得每个元素本身被抽中的优先度不一样，又如何用Fisher Yates洗牌算法来实现呢？ 加权模式一个比较笨重的办法,将元素按照其权重展开: 12&#123;a:2,b:3,c:1&#125;&#123;a,a,b,b,b,c&#125; （但显然不是好办法。=_=） 因为有了权重作为附加条件，再按照上面”从未抽取集合中随机抽取一个元素“的方式是不满足条件的，必须将权重参与到运算中（随机抽取）。 那么，可以将所有权重值加起来，得到一个权重总数sum，然后在0到sum的范围内随机产生一个数num，再将num与未抽取集合中每一个元素作某种比较，最后输出随机数。 步骤如下： 统计出所有元素的权重和sum。 在0到sum之间随机产生一个随机数num，遍历未抽取集合。 用随机数num和当前迭代元素n比较。假如num小于n，结束迭代，返回元素n（与最后一位元素交换），sum-=n，重复第二步；假如num大于n，则num-=n，继续迭代。 遍历到未抽取集合的最后一个元素时，如果num大于n，则输出最后一个元素，sum-=n。 重复第二步。 代码如下： 12345678910111213141516171819202122void shuffle2(int *arr, int nLen)&#123; int sum &#x3D; 0; for (size_t i &#x3D; 0; i &lt; nLen; i++)&#123; sum +&#x3D; arr[i]; &#125; for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123; int num &#x3D; rand() % sum; size_t j &#x3D; 0; for (; j &lt; i; j++)&#123; if (num &gt; arr[j]) &#123; num -&#x3D; arr[j]; &#125; else &#123; break; &#125; &#125; sum -&#x3D; arr[j]; std::swap(arr[i], arr[j]); &#125;&#125; 空间复杂度还是$O(1)$，但时间复杂度是$O(n+n^2)$。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"洗牌算法","slug":"洗牌算法","permalink":"https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"}]},{"title":"面试知识点——C/C++基础知识","slug":"interview-knowledge-C-base","date":"2021-04-02T01:52:14.000Z","updated":"2021-04-06T09:02:17.326Z","comments":true,"path":"2021/04/02/interview-knowledge-C-base/","link":"","permalink":"https://www.chaguake.com/2021/04/02/interview-knowledge-C-base/","excerpt":"","text":"一、extern关键字的使用1、外部变量声明，使得全局变量可跨文件使用。 不同.cpp文件在编译时是独立的，需要添加extern关键字声明该变量是在外部（其他.cpp文件）定义。 2、函数声明。 可以使用extern void fun();来代替引用#include *.h的方式，去声明外部函数。 这里有个问题，网络上说单方面修改extern函数原型时编译器不会报错，但博主在VS2008和VS2017上是会报错的（编译成功，链接失败）。 3、链接规范（extern “C”）。 链接规范的用法： 1234567extern &quot;C&quot; void fun();extern &quot;C&quot;&#123; void fun1(); void fun2();&#125; C++由于支持函数重载，在C++编译器工作时，会生成一个用于链接的中间函数名。 而C不支持函数重载，所以在C编译器工作时，生成的中间函数名只是简单的在函数名前加上一个下划线_。 在C++使用C函数时，会将C函数生成一个C++规则的中间函数名。这样子，在进行链接时，C编译生成的目标文件和C++编译生成的目标文件中的中间函数名就会不一样，导致链接失败。 所以，C++调用C的函数时，需要添加extern “C”来声明，按照C的规则编译C的函数。 而C调用C++的函数，除了使用extern “C”之外，还需要做一层包装函数（添加extern “C”为了生成C风格的中间函数名，添加包装函数为了支持重载）。 值得注意的是，不应该把头文件放在extern “C”的范围里，因为有可能会导致符号嵌套。 二、placement new当需要在一块已分配的内存上创建对象时，需要使用placement new。 1A *ptr &#x3D; new(buff) A; 使用强制转换的办法也可以在已分配的内存上创建对象，但是不会调用对象的构造函数，而且，有可能会有内存溢出的问题。 1A *ptr &#x3D; (A*)buff; 三、stdcall、cdecl和__fastcall三种函数调用协议参见参数传递和命名约定和C++知识回顾之stdcall、cdcel和__fastcall三者的区别 1、协议常用场合 __stdcall：Windows API默认的函数调用协议。 __cdecl：C/C++默认的函数调用协议。 __fastcall：适用于对性能要求高的场合（只适用于X86架构，在ARM和X64体系架构的编译器会直接忽略该关键字）。 2、函数入栈方式 __stdcall：函数参数由右向左入栈。 __cdecl：函数参数由右向左入栈。 __fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。 3、栈内数据清除方式 __stdcall：函数调用结束后由被调用函数清除栈内数据。 __cdecl：函数调用结束后由函数调用者清除栈内数据。 __fastcall：函数调用结束后由被调用函数清除栈内数据。 注： 1)不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。 2)某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。 3)由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。 4、C编译器函数名称修饰规则 __stdcall：编译后，函数名被修饰为“_functionname@number”（number为参数字节数）。 __cdecl：编译后，函数名被修饰为“_functionname”。 __fastcall：编译后，函数名给修饰为“@functionname@nmuber”（number为参数字节数）。 C++编译器函数名称修饰规则 __stdcall：编译后，函数名被修饰为“?functionname@@YG**@Z”。 __cdscl：编译后，函数名被修饰为“?functionname@@YA**@Z”。 __fastcall：编译后，函数名被修饰为“?functionname@@YI**@Z”。","categories":[{"name":"面试","slug":"面试","permalink":"https://www.chaguake.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"}]},{"title":"OpenGL入门（三）——生成三角形小结笔记","slug":"OpenGL-introduction-03","date":"2021-03-31T10:50:43.000Z","updated":"2021-04-02T01:39:54.200Z","comments":true,"path":"2021/03/31/OpenGL-introduction-03/","link":"","permalink":"https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/","excerpt":"","text":"英文原文地址 中文翻译地址 总结小结主要介绍了各类着色器的使用，特别是可编程的顶点着色器和片段着色器。 一、图形渲染管线图形渲染管线（简称管线）主要作用是将一堆物体的3D坐标转换成2D坐标输出，最后呈现在屏幕上。 管线接受一组3D坐标，然后通过几个串行的阶段处理（在GPU上并行处理），最终输出屏幕画面。 如上图。每一个阶段称为着色器，其中。标有蓝色的着色器有顶点着色器、几何着色器和片段着色器。它们允许我们自定义编写着色器处理逻辑。 二、各类着色器介绍OpenGL着色器语言 有些着色器允许自己设计，可以用OpenGL着色器语言（GLSL）编写。 顶点着色器 顶点着色器将用户输入的3D坐标转换成GLSL中的3D坐标，并且可以对顶点3D坐标做一些处理。 1234567#version 330 corelayout (location &#x3D; 0) in vec3 aPos;void main()&#123; gl_Position &#x3D; vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125; 在GLSL中，3D坐标是一个有4个分量的向量，x、y、z、w，最后一个用于透视除法上。 图元着色器 图元着色器将顶点着色器的顶点输出作为输入，然后将所有的顶点装配成指定图元的形状。 1glDrawArrays(GL_TRIANGLES, 0, 3); 几何着色器 几何着色器可以将图元着色器输出的顶点构造出其它的图元形状。 光栅化 光栅化将图元映射成屏幕上的像素形状，即片段。 片段着色器 片段着色器计算每一个像素的颜色，它需要接收场景的数据（例如：光照、阴影等），综合计算出像素点的颜色。 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125; 片段着色器只有一个颜色输出变量。 测试和混合 当每个片段的颜色都确定之后，还需要检查每个片段之间的层级关系和透明度叠加之后的显示颜色。 三、编译着色器着色器代码需要在运行时动态编译，代码以字符串形式传递给OpenGL。 首先，得创建着色器对象： 12unsigned int vertexShader;vertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER); glCreateShader函数需要输入当前需要创建的着色器类型，GL_FRAGMENT_SHADER是片段着色器，GL_VERTEX_SHADER是顶点着色器。 下一步，需要将着色器源码附加到着色器对象上，并且编译它： 12glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader); glShaderSource函数的第一个参数是着色器对象，第二个参数是着色器源码数量，第三个参数是着色器源码字符串数组首地址，第四个参数是着色器源码字符串长度数组首地址。 可以对着色器源码编译的结果检测： 12345678int success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if(!success)&#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125; 四、着色器程序对象着色器编译出来之后，需要将他们链接到同一个着色器程序对象上。 同样的，需要创建着色器程序对象： 12unsigned int shaderProgram;shaderProgram &#x3D; glCreateProgram(); 下一步，把各个着色器附加到着色器程序对象上，然后进行链接： 123glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram); 同样，也可以捕捉链接失败信息： 12345glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ...&#125; 着色器对象链接到着色器程序对象之后，着色器对象就可以删除了： 12glDeleteShader(vertexShader);glDeleteShader(fragmentShader); 当需要使用着色器程序时，调用： 1glUseProgram(shaderProgram); 删除着色器程序，调用： 1glDeleteProgram(shaderProgram); 五、顶点缓冲对象（Vertex Buffer Object，VBO）顶点数据从内存发送到GPU是一件耗时费力的事情，所以尽可能一次性发送更多的数据到显卡上。 定点缓冲对象可包含顶点的多种属性： 1234567float vertices[] &#x3D; &#123; &#x2F;&#x2F; positions &#x2F;&#x2F; colors &#x2F;&#x2F; texture coords 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, &#x2F;&#x2F; top right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, &#x2F;&#x2F; bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, &#x2F;&#x2F; bottom left -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f &#x2F;&#x2F; top left &#125;; 创建VBO： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); 绑定数据，但在此之前需要声明接下来绑定的数据是哪种类型的，应该把它绑定到哪种缓冲对象上： 因为要做顶点缓冲类型的数据绑定，所以用GL_ARRAY_BUFFER。 12glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData函数第一个参数是目标缓冲类型，第二个参数是需绑定数据的大小，第三个参数是需绑定数据地址，第四个参数指定显卡如何管理当前绑定的数据。 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW ：数据会改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 根据值不同，需绑定数据会放在显卡不同的位置。 摧毁VBO对象： 1glDeleteBuffers(1, &amp;VBO); 六、索引缓冲对象（Element Buffer Object，EBO或Index Buffer Object，IBO）万物皆三角形。三角形可以说是3D图形最小的组成元素，毕竟三角形的三个顶点肯定在同一个平面上。 在绘制矩阵图形时，可以将矩阵分成两个三角形来绘制。但这样子，就会出现共同顶点，在VBO上则是重复存储，浪费开销。 12345678910float vertices[] &#x3D; &#123; &#x2F;&#x2F; 第一个三角形 0.5f, 0.5f, 0.0f, &#x2F;&#x2F; 右上角 0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 右下角 -0.5f, 0.5f, 0.0f, &#x2F;&#x2F; 左上角 &#x2F;&#x2F; 第二个三角形 0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 右下角 -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角 -0.5f, 0.5f, 0.0f &#x2F;&#x2F; 左上角&#125;; 索引缓冲对象可以使得VBO不用存储每个顶点重复的数据，然后通过固定索引来描绘出每个三角形。 1234567891011float vertices[] &#x3D; &#123; 0.5f, 0.5f, 0.0f, &#x2F;&#x2F; 右上角 0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 右下角 -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角 -0.5f, 0.5f, 0.0f &#x2F;&#x2F; 左上角&#125;;unsigned int indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! 0, 1, 3, &#x2F;&#x2F; 第一个三角形 1, 2, 3 &#x2F;&#x2F; 第二个三角形&#125;; 创建索引缓冲对象： 12unsigned int EBO;glGenBuffers(1, &amp;EBO); 绑定数据（跟VBO类似）到VAO： 12glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 一般的，在绘制时使用glDrawArrays函数： 12&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是顶点坐标指针的起始索引，第三个参数是绘制顶点数量glDrawArrays(GL_TRIANGLES, 0, 3); 使用索引绘制时需要用到glDrawElements函数： 12&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是绘制顶点数量，第三个参数是索引的类型，第四个是EBO数组地址的偏移量glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 摧毁EBO对象： 1glDeleteBuffers(1, &amp;EBO); 七、顶点数组对象（Vertex Array Object，VAO）顶点数组对象封装了顶点所有属性数据（例如：坐标，颜色，纹理等），记录了顶点缓冲对像（VBO）和索引缓冲对象（EBO）的指针地址。 在配置顶点属性之后，VAO记录了配置的状态，在需要的时候绑定不同的VAO实现： glEnableVertexAttribArray函数和glDisableVertexAttribArray函数分别启用/禁用某个顶点属性，默认是禁用。 glVertexAttribPointer函数用于设置顶点属性配置和关联的顶点缓冲对象。一般顶点属性会放在同一个VBO或EBO中，增加复用性。 创建VAO： 12unsigned int VAO;glGenVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时创建多个VAO 使用VAO，需要先进行绑定： 1glBindVertexArray(VAO); 设置VBO、EBO： 12345glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 接下来，就可以设置VAO的顶点属性。 12glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); glVertexAttribPointer函数参数定义： 第一个参数是配置的顶点属性。在顶点着色器源码中使用layout(location = 0)来设置位置值位0，所以这里要传入对应的值。 第二个参数是顶点属性的大小。 第三个参数是数据的类型。 第四个参数是是否将数据标准化。如果设置为GL_TRUE，那么数据就会被映射在0到1之间。 第五个参数是步长。表示顶点属性之间的间隔。 第六个参数是当前使用的数据在缓冲数组中的偏移量（Offset）。 解绑VAO： 1glBindVertexArray(NULL); 摧毁VAO： 1glDeleteVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时删除多个VAO 八、线框模式与填充模式 如果只想获取图元的形状，而不用填充颜色，可以使用线框模式： 1glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) 填充模式（默认模式）则用： 1glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（二）——Hello Window小节笔记","slug":"OpenGL-introduction-02","date":"2021-03-31T06:59:55.000Z","updated":"2021-03-31T10:53:13.460Z","comments":true,"path":"2021/03/31/OpenGL-introduction-02/","link":"","permalink":"https://www.chaguake.com/2021/03/31/OpenGL-introduction-02/","excerpt":"","text":"英文原文地址 中文翻译地址 整个小节看这一份完整的源码就可以了。这里。 总结初始化GLFW。 1glfwInit(); 调用glfwWindowHint函数配置GLFW。 123glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 调用glfwCreateWindow函数创建窗口对象， 1GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL); 把窗口的上下文设置为当前线程的上下文。 1glfwMakeContextCurrent(window); 传递OpenGL函数指针给GLAD。 12345if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1;&#125; 传递窗口大小给OpenGL，由于窗口大小会变化，所以通过注册函数来实现动态更新。 12345void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125;glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); 循环渲染，直到窗口退出。 1234567891011121314151617void processInput(GLFWwindow *window)&#123; if(glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;while(!glfwWindowShouldClose(window))&#123; processInput(window);&#x2F;&#x2F;捕捉用户输入。 &#x2F;&#x2F;渲染指令 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window);&#x2F;&#x2F;交换颜色缓冲。 glfwPollEvents();&#x2F;&#x2F;检测事件。&#125; 退出时释放资源。 1glfwTerminate();","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（一）——GLFW库与GLAD库","slug":"OpenGL-introduction-01","date":"2021-03-31T06:22:54.000Z","updated":"2021-03-31T10:53:27.400Z","comments":true,"path":"2021/03/31/OpenGL-introduction-01/","link":"","permalink":"https://www.chaguake.com/2021/03/31/OpenGL-introduction-01/","excerpt":"","text":"OpenGL入门系列是博主学习LearnOpenGL教程的笔录。 LearnOpenGL中文翻译版教程地址：https://learnopengl-cn.github.io/ LearnOpenGL英文原作者版地址：https://learnopengl.com/ GLFW GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。 官网：https://www.glfw.org/ GLFW提供了简单的API，方便开发者创建windows、contexts、surfaces、input和events等一系列操作。 官网一般提供了现成的二进制文件库和头文件，将它引用到项目中使用。 GLAD由于OpenGL的接口函数地址一般是未知的，需要在运行期间动态获取。如下： 1234567&#x2F;&#x2F; 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);&#x2F;&#x2F; 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers &#x3D; (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);&#x2F;&#x2F; 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer); GLAD提供了一个在线服务，通过一些自定义配置，生成一个文件库，把它引用到项目中使用。 值得注意的是，在引用GLFW的头文件之前要先引用GLAD的头文件，因为GLAD包含了OpenGL的头文件。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"lua 基础知识","slug":"lua-base-knowledge","date":"2021-03-24T11:35:05.000Z","updated":"2021-03-31T01:50:42.780Z","comments":true,"path":"2021/03/24/lua-base-knowledge/","link":"","permalink":"https://www.chaguake.com/2021/03/24/lua-base-knowledge/","excerpt":"","text":"注释单行注释 两个连续减号。 1--我是注释 多行注释 结构类似多行字符串。 1234--[[第一行注释第二行注释]]-- 数据类型lua的变量不需要声明数据类型，并且变量的数据类型是不确定的，前一秒可以赋值数值，下一秒可以赋值字符串。 数据类型 描述 nil 只有值nil属于该类型，表示一个无效值 boolean 包含两个值：true和false number 表示双精度类型的实浮点数 string 由单引号或者双引号表示的字符串 function 由C或Lua编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 作用域变量的作用域默认是全局的，哪怕是在函数里定义的。 想要删除一个变量，把它赋值为nil。 局部变量需要在变量前加上local关键字。 迭代器lua的迭代器函数有两个：pairs和ipairs。前者遇到nil不会结束迭代，而是将nil过滤；后者遇到nil会结束迭代，直接返回。 12345678910111213141516171819202122232425array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;, nil, &quot;!&quot;&#125;for key,value in ipairs(array)do print(key, value)end&#x2F;*HelloWorld*&#x2F;array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;, nil, &quot;!&quot;&#125;for key,value in pairs(array)do print(key, value)end&#x2F;*HelloWorld!*&#x2F; 迭代器函数每次调用会返回下一组元素，根据返回的元素组是否包含迭代状态的元素来区分是无状态的迭代器还是多状态的迭代器。 无状态的迭代器 它返回每次迭代的状态元素，并且接受上一次迭代元素，例如ipairs。 123456789101112131415161718function iter (a, i) i &#x3D; i + 1 local v &#x3D; a[i] if v then return i, v endend function ipairs (a) return iter, a, 0endt &#x3D; &#123;1,2,3,4,5&#125;for k,v in ipairs(t)do print(k ,v)end 多状态的迭代器 如果迭代器需要维护不止一个状态元素，那可以使用闭包来实现将状态信息存放。 1234567891011121314151617181920array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;&#125;function elementIterator (collection) local index &#x3D; 0 local count &#x3D; #collection -- 闭包函数 return function () index &#x3D; index + 1 if index &lt;&#x3D; count then -- 返回迭代器的当前元素 return collection[index] end endendfor element in elementIterator(array)do print(element)end 模块与包从Lua5.1开始，Lua加入了标准的模块管理机制。 自定义模块module.lua代码： 123456789101112131415161718192021-- 文件名为 module.lua-- 定义一个名为 module 的模块module &#x3D; &#123;&#125; -- 定义一个常量module.constant &#x3D; &quot;这是一个常量&quot; -- 定义一个函数function module.func1() io.write(&quot;这是一个公有函数！\\n&quot;)end local function func2() print(&quot;这是一个私有函数！&quot;)end function module.func3() func2()end return module 加载模块示例： 1234567-- test_module.lua 文件-- module 模块为上文提到到 module.luarequire(&quot;module&quot;) print(module.constant) module.func3() 模块别名： 12345678-- test_module2.lua 文件-- module 模块为上文提到到 module.lua-- 别名变量 mlocal m &#x3D; require(&quot;module&quot;) print(m.constant) m.func3() C包 Lua可以引用C的库. 1234local path &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lua&#x2F;lib&#x2F;libluasocket.so&quot;-- 或者 path &#x3D; &quot;C:\\\\windows\\\\luasocket.dll&quot;，这是 Window 平台下local f &#x3D; assert(loadlib(path, &quot;luaopen_socket&quot;))f() -- 真正打开库 元表元表提供了对table的扩展操作，通过元方法，可以对table做对应的关联行为。 12setmetatable(table,metatable)getmetatable(table) __index元方法 提供了当使用在table中不存在的键访问table时的控制操作。 1234567891011121314mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __index &#x3D; function(mytable, key) if key &#x3D;&#x3D; &quot;key2&quot; then return &quot;metatablevalue&quot; else return nil end end&#125;)print(mytable.key1,mytable.key2)&#x2F;*value1 metatablevalue*&#x2F; 上面代码也可以写成： 12mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __index &#x3D; &#123; key2 &#x3D; &quot;metatablevalue&quot; &#125; &#125;)print(mytable.key1,mytable.key2) __newindex元方法 当给table做一个不存在的键赋值时，就会触发__newindex元方法。 12345678910111213141516mymetatable &#x3D; &#123;&#125;mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __newindex &#x3D; mymetatable &#125;)print(mytable.key1)mytable.newkey &#x3D; &quot;新值2&quot;print(mytable.newkey,mymetatable.newkey)mytable.key1 &#x3D; &quot;新值1&quot;print(mytable.key1,mymetatable.key1)&#x2F;*value1nil 新值2新值1 nil*&#x2F; 操作符元方法 12345678910111213141516171819202122232425262728293031323334353637-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数function table_maxn(t) local mn &#x3D; 0 for k, v in pairs(t) do if mn &lt; k then mn &#x3D; k end end return mnend-- 两表相加操作mytable &#x3D; setmetatable(&#123; 1, 2, 3 &#125;, &#123; __add &#x3D; function(mytable, newtable) for i &#x3D; 1, table_maxn(newtable) do table.insert(mytable, table_maxn(mytable)+1,newtable[i]) end return mytable end&#125;)secondtable &#x3D; &#123;4,5,6&#125;mytable &#x3D; mytable + secondtable for k,v in ipairs(mytable) doprint(k,v)end&#x2F;*1 12 23 34 45 56 6*&#x2F; 操作符元方法 描述 __add 加 __sub 减 __mul 乘 __div 商 ‘/’ __mod 余数 ‘%’ __unm 负数 ‘-’ __concat 连接符号 ‘..’ __eq 判断相等 ‘==’ __lt 小于 ‘&lt;’ __le 小于等于 ‘&lt;=’ __call元方法 提供元组一个调用函数的方法。 12345678910111213141516171819202122232425262728293031-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数function table_maxn(t) local mn &#x3D; 0 for k, v in pairs(t) do if mn &lt; k then mn &#x3D; k end end return mnend-- 定义元方法__callmytable &#x3D; setmetatable(&#123;10&#125;, &#123; __call &#x3D; function(mytable, newtable) sum &#x3D; 0 for i &#x3D; 1, table_maxn(mytable) do sum &#x3D; sum + mytable[i] end for i &#x3D; 1, table_maxn(newtable) do sum &#x3D; sum + newtable[i] end return sum end&#125;)newtable &#x3D; &#123;10,20,30&#125;print(mytable(newtable))&#x2F;*70*&#x2F; __tostring元方法 提供table格式化输出的方法。 12345678910mytable &#x3D; setmetatable(&#123; 10, 20, 30 &#125;, &#123; __tostring &#x3D; function(mytable) sum &#x3D; 0 for k, v in pairs(mytable) do sum &#x3D; sum + v end return &quot;表所有元素的和为 &quot; .. sum end&#125;)print(mytable)","categories":[{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/categories/lua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/tags/lua/"}]},{"title":"c++ 时间与日期相关函数的使用","slug":"c-usage-of-time-and-date","date":"2021-03-23T03:21:14.000Z","updated":"2021-03-23T09:41:02.578Z","comments":true,"path":"2021/03/23/c-usage-of-time-and-date/","link":"","permalink":"https://www.chaguake.com/2021/03/23/c-usage-of-time-and-date/","excerpt":"","text":"基础类型介绍C/C++中，跟时间与日期相关的数据类型有clock_t、time_t和tm，它们的定义如下： 12345678910111213141516171819202122232425262728#include&lt;time.h&gt; &#x2F;&#x2F;for c#include&lt;ctime&gt; &#x2F;&#x2F;for c++typedef long clock_t;typedef long __time32_t;typedef __int64 __time64_t;#ifndef _CRT_NO_TIME_T #ifdef _USE_32BIT_TIME_T typedef __time32_t time_t; #else typedef __time64_t time_t; #endif#endifstruct tm&#123; int tm_sec; &#x2F;&#x2F; seconds after the minute - [0, 60] including leap second int tm_min; &#x2F;&#x2F; minutes after the hour - [0, 59] int tm_hour; &#x2F;&#x2F; hours since midnight - [0, 23] int tm_mday; &#x2F;&#x2F; day of the month - [1, 31] int tm_mon; &#x2F;&#x2F; months since January - [0, 11] int tm_year; &#x2F;&#x2F; years since 1900 int tm_wday; &#x2F;&#x2F; days since Sunday - [0, 6] int tm_yday; &#x2F;&#x2F; days since January 1 - [0, 365] int tm_isdst; &#x2F;&#x2F; daylight savings time flag&#125;; 常用函数介绍一、time函数函数定义 获取从1970-01-01 00:00:00到现在经过的秒数。 1234567time_t time(time_t *seconds);&#x2F;*params:- seconds: 假如seconds非NULL，该函数会将返回值填充到这里。return: 返回从 1970-01-01 00:00:00到现在经过的秒数。*&#x2F; 实例 123456789101112#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t seconds; seconds &#x3D; time(NULL); printf(&quot;自 1970-01-01 起的小时数 &#x3D; %ld\\n&quot;, seconds&#x2F;3600); return(0);&#125; 二、ctime函数函数定义 获取指定时间点的时间格式化字符串。 1234567char* ctime(const time_t *timer);&#x2F;*params:- timer: 需要输出时间格式化字符串的时间点。return: 返回指定时间点的时间格式化字符串。格式如：Mon Aug 13 08:23:14 2021*&#x2F; 实例 12345678910111213#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t curtime; time(&amp;curtime); printf(&quot;当前时间 &#x3D; %s&quot;, ctime(&amp;curtime)); return(0);&#125; 三、localtime函数函数定义 将time_t的时间类型转换成tm结构体的时间类型。 返回的时间为本地时间，即默认加上了电脑上配置的时区偏移小时差。 1struct tm *localtime(const time_t *timer); 实例 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t rawtime; struct tm *info; char buffer[80]; time( &amp;rawtime ); info &#x3D; localtime( &amp;rawtime ); printf(&quot;当前的本地时间和日期：%s&quot;, asctime(info)); return(0);&#125; 四、clock函数函数定义 获取从程序执行起，处理器时钟所使用的时间。 假如需要获取CPU所使用的秒数，需要除以CLOCKS_PER_SEC。 123456clock_t clock(void);&#x2F;*return:返回自程序启动起，处理器时钟所使用的时间。如果失败，则返回 -1 值。*&#x2F; 示例 12345678910111213141516171819202122232425#include &lt;time.h&gt;#include &lt;stdio.h&gt; int main()&#123; clock_t start_t, end_t; double total_t; int i; start_t &#x3D; clock(); printf(&quot;程序启动，start_t &#x3D; %ld\\n&quot;, start_t); printf(&quot;开始一个大循环，start_t &#x3D; %ld\\n&quot;, start_t); for(i&#x3D;0; i&lt; 10000000; i++) &#123; &#125; end_t &#x3D; clock(); printf(&quot;大循环结束，end_t &#x3D; %ld\\n&quot;, end_t); total_t &#x3D; (double)(end_t - start_t) &#x2F; CLOCKS_PER_SEC; printf(&quot;CPU 占用的总时间：%f\\n&quot;, total_t ); printf(&quot;程序退出...\\n&quot;); return(0);&#125; 五、asctime函数函数定义 输出结构体tm时间的格式化字符串。 1234567char *asctime(const struct tm *timeptr);&#x2F;*return:输出结构体&#96;tm&#96;时间的格式化字符串。格式如：Sat Mar 25 06:10:10 1989*&#x2F; 示例 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;int main()&#123; struct tm t; t.tm_sec &#x3D; 10; t.tm_min &#x3D; 10; t.tm_hour &#x3D; 6; t.tm_mday &#x3D; 25; t.tm_mon &#x3D; 2; t.tm_year &#x3D; 89; t.tm_wday &#x3D; 6; puts(asctime(&amp;t)); return(0);&#125; 六、gmtime函数函数定义 将time_t的时间类型转换成tm结构体的时间类型。 返回的时间为格林尼治标准时间，不会自动加上电脑上配置的时区偏移小时差。 1struct tm *gmtime(const time_t *timer); 示例 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;time.h&gt; #define BST (+1)#define CCT (+8) int main ()&#123; time_t rawtime; struct tm *info; time(&amp;rawtime); &#x2F;* 获取 GMT 时间 *&#x2F; info &#x3D; gmtime(&amp;rawtime ); printf(&quot;当前的世界时钟：\\n&quot;); printf(&quot;伦敦：%2d:%02d\\n&quot;, (info-&gt;tm_hour+BST)%24, info-&gt;tm_min); printf(&quot;中国：%2d:%02d\\n&quot;, (info-&gt;tm_hour+CCT)%24, info-&gt;tm_min); return(0);&#125; 七、mktime函数函数定义 输出由结构体tm的时间变量转换成time_t类型的本地时间戳。 1time_t mktime(struct tm *timeptr) 示例 123456789101112131415161718192021222324252627282930&#x2F;* 输入日期判断是周几 *&#x2F;#include &lt;stdio.h&gt; &#x2F;* printf, scanf *&#x2F;#include &lt;time.h&gt; &#x2F;* time_t, struct tm, time, mktime *&#x2F; int main ()&#123; time_t rawtime; struct tm * timeinfo; int year, month ,day; const char * weekday[] &#x3D; &#123; &quot;周日&quot;, &quot;周一&quot;,&quot;周二&quot;, &quot;周三&quot;,&quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot;&#125;; &#x2F;* 用户输入日期 *&#x2F; printf (&quot;年: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;year); printf (&quot;月: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;month); printf (&quot;日: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;day); &#x2F;* 获取当前时间信息，并修改用户输入的输入信息 *&#x2F; time ( &amp;rawtime ); timeinfo &#x3D; localtime ( &amp;rawtime ); timeinfo-&gt;tm_year &#x3D; year - 1900; timeinfo-&gt;tm_mon &#x3D; month - 1; timeinfo-&gt;tm_mday &#x3D; day; &#x2F;* 调用 mktime: timeinfo-&gt;tm_wday *&#x2F; mktime ( timeinfo ); printf (&quot;那一天是：%s\\n&quot;, weekday[timeinfo-&gt;tm_wday]); return 0;&#125; 八、difftime函数函数定义 输出两个time_t类型的时间变量之间的秒数差。 1double difftime(time_t time1, time_t time2) 示例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;time.h&gt;#ifdef _WIN32#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#endif int main ()&#123; time_t start_t, end_t; double diff_t; printf(&quot;程序启动...\\n&quot;); time(&amp;start_t); printf(&quot;休眠 5 秒...\\n&quot;); sleep(5); time(&amp;end_t); diff_t &#x3D; difftime(end_t, start_t); printf(&quot;执行时间 &#x3D; %f\\n&quot;, diff_t); printf(&quot;程序退出...\\n&quot;); return(0);&#125; 九、strftime函数函数定义 输出结构体tm类型的变量的时间格式化字符串。 123456789101112size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr);&#x2F;*params:- str：输出的时间格式化字符串存储空间。- maxsize：存储空间str的最大字符数。- format：格式化模版。- timeptr：需要输出时间格式化字符串的变量。return:返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。*&#x2F; 格式化模版使用的含义符参见：菜鸟教程 示例 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t rawtime; struct tm *info; char buffer[80]; time( &amp;rawtime ); info &#x3D; localtime( &amp;rawtime ); strftime(buffer, 80, &quot;%Y-%m-%d %H:%M:%S&quot;, info); printf(&quot;格式化的日期 &amp; 时间 : |%s|\\n&quot;, buffer ); return(0);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"}],"tags":[{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"}]},{"title":"GC标记-清除算法","slug":"GC_mark_sweep_algorithm","date":"2021-03-14T16:00:00.000Z","updated":"2021-04-20T09:13:22.502Z","comments":true,"path":"2021/03/15/GC_mark_sweep_algorithm/","link":"","permalink":"https://www.chaguake.com/2021/03/15/GC_mark_sweep_algorithm/","excerpt":"","text":"GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的内存空间重新得到利用。 伪代码标记-清除算法的伪代码： 12345mark_sweep()&#123; mark_phase(); sweep_phase();&#125; 回收内存部分以下图的堆为例子，对各个阶段进行说明： 标记阶段根据上面出现的mark_phase()函数来进行标记阶段的处理。 mark_phase()函数伪代码： 12345mark_phase()&#123; for(r : $roots); mark(*r);&#125; 在标记阶段中，collector 会为堆里的所有活动对象打上标记。为此，我们首先要标记通过根直接引用的对象。首先我们标记这样的对象，然后递归地标记通过指针数组能访问到的对象。这样就能把所有活动对象都标记上了。 mark()函数伪代码： 1234567891011mark(obj)&#123; if(obj.mark == FALSE) &#123; obj.mark == TRUE; for(child : children(obj)) &#123; mark(*child); &#125; &#125;&#125; 在第 2 行中，检查作为实参传递的 obj 是否已被标记。在引用中包含了循环等的情况下，即使对已被标记的对象，有时程序也会调用 mark() 函数。出现类似这种情况的时候，我们就要避免重复进行标记处理。 如果标记未完成，则程序会在对象的头部进行置位操作。这个位要分配在对象的头之中，并且能用 obj.mark 访问。意思是若 obj.mark 为真，则表示对象已标记；若 obj.mark 为假，则对象没有被标记。 标记完所有活动对象后，标记阶段就结束了。标记阶段结束时的堆如下图所示： 在标记阶段中，程序会标记所有活动对象。毫无疑问，标记所花费的时间是与“活动对象的总数”成正比的。 以上是关于标记阶段的说明。用一句话概括，标记阶段就是“遍历对象并标记”的处理过程。这个“遍历对象”的处理过程在 GC 中是一个非常重要的概念，在之后还会多次出现，请务必记牢。 专栏深度优先搜索 广度优先搜索 比较一下内存使用量（已存储的对象数量）就可以知道，深度优先搜索比广度优先搜索更能压低内存使用量。 清除阶段在清除阶段中，collector 会遍历整个堆，回收没有打上标记的对象（即垃圾），使其能再次得到利用。 sweep_phase()函数伪代码： 123456789101112131415sweep_phase()&#123; sweeping = $heap_start; while(sweeping &lt; $heap_end) &#123; if(sweeping.mark == TRUE) sweeping.mark == FALSE; else &#123; sweeping.next = $free_list; $file_list = sweeping; &#125; &#125; sweeping += sweeping.size;&#125; 在此出现了叫作 size 的域，这是存储对象大小（字节数）的域。跟 mark 域一样，我们事先在各对象的头中定义它们。 在清除阶段，我们使用变量 sweeping 遍历堆，具体来说就是从堆首地址 $heap_start 开始，按顺序一个个遍历对象的标志位。 设置了标志位，就说明这个对象是活动对象。活动对象必然是不能回收的。在第 5 行我们取消标志位，准备下一次的 GC。 我们必须把非活动对象回收再利用。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。 我们在 sweep_phase() 函数的第 7 行、第 8 行进行这项操作。 在第 7 行新出现了叫作 next 的域。我们只在生成空闲链表以及从这个空闲链表中取出分块时才会使用到它。没有必要为各个对象特别准备域，从对象已有的域之中分出来一个就够了。在本章中，next 表示对象（或者分块）最初的域，即 field1。也就是说，给 field1 这个域起个别名叫 next。这跟 C 语言中的联合体（union）的概念相同。 在清除阶段，程序会遍历所有堆，进行垃圾回收。也就是说，所花费时间与堆大小成正比。堆越大，清除阶段所花费的时间就会越长。 分配部分分配这里的分配是指将回收的垃圾进行再利用。当 mutator 申请分块时，怎样才能把大小合适的分块分配给 mutator 呢？ 在清除阶段已经把垃圾对象连接到空闲链表了。搜索空闲链表并寻找大小合适的分块，这项操作就叫作分配。 执行分配的函数new_obj()伪代码： 12345678new_obj(size)&#123; chunk = pickup_chunk(size, $free_list); if(chunk != NULL) return chunk; else allocation_fail();&#125; 第 2 行的 pickup_chunk() 函数用于遍历 $free_list，寻找大于等于 size 的分块。它不光会返回和 size 大小相同的分块，还会返回比 size 大的分块。如果它找到和 size 大小相同的分块，则会直接返回该分块；如果它找到比 size 大的分块，则会将其分割成 size 大小的分块和去掉 size 后剩余大小的分块，并把剩余的分块返回空闲链表。 如果此函数没有找到合适的分块，则会返回 NULL。返回 NULL 时分配是不会进行的。 专栏First - fit、Best - fit、Worst - fit 的不同之前我们讲的分配策略叫作 First - fit。因为在 pickup_chunk() 函数中，最初发现大于等于 size 的分块时就会立即返回该分块。 然而，分配策略不止这些。还有遍历空闲链表，返回大于等于 size 的最小分块，这种策略叫作 Best - fit。 还有一种策略叫作 Worst - fit，即找出空闲链表中最大的分块，将其分割成 mutator 申请的大小和分割后剩余的大小，目的是将分割后剩余的分块最大化。但因为 Worst - fit 很容易生成大量小的分块，所以不推荐大家使用此方法。 除去 Worst - fit，剩下的还有 Best - fit 和 First - fit 这两种。当我们使用单纯的空闲链表时，考虑到分配所需的时间，选择使用 First - fit 更为明智。 合并前文中已经提过，根据分配策略的不同可能会产生大量的小分块。但如果它们是连续的，我们就能把所有的小分块连在一起形成一个大分块。这种“连接连续分块”的操作就叫作合并（coalescing），合并是在清除阶段进行的。 执行合并的函数sweep_phase()伪代码： 1234567891011121314151617181920sweep_phase()&#123; sweeping = $heap_start; while(sweeping &lt; $heap_end) &#123; if(sweeping.mark == TRUE) sweeping.mark = FALSE; else &#123; if(sweeping == $free_list + $free_list.size) $free_list.size +=sweeping.size; else &#123; sweeping.next = $free_list; $free_list = sweeping; &#125; &#125; sweeping += sweeping.size; &#125;&#125; 上面的sweep_phase() 函数只有第 7 行、第 8 行与上文的sweep_phase() 函数不同。第 7 行用于调查这次发现的分块和上次发现的分块是否连续，如果发现分块连续，则在第 8 行将邻接的 2 个分块合并，整理成 1 个分块。 优点实现简单与保守式 GC 算法兼容 GC 标记 - 清除算法因为不会移动对象，所以非常适合搭配保守式 GC 算法。 缺点碎片化在 GC 标记 - 清除算法的使用过程中会逐渐产生被细化的分块，不久后就会导致无数的小分块散布在堆的各处。我们称这种状况为碎片化（fragmentation）。 如果发生碎片化，那么即使堆中分块的总大小够用，也会因为一个个的分块都太小而不能执行分配。 此外，如果发生碎片化，就会增加 mutator 的执行负担。（把具有引用关系的对象安排在堆中较远的位置，就会增加访问所需的时间） 因为分块在堆中的分布情况取决于 mutator 的运行情况，所以只要使用 GC 标记 - 清除算法，就会或多或少地产生碎片化。 为了避免碎片化，需要对其进行“压缩”，或者采用“BiBOP 法”。 分配速度GC 标记 - 清除算法中分块不是连续的，因此每次分配都必须遍历空闲链表，找到足够大的分块。最糟的情况就是每次进行分配都得把空闲链表遍历到最后。 另一方面，因为在 GC 复制算法和 GC 标记 - 压缩算法中，分块是作为一个连续的内存空间存在的，所以没必要遍历空闲链表，分配就能非常高速地进行，而且还能在堆允许范围内分配很大的对象。 多个空闲链表（multiple free-list）和 BiBOP 法都是为了能在 GC 标记 - 清除算法中高速进行分配而想出的方法。 与写时复制技术不兼容写时复制技术（copy-on-write）是在 Linux 等众多 UNIX 操作系统的虚拟存储中用到的高速化方法。打个比方，在 Linux 中复制进程，也就是使用 fork() 函数时，大部分内存空间都不会被复制。只是复制进程，就复制了所有内存空间的话也太说不过去了吧。因此，写时复制技术只是装作已经复制了内存空间，实际上是将内存空间共享了。 在各个进程中访问数据时，能够访问共享内存就没什么问题了。 然而，当我们对共享内存空间进行写入时，不能直接重写共享内存。因为从其他程序访问时，会发生数据不一致的情况。在重写时，要复制自己私有空间的数据，对这个私有空间进行重写。复制后只访问这个私有空间，不访问共享内存。像这样，因为这门技术是“在写入时进行复制”的，所以才被称为写时复制技术。 这样的话，GC 标记 - 清除算法就会存在一个问题 —— 与写时复制技术不兼容。即使没重写对象，GC 也会设置所有活动对象的标志位，这样就会频繁发生本不应该发生的复制，压迫到内存空间。 为了处理这个问题，我们采用位图标记（bitmap marking）的方法。 多个空闲链表之前我们讲的标记 - 清除算法中只用到了一个空闲链表，在这个空闲链表中，对大的分块和小的分块进行同样的处理。但是这样一来，每次分配的时候都要遍历一次空闲链表来寻找合适大小的分块，这样非常浪费时间。 因此，我们有一种方法，就是利用分块大小不同的空闲链表，即创建只连接大分块的空闲链表和只连接小分块的空闲链表。这样一来，只要按照 mutator 所申请的分块大小选择空闲链表，就能在短时间内找到符合条件的分块了。 当只利用一个空闲链表时，需要遍历多次空闲链表才能分配 3 个字的分块。 这次数组的各个元素都位于空闲链表的前面，第 1 个元素是由 2 个字的分块连接的空闲链表的开头，第 2 个元素是由 3 个字的分块连接的空闲链表的开头。因此，例如在分配 3 个字的分块时，只要查询用于 3 个字的空闲链表就够了。比起只利用一个空闲链表来说，此方法大幅节约了分配所需要的时间。 不过请稍等，这里有一处需要我们留意。那就是到底制造多少个空闲链表才好呢？用于 2 个字的空闲链表、用于 3 个字的、用于 500 个字的 …… 照这样下去，我们就得准备无数个空闲链表了。 一般情况下，mutator 很少会申请非常大的分块。为了应对这种极少出现的情况而大量制造空闲链表，会使得空闲链表的数组过于巨大，结果压迫到内存空间。 因此，我们通常会给分块大小设定一个上限，分块如果大于等于这个大小，就全部采用一个空闲链表处理。有人可能会想：“这样一来，最后不还是没能有效率地搜索大的分块吗？”然而，因为这种分配非常大的分块的情况是极为罕见的，所以效率低一点也不是什么大问题。比这更为重要的是怎么去更快地搜索 mutator 频繁申请分配的小分块，把关注的重点移到这上面来才是更精明的做法。打个比方，如果设定分块大小上限为 100 个字，那么准备用于 2 个字、3 个字、……、100 个字，以及大于等于 101 个字的总共 100 个空闲链表就可以了。 利用多个空闲链表时，我们需要修正 new_obj() 函数以及 sweep_phase() 函数。修正后的 new_obj() 函数以及 sweep_phase() 函数： 利用多个空闲链表的 new_obj() 函数伪代码： 1234567891011121314151617181920new_obj(size)&#123; index = size / (WORD_LENGTH / BYTE_LENGTH) if(index &lt;= 100) &#123; if($free_list[index] != NULL) &#123; chunk = $free_list[index]; $free_list[index] = $free_list[index].next; return chunk; &#125; &#125; else &#123; chunk = pickup_chunk(size, $free_list[101]); if(chunk != NULL) return chunk; &#125; allocation_fail();&#125; 利用多个空闲链表的 sweep_phase() 函数伪代码： 1234567891011121314151617181920212223242526sweep_phase()&#123; for(i:2..101) $free_list[i] = NULL; sweeping = $heap_start; while(sweeping &lt; $heap_end) &#123; if(sweeping.mark == TRUE) sweeping.mark = FALSE; else &#123; index = size / (WORK_LENGHT / BYTE_LENGHT); if(index &lt;= 100) &#123; sweeping.next = $free_list[index]; $free_list[index] = sweeping; &#125; else &#123; sweeping.next = $free_list[101]; $free_list[101] = sweeping; &#125; &#125; sweeping += sweeping.size; &#125;&#125; BiBOP 法BiBOP 是 Big Bag Of Pages 的缩写。含义是将大小相近的对象整理成固定大小的块进行管理的做法。 GC 标记 - 清除算法中会发生碎片化。碎片化的原因之一就是堆上杂乱散布着大小各异的对象。 对此，我们可以用这个方法：把堆分割成固定大小的块，让每个块只能配置同样大小的对象。这就是 BiBOP 法。 3 个字的对象被整合分配到左数第 1 个和第 3 个块，2 个字的对象被整合分配到左数第 2 个块。像这样配置对象，就会提高内存的使用效率。因为每个块中只能配置同样大小的对象，所以不可能出现大小不均的分块。 但是，使用 BiBOP 法并不能完全消除碎片化。比方说在全部用于 2 个字的块中，只有 1 到 2 个活动对象，这种情况下就不能算是有效利用了堆。 BiBOP 法原本是为了消除碎片化，提高堆使用效率而采用的方法。但像上面这样，在多个块中分散残留着同样大小的对象，反而会降低堆使用效率。 位图标记在单纯的 GC 标记 - 清除算法中，用于标记的位是被分配到各个对象的头中的。也就是说，算法是把对象和头一并处理的。然而这跟写时复制技术不兼容。 对此我们有个方法，那就是只收集各个对象的标志位并表格化，不跟对象一起管理。在标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。像这样集合了用于标记的位的表格称为“位图表格”（bitmap table），利用这个表格进行标记的行为称为“位图标记”。位图表格的实现方法有多种，例如散列表和树形结构等。为了简单起见，这里我们采用整数型数组。 在位图标记中重要的是，位图表格中位的位置要和堆里的各个对象切实对应。一般来说，堆中的 1 个字会分配到 1 个位。 位图标记中的 mark() 函数伪代码： 123456789101112mark(obj)&#123; obj_num = (obj - $heap_start) / WORD_LENGHT; index = obj_num / WORD_LENGHT; offset = obj_num % WORD_LENGHT; if(($bitmap_tbl[index] &amp; (1 &lt;&lt; offset)) == 0) &#123; $bitmap_tbl[index] != (1 &lt;&lt; offset); for(child : children(obj)) mark(*child); &#125;&#125; 在这里，WORD_LENGTH 是个常量，表示的是各机器中 1 个字的位宽（例如 32 位机器的 WORD_LENGTH 就是 32）。obj_num 指的是从位图表格前面数起，obj 的标志位在第几个。如上图的 E，它的 obj_num 值就是 8。但下图中位的排序顺序和上图是相反的。因此，E 的标志位是从 bitmap_table[0] 的右边起第 9 个位。 我们用 obj_num 除以 WORD_LENGTH 得到的商 index 以及余数 offset 来分别表示位图表格的行编号和列编号。第 6 行和第 7 行中用到了位运算，看上去有些复杂，实际上只是干了件非常简单的事情。 和在对象的头中直接置标志位的方法相比，该方法稍微有些复杂，但是这样做有两个好处。 优点与写时复制技术兼容以往的标记操作都是直接对对象设置标志位，这会产生无谓的复制。 然而，使用位图标记是不会对对象设置标志位的，所以也不会发生无谓的复制。当然，因为对位图表格进行了重写，所以在此处会发生复制。不过，因为位图表格非常小，所以即使被复制也不会有什么大的影响。 此外，以上问题只发生在写时复制技术的运行环境（Linux 等）中，以及频繁执行 fork() 函数的应用程序中。也就是说，它对于一般的程序来说完全不是问题。 清除操作更高效不仅在标记阶段，在清除阶段也可以得到好处。以往的清除操作都必须遍历整个堆，把非活动对象连接到空闲链表，同时取消活动对象的标志位。 利用了位图表格的清除操作则把所有对象的标志位集合到一处，所以可以快速消去标志位。 位图标记的sweep_phase() 函数伪代码： 1234567891011121314151617181920sweep_phase()&#123; sweeping = $heap_start; index = 0; offset = 0; while(sweeping &lt; $heap_end) &#123; if($bitmap_tbl[index] &amp; (1 &lt;&lt; offset) == 0) &#123; sweeping.next = $free_list; $free_list = sweeping &#125; index += (offset + sweeping.size) / WORD_LENGTH; offset = (offset + sweeping.size) % WORD_LENGTH; sweeping += sweeping.size; &#125; for(i : 0..(HEAP_SIZE / WORD_LENGTH - 1)) $bitmap_tbl[i] = 0&#125; 与一般的清除阶段相同，我们用 sweeping 指针遍历整个堆。不过，这里使用了 index 和 offset 两个变量，在遍历堆的同时也遍历位图表格。 第 6 行到第 12 行是从堆的开头开始遍历。第 7 行是调查遍历过程中与对象对应的标志位。当对象没有设置标志位时，程序会在第 8 行和第 9 行将此对象连接到空闲链表。当对象已经设立了标志位时，程序就不会在此进行消除位的操作，而是放到之后一并进行。 第 10 行、第 11 行是遍历位图表格，第 12 行是遍历堆。 第 14 行、第 15 行是把所有在位图表格中设置的位取消。因为能够一并消除标志位，所以能够有效地取消位。 要注意的地方在进行位图标记的过程中，有件事情我们必须注意，那就是对象地址和位图表格的对应。就像之前和大家说明的那样，想通过对象的地址求与其对应的标志位的位置，是要进行位运算的。然而在堆有多个，对象地址不连续的情况下，我们无法用单纯的位运算求出标志位的位置。因此，在堆为多个的情况下，一般会为每个堆都准备一个位图表格。 延迟清除法清除操作所花费的时间是与堆大小成正比的。也就是说，处理的堆越大，GC 标记 - 清除算法所花费的时间就越长，结果就会妨碍到 mutator 的处理。 延迟清除法（Lazy Sweep）是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在标记操作结束后，不一并进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。 延迟清除法中的 new_obj() 函数伪代码： 1234567891011new_obj(size)&#123; chunk = lazy_sweep(size); if(chunk != NULL) return chunk; mark_phase(); chunk = lazy_sweep(size); if(chunk != NULL) return chunk; allocation_fail();&#125; 在分配时直接调用 lazy_sweep() 函数，进行清除操作。如果它能用清除操作来分配分块，就会返回分块；如果不能分配分块，就会执行标记操作。当 lazy_sweep() 函数返回 NULL 时，也就是没有找到分块时，会调用 mark_phase() 函数进行一遍标记操作，再调用 lazy_sweep() 函数来分配分块。在这里没能分配分块也就意味着堆上没有分块，mutator 也就不能再进行下一步处理了。 lazy_sweep() 函数伪代码： 12345678910111213141516171819lazy_sweep(size)&#123; while($sweeping &lt; $heap_end) &#123; if($sweeping.mark == TRUE) &#123; $sweeping.mark = FALSE; &#125; else if($sweeping.size &gt;= size) &#123; chunk = $sweeping; $sweeping += $sweeping.size; return chunk; &#125; $sweeping += $sweeping.size; &#125; $sweeping = $heap_start; return NULL;&#125; lazy_sweep() 函数会一直遍历堆，直到找到大于等于所申请大小的分块为止。在找到合适分块时会将其返回。但是在这里 $sweeping 变量是全局变量。也就是说，遍历的开始位置位于上一次清除操作中发现的分块的右边。 当 lazy_sweep() 函数遍历到堆最后都没有找到分块时，会返回 NULL。 因为延迟清除法不是一下遍历整个堆，它只在分配时执行必要的遍历，所以可以压缩因清除操作而导致的 mutator 的暂停时间。这就是“延迟”清除操作的意思。 我们已经知道，通过延迟清除法可以缩减 mutator 的暂停时间，不过这是真的吗？稍微想想看就会明白，延迟清除的效果是不均衡的。打个比方，假设刚标记完的堆的情况如下图 所示。 也就是说，垃圾变成了垃圾堆，活动对象变成了活动对象堆，它们形成了一种邻接的状态。在这种情况下，程序在清除垃圾较多的部分时能马上获得分块，所以能减少 mutator 的暂停时间。然而一旦程序开始清除活动对象周围，就怎么也无法获得分块了，这样就增加了 mutator 的暂停时间。 结果，如果一下子清除的堆大小不一定，那么 mutator 的暂停时间就会增大。 关于保持所清除的堆大小的方法，后文详细说明。 虽然在这里没有特别提及，不过标记阶段导致的暂停时间和清除阶段导致的暂停时间一样，也是个问题。关于如何改善这个问题，也是在后文详细说明。","categories":[{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《垃圾回收的算法与实现》","slug":"《垃圾回收的算法与实现》","permalink":"https://www.chaguake.com/tags/%E3%80%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"}]},{"title":"C++多态之虚函数与虚函数表","slug":"virtual_function_or_table_of_polymorphism","date":"2021-03-13T16:00:00.000Z","updated":"2021-03-14T10:53:29.587Z","comments":true,"path":"2021/03/14/virtual_function_or_table_of_polymorphism/","link":"","permalink":"https://www.chaguake.com/2021/03/14/virtual_function_or_table_of_polymorphism/","excerpt":"","text":"虚函数，是用关键字virtual修饰的类成员函数，但不包括静态函数（static）和构造函数。 内联函数（inline）可以是虚函数。因为内联函数是作用于编译期间，用于通知编译器是否要将内联函数展开。当虚函数标记为内联函数时，假如该函数呈现运行时多态，那么编译器会忽略关键字inline。 12345678910111213141516171819202122class Base&#123;public: Base(); ~Base(); virtual void fun1(); virtual void fun2();&#125;class Device:public Base&#123;public: Device(); virtual ~Device();&#x2F;&#x2F;确保Device类正常析构 virtual void fun1(); void fun2();&#x2F;&#x2F;不加关键字virtual也可以 virtual void print();&#125;&#x2F;&#x2F;Device dev;&#x2F;&#x2F;dev.fun1();&#x2F;&#x2F;dev.fun2(); 运行上面代码，可以发现，对象dev有一个指针对象__vfptr。 指针对象__vfptr是虚函数指针，类型为void(*)()，它指向对象dev的数组vftable，即虚函数表。 定义另一个Device类对象，可以看到，两个Device类对象的指针对象__vfptr的地址是一样的，这就意味着，Device类的虚函数表全局只有一份，所有Device类对象都会创建一个虚函数指针，并指向它。 在Device类中定义虚函数print，会发现在__vfptr中并没有发现它，但vftable大小+1，派生另一个类，继承于Device类，其__vfptr和vftable跟Device类一样。 这就说明，继承于Base类，但属于其子类的虚函数都会按顺序写入基类的vftable里。（假如有多继承，那属于其子类的虚函数都会按顺序写入第一个基类的vftable里。） 那假如基类并没有虚函数呢？ 可以看出，vftable会挂在基类的下一级子类中（或者再下一级）。 其他博客的相关文章：C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"}],"tags":[{"name":"C++多态","slug":"C-多态","permalink":"https://www.chaguake.com/tags/C-%E5%A4%9A%E6%80%81/"}]}],"categories":[{"name":"图形学","slug":"图形学","permalink":"https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"},{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"},{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"数据库","slug":"数据库","permalink":"https://www.chaguake.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"},{"name":"问题排查","slug":"问题排查","permalink":"https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"面试","permalink":"https://www.chaguake.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/categories/lua/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/tags/OpenGL/"},{"name":"Ray Tracing","slug":"Ray-Tracing","permalink":"https://www.chaguake.com/tags/Ray-Tracing/"},{"name":"SDF","slug":"SDF","permalink":"https://www.chaguake.com/tags/SDF/"},{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"},{"name":"blender源码","slug":"blender源码","permalink":"https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"},{"name":"blender工具","slug":"blender工具","permalink":"https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"},{"name":"《Go语言高级编程》","slug":"《Go语言高级编程》","permalink":"https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.chaguake.com/tags/Mysql/"},{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"},{"name":"问题排查之TCP","slug":"问题排查之TCP","permalink":"https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.chaguake.com/tags/TCP/"},{"name":"抽样算法","slug":"抽样算法","permalink":"https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"},{"name":"洗牌算法","slug":"洗牌算法","permalink":"https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/tags/lua/"},{"name":"《垃圾回收的算法与实现》","slug":"《垃圾回收的算法与实现》","permalink":"https://www.chaguake.com/tags/%E3%80%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"},{"name":"C++多态","slug":"C-多态","permalink":"https://www.chaguake.com/tags/C-%E5%A4%9A%E6%80%81/"}]}