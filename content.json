{"meta":{"title":"茶瓜客","subtitle":"解衣又作茶瓜客，倚槛同看烟雨峰","description":"解衣又作茶瓜客，倚槛同看烟雨峰","author":"茶瓜客","url":"https://www.chaguake.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-03-09T07:38:35.984Z","updated":"2021-03-09T05:57:02.612Z","comments":false,"path":"/404.html","permalink":"https://www.chaguake.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-11T07:34:30.643Z","updated":"2021-03-11T07:34:30.643Z","comments":true,"path":"about/index.html","permalink":"https://www.chaguake.com/about/index.html","excerpt":"","text":"这个人很懒，什么也没有留下……"},{"title":"书单","date":"2021-03-11T03:27:43.709Z","updated":"2021-03-11T03:27:43.709Z","comments":true,"path":"books/index.html","permalink":"https://www.chaguake.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-03-09T07:36:46.388Z","updated":"2021-03-09T05:57:02.612Z","comments":false,"path":"categories/index.html","permalink":"https://www.chaguake.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-03-09T06:20:35.606Z","updated":"2021-03-09T05:57:02.612Z","comments":true,"path":"links/index.html","permalink":"https://www.chaguake.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-03-11T03:28:04.838Z","updated":"2021-03-11T03:28:04.838Z","comments":true,"path":"repository/index.html","permalink":"https://www.chaguake.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-09T07:36:46.388Z","updated":"2021-03-09T05:57:02.612Z","comments":false,"path":"tags/index.html","permalink":"https://www.chaguake.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"blender快捷键汇总","slug":"blender-hot-key","date":"2021-04-28T03:09:11.000Z","updated":"2021-04-28T07:34:26.934Z","comments":true,"path":"2021/04/28/blender-hot-key/","link":"","permalink":"https://www.chaguake.com/2021/04/28/blender-hot-key/","excerpt":"","text":"文章参考： Blender2.9入门篇 模拟游戏引擎角色操作（第一人称视角）快捷键：Shift + ~ 在blender下面的状态栏会有操作按键提示。 常用快捷键1、快捷键：Ctrl + Tab 弹出模式选择导航，鼠标移动选择（也可以左上角点击下拉框选择）。 2、快捷键：Tab 快速进入编辑模式，再按一次返回物体模式。 3、快捷键：G 移动选中物体，左键确认，右键取消。 再点击X或Y或Z键，可沿对应轴水平移动。 按住鼠标中键，可以在xyz轴上，快速实现物体从一个轴跳到另一个轴，并且带上对原点的偏移量。 4、快捷键：Alt + G 物体位置回归原点(0,0,0)。 5、快捷键：Shift + A 打开Add菜单。 6、快捷键：Ctrl + N 打开New File菜单。 7、快捷键：长按Shift + 其他 微调操作，使得数值增值步长变小。 8、快捷键：Shift + R 重复上一个命令。 9、快捷键：Ctrl + Z 撤销操作。 10、快捷键：F3 弹出操作搜索窗口。 11、快捷键：F2 选中物体重命名。 12、快捷键：Ctrl + Space 视图最大化（右侧停靠窗隐藏）。 13、快捷键：Ctrl + Shift + Space 视图全屏。 14、快捷键：Z 弹出着色方式选择导航，鼠标移动选择（也可以右上角点击选择）。 15、快捷键：Shift + Z 线框显示和实体显示切换。 16、快捷键：Ctrl + ~ 显示/隐藏Gizmo（视图右上角竖着排列的控件）。 17、快捷键：鼠标中键 + 上下移动 自由切换视角。 18、快捷键：Alt + 鼠标中键 + 上下移动 切换六个正视角（顶、底、前、后、左、右）。 也可以用数字键盘来切换视角： 操作 快捷键 切换到顶视角 7 切换到底视角 Ctrl + 7 切换到前视角 1 切换到后视角 Ctrl + 1 切换到右视角 3 切换到左视角 Ctrl + 3 切换到摄像机视角 0 正交视图和透视图切换 5 四视图和透视图切换 Ctrl + Alt + Q 上下旋转视角 8或2 左右旋转视角 6或4 视角旋转180° 9 19、快捷键：N 显示/隐藏视图右侧停靠窗口。 20、快捷键：Shift + 鼠标中键 自由移动视图。 21、快捷键：H 隐藏选中项。 22、快捷键：Shift + H 隐藏未选中项。 23、快捷键：Alt + H 显示所有隐藏对象。 24、快捷键：数字键盘/ 居中放大选中对象，再次点击返回原来视角。 25、快捷键：数字键盘. 居中放大选中对象，不会返回原来视角。 26、快捷键：Home 或者 Shift + C 完整显示场景所有对象（被隐藏除外）。 27、快捷键：Ctrl + A 打开Apply菜单。 28、快捷键：T 显示/隐藏视图左侧工具菜单。 29、快捷键：Shift + Space 打开工具菜单，跟视图左侧工具菜单一样。 30、快捷键：Shift + 鼠标右键 放置游标在鼠标位置。 31、快捷键：Shift + C 将游标放在原点(0,0,0)。 32、快捷键：Shift + S 打开游标菜单导航。 33、快捷键：&lt; 变换坐标系。同样可在视图上方点击下拉框切换。 34、快捷键：&gt; 变换轴心点。同样可在视图上方点击下拉框切换。 35、快捷键：Shift + D 复制。 36、快捷键：Alt + D 关联复制。 37、快捷键：Ctrl + J 将选中的所有对象模型合并成一个对象模型。 38、快捷键：W 框选、套索、圈选工具切换。 39、快捷键：Ctrl + M 镜像（反向翻转），需要再输入轴键（X或Y或Z）。","categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"}],"tags":[{"name":"blender工具","slug":"blender工具","permalink":"https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"}]},{"title":"OpenGL入门（四）——着色器","slug":"OpenGL-introduction-04","date":"2021-04-22T08:53:15.000Z","updated":"2021-04-23T02:03:07.418Z","comments":true,"path":"2021/04/22/OpenGL-introduction-04/","link":"","permalink":"https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/","excerpt":"","text":"英文原文地址 中文翻译地址 着色器（Shader）是运行在GPU上的小程序，用于图形渲染管线的某个特定部分。 而在OpenGL使用GLSL这一门着色器语言来实现着色器程序。 GLSL着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。 着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。 一个典型的着色器有下面的结构： 123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123; &#x2F;&#x2F; 处理输入并进行一些图形操作 ... &#x2F;&#x2F; 输出处理过的结果到输出变量 out_variable_name &#x3D; weird_stuff_we_processed;&#125; 向量GLSL包含C语言大部分默认的基础数据类型。 向量是GLSL中比较常用的数据类型，常见的类型形式如下（n代表分量的数量）： 类型 含义 vecn 包含n个float分量的默认向量 bvecn 包含n个bool分量的向量 ivecn 包含n个int分量的向量 uvecn 包含n个unsigned int分量的向量 dvecn 包含n个double分量的向量 向量支持重组特性，一个向量的分量可以由其他的向量组成： 123vec2 vect &#x3D; vec2(0.1, 0.1)vec4 result &#x3D; vec4(vect, 0.0, 0.0)vec4 result2 &#x3D; vec4(result.xyz, 1.0) 输入与输出GLSL定义了in和out关键字实现着色器的输入和输出。 下面举个例子，顶点着色器接收一个3个分量的顶点位置向量，然后输出一个4个分量的顶点颜色向量，它会作为片段着色器的输入。 顶点着色器代码： 12345678910#version 330 corelayout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为0out vec4 vertexColor; &#x2F;&#x2F; 为片段着色器指定一个颜色输出void main()&#123; gl_Position &#x3D; vec4(aPos, 1.0); &#x2F;&#x2F; 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor &#x3D; vec4(0.5, 0.0, 0.0, 1.0); &#x2F;&#x2F; 把输出变量设置为暗红色&#125; 片段着色器代码： 123456789#version 330 coreout vec4 FragColor;in vec4 vertexColor; &#x2F;&#x2F; 从顶点着色器传来的输入变量（名称相同、类型相同）void main()&#123; FragColor &#x3D; vertexColor;&#125; uniformuniform提供了从CPU应用程序向GPU着色器程序发送数据的能力。 并且，uniform变量是全局的，它必须在每个着色器程序对象中有且只有一个，并且它可以被着色器程序的任意着色器在任意阶段访问。 使用方法如下： 在片段着色器中定义uniform变量。 123456789#version 330 coreout vec4 FragColor;uniform vec4 ourColor; &#x2F;&#x2F; 在OpenGL程序代码中设定这个变量void main()&#123; FragColor &#x3D; ourColor;&#125; 在C/C++代码中，使用glGetUniformLocation函数获取该uniform变量，然后使用glUniform4f函数对其赋值。 12345float timeValue &#x3D; glfwGetTime();float greenValue &#x3D; (sin(timeValue) &#x2F; 2.0f) + 0.5f;int vertexColorLocation &#x3D; glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); 值得注意的是，如果glGetUniformLocation返回-1就代表没有找到这个位置值。 而且，glUniform4f函数是属于设置uniform函数族中的一个，因为OpenGL底层是C库，不支持重载。 传递多个属性在上面的例子中，只是传递了顶点位置的属性到顶点着色器上，那怎样才能传递多个属性呢？ 首先，先给出顶点属性数据： 123456float vertices[] &#x3D; &#123; &#x2F;&#x2F; 位置 &#x2F;&#x2F; 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, &#x2F;&#x2F; 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, &#x2F;&#x2F; 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f &#x2F;&#x2F; 顶部&#125;; 然后再顶点着色器代码中接收多个输入，每个输入使用(location = n)来做绑定： 1234567891011#version 330 corelayout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为 0 layout (location &#x3D; 1) in vec3 aColor; &#x2F;&#x2F; 颜色变量的属性位置值为 1out vec3 ourColor; &#x2F;&#x2F; 向片段着色器输出一个颜色void main()&#123; gl_Position &#x3D; vec4(aPos, 1.0); ourColor &#x3D; aColor; &#x2F;&#x2F; 将ourColor设置为我们从顶点数据那里得到的输入颜色&#125; (location = n)对应C/C++代码中glVertexAttribPointer函数的第一个参数： 123456&#x2F;&#x2F; 位置属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);&#x2F;&#x2F; 颜色属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));glEnableVertexAttribArray(1); 给出顶点数据的存储结构图： 最后输出结果如下：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"第一章 Go语言基础——函数、方法和接口","slug":"Go-base-knowledge-02","date":"2021-04-21T02:59:56.000Z","updated":"2021-04-21T07:20:07.507Z","comments":true,"path":"2021/04/21/Go-base-knowledge-02/","link":"","permalink":"https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/","excerpt":"","text":"1.4 函数、方法和接口函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口定义了方法的集合。 Go语言通过隐式接口机制实现鸭子面向对象模型（所谓鸭子就是走路像鸭子，叫声像鸭子，那么它就可以当作鸭子）。 1.4.1 函数函数是一个操作序列，可以把它赋值给变量。 12345678910111213141516&#x2F;&#x2F;具名函数func Add(a, b int) &#123; return a+b&#125;var add &#x3D; Addadd(1, 2)Add(1, 2)&#x2F;&#x2F;匿名函数var Add &#x3D; func(a, b int) &#123; return a+b&#125;Add(1, 2) 函数的参数和返回值可以有多个，支持可变参数。 123456789101112func Swap(a, b int) &#123; return b, a&#125;func Sum(a int, more ...int) int &#123; for _, v :&#x3D; range more &#123; a +&#x3D; v &#125; return a&#125;sum :&#x3D; Sum(1, []int&#123;2, 3&#125;...) 可以给返回值命名，这样子返回值变量就可以在函数中使用，并且return语句可以不用带返回值（假如return语句带了变量，这是将变量赋值给返回值）。 1234567func Sum(a int, more ...int) (sum int) &#123; sum +&#x3D; a for _, v :&#x3D; range more &#123; sum +&#x3D; v &#125; return&#125; defer关键字 defer语句可以延迟执行一个函数，并且以栈的方式执行多个defer语句。 12345678910func main() &#123; for i :&#x3D; 0; i &lt; 3; i++ &#123; defer func()&#123;fmt.Println(i)&#125;() &#125;&#125;&#x2F;&#x2F; Output:&#x2F;&#x2F; 3&#x2F;&#x2F; 3&#x2F;&#x2F; 3 Go语言中指针不是固定不变的 Goroutine启动时只会分配很小的栈（4KB或8KB），在运行过程中才会不断扩充自己的栈空间，在增长过程中会拷贝之前的数据到新的内存空间。 并且，无法得知函数参数或局部变量到底是保存在栈中还是堆中。 1.4.2 方法方法是关联类型的函数。 1234567func (v *vType) Funcname() &#123; ...&#125;var v vTypev.Funcname() 方法表达式特性 可以使用方法表达式将方法还原为普通函数。 123&#x2F;&#x2F;func Funcname(v *vType)()&#123;...&#125;var Func &#x3D; (*vType).FuncnameFunc(v) 方法的继承 Go语言不支持传统面向对象中的继承特性，但可通过组合的方式支持方法的继承——通过在结构体内置匿名的成员来实现。 123456789101112import &quot;image&#x2F;color&quot;type Point struct &#123; X, Y float64 &#125;type ColoredPoint struct &#123; Point Color color.RGBA&#125;var cp ColoredPointcp.X &#x3D; 1cp.Point.X &#x3D; 2 看似cp.X中X是属于ColoredPoint类型的，实际上X依旧是属于匿名成员Point的。因为在编译期间，cp.X会被展开成cp.Point.X。 1.4.3 接口Go语言的接口类型是对其他类型行为的抽象和概括。而且，Go语言的借口类型是延迟绑定，可以实现类似虚函数的多态功能。 12345678910111213141516type UpperString stringfunc (s UpperString) String() string &#123; return strings.ToUpper(string(s))&#125;&#x2F;*接口在fmt包中有定义：type fmt.Stringer interface &#123; String() string&#125;*&#x2F;func main() &#123; fmt.Fprintln(os.Stdout, UpperString(&quot;hello, world&quot;))&#125; Go语言对接口类型的转换很灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。 123456var ( a io.ReadCloser &#x3D; (*os.File)(f) &#x2F;&#x2F;隐式转换 b io.Reader &#x3D; a &#x2F;&#x2F;隐式转换 c io.Closer &#x3D; a &#x2F;&#x2F;隐式转换 d io.Reader &#x3D; c.(io.Reader) &#x2F;&#x2F;显式转换)","categories":[{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《Go语言高级编程》","slug":"《Go语言高级编程》","permalink":"https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"}]},{"title":"第一章 Go语言基础——数组、字符串和切片","slug":"Go-base-knowledge-01","date":"2021-04-20T09:14:25.000Z","updated":"2021-04-21T02:58:25.031Z","comments":true,"path":"2021/04/20/Go-base-knowledge-01/","link":"","permalink":"https://www.chaguake.com/2021/04/20/Go-base-knowledge-01/","excerpt":"","text":"1.3 数组、字符串和切片这三种数据类型，在底层，原始数据有着相同的内存结构；在上层，因为语法的限制而有着不同的行为表现。 数组是一种值类型，虽然数组的元素可以修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理。 字符串底层是对应的字节数组，但是字符串的只读属性禁止了程序中对底层字节数组元素的修改。而且字符串赋值只是复制了数据地址和对应的长度。 切片的结构和字符串的结构相似，但是解除了只读限制。底层结构多了cap字段，用于表示切片的容量。 Go语言的赋值和函数传参规则很简单，除闭包函数以引用的方式对外部变量访问之外，其他赋值和函数传参都是以传值的方式处理。 1.3.1 数组数组是一个由固定长度的特定类型元素组成的序列，一个数组由零个或多个元素组成。 数组的长度是数组类型的组成部分，不同长度或不同类型的数据组成的数组都是不同的类型。 数组定义方式： 1234var a [3]int &#x2F;&#x2F;[0, 0, 0]var b &#x3D; [...]int&#123;1, 2, 3&#125; &#x2F;&#x2F;[1, 2, 3]var c &#x3D; [...]int&#123;2:3, 1:2&#125; &#x2F;&#x2F;[0, 2, 3]var d &#x3D; [...]int&#123;1, 2, 4:5, 6&#125; &#x2F;&#x2F;[1, 2, 0, 0, 5, 6] 数组是值语义，一个数组变量即整个数组，不能隐式地指向第一个元素的地址。 可以传递一个指向数组的指针，数组指针在使用上与数组变量差别不大： 123456789101112131415161718var a &#x3D; [...]int&#123;1, 2, 3&#125;var b &#x3D; &amp;afmt.Println(a[0])fmt.Println(b[0])for i :&#x3D; range a &#123; fmt.Println(i, a[i])&#125;for i, v :&#x3D; range b &#123; fmt.Println(i, v)&#125;&#x2F;&#x2F;效率性能比for range差for i :&#x3D; 0; i &lt; len(a); i++ &#123; fmt.Println(i, a[i])&#125; 使用for range方式迭代，还可以忽略迭代时的下标： 1234var times [5][0]intfor range times &#123; fmt.Println(&quot;hello&quot;)&#125; times是一个[5][0]int的二维数组，即[[], [], [], [], []]，整个数组的内存大小为0。 数组的类型可以是任意的，接口、结构体、函数都行。 长度为0的数组不占空间，可以用于占位或者类型声明。 123c1 :&#x3D; make(chan [0]int)&#x2F;&#x2F;等同于&#x2F;&#x2F;c1 :&#x3D; make(chan sttruct&#123;&#125;) 使用fmt.Printf打印数组的类型和详细信息： 123var b &#x3D; [...]int&#123;1, 2, 3&#125;fmt.Printf(&quot;b: %T\\n&quot;, b) &#x2F;&#x2F;b: [3]intfmt.Printf(&quot;b: %#v\\n&quot;, b) &#x2F;&#x2F;b: [3]int&#123;1, 2, 3&#125; 1.3.2 字符串字符串是不可改变的字符序列。 Go语言字符串的底层结构在reflect.StringHeader中定义： 1234type StringHeader struct &#123; Data uintptr Len int&#125; 对于字符串，与对应的byte数组的底层数据内存结构是一致的： 12345s :&#x3D; &quot;hello, world&quot;var data &#x3D; [...]byte &#123; &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;&#125; 字符串支持切片操作，不同位置的切片底层访问的是同一块内存数据。 1234567s :&#x3D; &quot;hello, world&quot;hello :&#x3D; s[:5]world :&#x3D; s[7:]s1 :&#x3D; &quot;hello, world&quot;[:5] &#x2F;&#x2F;&quot;hello, world&quot;[:5]与s[:5]指向的是用一个字符串常量s2 :&#x3D; &quot;hello, world&quot;[7:] 除了使用len函数获取字符串长度之外，也可以使用reflect.StringHeader结构访问字符串的长度。 1fmt.Println(&quot;len(s):&quot;, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len) 1.3.3 切片切片可以说是一种简化版的动态数组。底层数据结构reflect.SliceHeader如下： 12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; Cap表示切片指向的内存空间的最大容量，会按照规则实现自动扩充。 切片的定义方式： 1234567891011var ( a []int &#x2F;&#x2F;nil切片，和nil相等 b &#x3D; []int&#123;&#125; &#x2F;&#x2F;空切片 c &#x3D; []int&#123;1, 2, 3&#125; &#x2F;&#x2F;有3个元素的切片，len和cap都为3 d &#x3D; c[:2] &#x2F;&#x2F;有2个元素的切片，len为2，cap为3 e &#x3D; c[0:2:cap(c)] &#x2F;&#x2F;有2个元素的切片，len为2，cap为3 f &#x3D; c[:0] &#x2F;&#x2F;有0个元素的切片，len为0，cap为3 g &#x3D; make([]int, 3) &#x2F;&#x2F;有三个元素的切片，len和cap都为3 h &#x3D; make([]int, 2, 3) &#x2F;&#x2F;有2个元素的切片，len为2，cap为3 i &#x3D; make([]int, 0, 3) &#x2F;&#x2F;有0个元素的切片，len为0，cap为3) 添加切片元素 使用内置的append函数。值得注意的是，append函数有可能导致重新分配内存。 123456789101112var a []int&#x2F;&#x2F;切片尾部添加N个元素a &#x3D; append(a, 1)a &#x3D; append(a, 2, 3)a &#x3D; append(a, []int&#123;5, 6&#125;...)&#x2F;&#x2F;切片头部添加N个元素a &#x3D; append([]int&#123;0&#125;, a...)&#x2F;&#x2F;切片中间添加N个元素a &#x3D; append(a[:4], append([]int&#123;4&#125;, a[4:]...)...) 在切片中间添加元素时，append会创建临时切片。可使用copy函数和append函数组合，避免创建临时切片： 123a &#x3D; append(a, 0) &#x2F;&#x2F;扩充空间，需要插入N个就扩充Ncopy(a[5:], a[4:]) &#x2F;&#x2F;a[4:]后移一个位置a[4] &#x3D; 4 删除切片元素 删除头部和尾部的元素，可直接重新赋值范围即可： 123456789var a &#x3D; []int&#123;1, 2, 3&#125;&#x2F;&#x2F;删除尾部a &#x3D; a[:len(a)-1]a &#x3D; a[:len(a)-N]&#x2F;&#x2F;删除头部a &#x3D; a[1:]a &#x3D; a[N:] 删除头部元素或中间元素也可以用append函数或copy函数。 123456789a :&#x3D; []int&#123;1, 2, 3&#125;&#x2F;&#x2F;头部元素a &#x3D; append(a[:0], a[1:]...)a &#x3D; a[:copy(a, a[1:])]&#x2F;&#x2F;中间元素a &#x3D; append(a[:i], a[i+1:]...)a &#x3D; a[:i + copy(a[i], a[i+1:])] 切片高效操作的要点是降低内存分配的次数，尽量保证append函数操作不会超出cap的容量。 切片使用中，假如只使用了切片的一部分数据，应当拷贝到一个新的变量，避免切片底层数据的长期引用。 切片类型强制转换 通过切片底层结构reflect.SliceHeader来做指针的强制赋值。 12345678a :&#x3D; []float64&#123;&#125;c :&#x3D; []int&#123;&#125;aHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))cHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;c))*cHdr &#x3D; *aHdr","categories":[{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《Go语言高级编程》","slug":"《Go语言高级编程》","permalink":"https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"}]},{"title":"Mysql常用SQL命令集合","slug":"mysql-common-command","date":"2021-04-15T03:27:46.000Z","updated":"2021-04-15T06:22:49.391Z","comments":true,"path":"2021/04/15/mysql-common-command/","link":"","permalink":"https://www.chaguake.com/2021/04/15/mysql-common-command/","excerpt":"","text":"show engines命令用于查看当前Mysql使用的数据库存储引擎。 show variables命令用于查看当前Mysql的配置情况。 show status like ‘Table%’命令用于查看当前表使用状态，有两个关键的字段：Table_locks_immediate为表立即释放锁的次数，Table_locks_waited为表等待释放锁的次数。 show status like ‘innodb_row_lock%’命令用于查看行锁争夺情况。 lock table/unlock table命令MyISAM数据库引擎加锁（解锁）操作。 InnoDB Monitors可创建InnoDB Monitors来观察发生锁冲突的表、数据行等信息。 123CREATE TABLE innodb_monitor(a INT) ENGINE&#x3D;INNODB;Show innodb status \\G;DROP TABLE innodb_monitor; SELECT … LOCK IN SHARE MODE命令用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。 但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁。 SELECT … FOR UPDATE命令对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。 其他session可以查询，但是不能加共享锁。 InnoDB的行锁与表锁当使用索引来检索数据时，就会使用到行级锁，否则，将会使用表级锁。 比如，SELECT …WHERE … FOR UPDATE语句，如果where后面使用的是索引，那么这条语句就是行锁，否则是表锁。 而且，假如另一个session的SELECT …WHERE … FOR UPDATE语句通过另一个索引找到对应行，那还是会等待锁。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.chaguake.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.chaguake.com/tags/Mysql/"}]},{"title":"Sunday字符串匹配算法","slug":"Sunday-alg","date":"2021-04-15T00:45:40.000Z","updated":"2021-04-15T01:14:42.265Z","comments":true,"path":"2021/04/15/Sunday-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/15/Sunday-alg/","excerpt":"","text":"参考文献： 字符串匹配——Sunday算法 Sunday算法比BM算法更快，并且方便不少。与KMP算法一样，迭代方向和字符比较方向都是从左到右。但匹配失效时取未参与匹配的第一个字符来做位数移动的判断依据。 如果该字符没有在搜索字符串中出现则直接跳过，即移动位数 = 搜索字符串长度 + 1； 否则，其移动位数 = 搜索字符串长度 - 该字符最右出现的位置（以0开始） = 搜索字符串中该字符最右出现的位置到尾部的距离 + 1。（其实就是将搜索字符串最右出现的位置与该字符位置对齐） 下面举例说明： 1.匹配失效时，判断字符i是否在模式串中出现，没有则移动模式串到字符i后面。 2.匹配失效时，判断字符r是否在模式串中出现，有则将模式串中最右出现字符r的位置与字符r的位置对齐。 3.完成匹配。 可以看出，Sunday算法十分快速地实现了匹配。 代码： 12345678910111213141516171819202122232425262728293031323334353637int Sunday(const string&amp; T, const string&amp; P) &#123; int n &#x3D; T.length(); int m &#x3D; P.length(); int shift[MAXNUM]; &#x2F;&#x2F; 默认值，移动m+1位 for (size_t i &#x3D; 0; i &lt; MAXNUM; i++)&#123; shift[i] &#x3D; m + 1; &#125; &#x2F;&#x2F; 模式串P中每个字母出现的最后的下标 &#x2F;&#x2F; 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数 for (int i &#x3D; 0; i &lt; m; i++) &#123; shift[P[i]] &#x3D; m - i; &#125; &#x2F;&#x2F; 模式串开始位置在主串的哪里 int s &#x3D; 0; &#x2F;&#x2F; 模式串已经匹配到的位置 int j; while (s &lt;&#x3D; n - m) &#123; j &#x3D; 0; while (T[s + j] &#x3D;&#x3D; P[j]) &#123; j++; &#x2F;&#x2F; 匹配成功 if (j &gt;&#x3D; m) &#123; return s; &#125; &#125; &#x2F;&#x2F; 找到主串中当前跟模式串匹配的最末字符的下一个字符 &#x2F;&#x2F; 在模式串中出现最后的位置 &#x2F;&#x2F; 所需要从(模式串末尾+1)移动到该位置的步数 s +&#x3D; shift[T[s + m]]; &#125; return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"}]},{"title":"BM字符串匹配算法","slug":"Boyer-Moore-alg","date":"2021-04-14T05:44:16.000Z","updated":"2021-04-14T09:19:27.946Z","comments":true,"path":"2021/04/14/Boyer-Moore-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/14/Boyer-Moore-alg/","excerpt":"","text":"参考文献有: BM字符串匹配算法论文 Boyer-Moore algorithm BM（Boyer-Moore）算法比KMP算法高效不少。KMP算法只有一个匹配规则，而BM算法有两个匹配规则，更加优化了迭代索引，减少不必要的比较次数。 BM算法的主要思想是：源字符串迭代方向依旧是从左到右，源字符串与搜索字符串的比较方向是从左到右。遇到不匹配情况时，根据两个匹配规则，定位下一次源字符串与搜索字符串比较的位置。 匹配规则BM算法定义了两个匹配规则，在每一次调整搜索字符串位置时，移动位数由两个匹配规则判断返回值中的最大值决定。 坏字符规则（bad-character shift）。当源字符串中的某个字符与搜索字符串中的某个字符不匹配时，则源字符串中的那个字符称之为坏字符。 这时，搜索字符串向右移动的位数 = 已完成匹配字符集合（从右到左）的最后一个字符索引（从0开始） - 坏字符在搜索字符串中最右边出现的位置索引（从0开始）。 假如坏字符在搜索字符串中未出现，则移动位数值为-1。 坏字符规则下的两种判断情况： 当搜索字符串不包含坏字符时，直接将搜索字符串移动到坏字符索引+1的位置（符合上面的计算公式）。 当搜索字符串包含坏字符时，将搜索字符串中最右出现的位置与坏字符位置对齐。这就意味着可能出现搜索字符串位置回退的情况，不过没关系，最后计算的移动位数由两个匹配规则决定的。 好后缀规则（good-suffix shift）。当字符无法继续匹配时，称已完成匹配字符集合为好后缀， 搜索字符串向右移动的位数 = 搜索字符串最右的好后缀索引 - 搜索字符串倒数第二次出现的好后缀索引。 假如好后缀在搜索字符串中只出现一次，则移动位数值为-1。 好后缀规则下的三种判断情况： 搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配且没有其他前缀子字符串与好后缀的后缀子字符串适配时，直接将搜索字符串移动到好后缀后面的字符位置。 搜索字符串中除了已经匹配上好后缀的那一个子字符串，还存在其他子字符串与好后缀适配时，则将搜索字符串倒数第二个适配的子字符串与好后缀对齐。 搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配，但存在其他前缀子字符串与好后缀的后缀子字符串适配时，则将它们对齐。 实例下面以实例来进行详解，如何用代码实现BM算法。 现在有一个源字符串cbcccacacabccabc，和一个搜索字符串cabcca，想要得到源字符串是否包含搜索字符串，有则输出位置索引。 根据坏字符规则，需要创建一个字符位置映射表，用于记录坏字符在搜索字符串中最右边的位置。 12345678&#x2F;&#x2F;char_table大小要大于等于会出现的所有字符种类数&#x2F;&#x2F;int char_table[MAXNUM + 1];&#x2F;&#x2F;memset(char_table, -1, sizeof(char) *(MAXNUM + 1));void InitCharTable(const char *search, unsigned int len, int *char_table) &#123; for (int i &#x3D; 0; i &lt; len; i++) &#123; char_table[search[i]] &#x3D; i; &#125;&#125; 根据好后缀规则，需要创建前缀子字符串索引表和后缀子字符串索引表。 123456789101112131415161718void InitGoodSuffixTable(const char *search, int len, int *suffix, bool *prefix) &#123; for (int i &#x3D; 0; i &lt; len - 1; i++) &#123; &#x2F;&#x2F;范围从第一个字符到倒数第二个字符 int j &#x3D; i; int k &#x3D; 0; while (j &gt;&#x3D; 0 &amp;&amp; search[j] &#x3D;&#x3D; search[len - 1 - k]) &#123;&#x2F;&#x2F;通过j、k同时往前回朔找相同的字符 suffix[++k] &#x3D; --j + 1;&#x2F;&#x2F;在后缀子字符串的后一个字符标记偏移量，兼容a[0]的情况 &#125; if (j &#x3D;&#x3D; -1) &#123; prefix[k] &#x3D; true;&#x2F;&#x2F;前缀子字符串最多只有一个，在结束的字符上标记结束符号（设为true） &#125; &#125;&#125;&#x2F;*输出结果：suffix：[-1, 1, 0, -1, -1, -1]。prefix：[false, false, true, false, false, false]。*&#x2F; 移动位数的函数需要跟前缀子字符串索引表和后缀子字符串索引表的生成方式绑定使用。 123456789101112int MoveIndexByGS(int bcindex, int len, int *suffix, bool *prefix) &#123; int gslen &#x3D; len - 1 - bcindex; if (suffix[gslen] !&#x3D; -1) &#123; return bcindex - suffix[gslen] + 1; &#125; for (int r &#x3D; bcindex + 2; r &lt;&#x3D; len - 1; r++) &#123; if (prefix[len - r]) return r; &#125; return len;&#125; BM算法的实现逻辑函数： 123456789101112131415161718192021222324252627282930313233343536373839404142int BM(const char *str, int len,const char *search, int slen) &#123; &#x2F;&#x2F;bad char rule tables int char_table[MAXNUM + 1]; memset(char_table, -1, sizeof(char_table)); InitCharTable(search, slen, char_table); &#x2F;&#x2F;good suffix rule tables int suffix[MAXNUM + 1]; bool prefix[MAXNUM + 1]; memset(suffix, -1, sizeof(suffix)); memset(prefix, false, sizeof(prefix)); InitGoodSuffixTable(search, slen, suffix, prefix); int i &#x3D; 0; while (i &lt;&#x3D; len - slen) &#123; int j; for (j &#x3D; slen - 1; j &gt;&#x3D; 0; j--) &#123; &#x2F;&#x2F;fine bad char if (str[i + j] !&#x3D; search[j]) break; &#125; if (j &lt; 0) &#123; return i; &#125; &#x2F;&#x2F; find bad char position int x &#x3D; j - char_table[(int)str[i + j]]; &#x2F;&#x2F; find good suffix position int y &#x3D; 0; if (j &lt; slen - 1) &#123; y &#x3D; MoveIndexByGS(j, slen, suffix, prefix); &#125; &#x2F;&#x2F;get the max offset i &#x3D; i + max(x, y); &#125; return -1;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"}]},{"title":"KMP字符串匹配算法","slug":"knuth-morris-pratt-alg","date":"2021-04-12T06:07:04.000Z","updated":"2021-04-12T07:23:08.137Z","comments":true,"path":"2021/04/12/knuth-morris-pratt-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/12/knuth-morris-pratt-alg/","excerpt":"","text":"在日常工作中，我们经常需要在文本中搜寻某些特定的字符串，那作为使用者的你，有没有想过其算法的实现呢？ 举个例子，假如有一个源字符串“ablshvaabcadababcskilils”，如何判断其是否包含搜索字符串“abcadaba”？ 一般想到的做法是暴力遍历匹配方法：遍历源字符串，然后取出与搜索字符串相同长度的子字符串做比较，不匹配就将迭代索引+1，再取出与搜索字符串相同长度的子字符串做比较，直到迭代结束。时间复杂度为$O(m*n)$，取决于源字符串和搜索字符串的长度。 不难发现，在子字符串与搜索字符串做比较时，很大程度上，有部分操作是与上一次比较时重复的，那能否设计一种模式，减少这部分的重复工作呢？ KMP算法（Knuth-Morris-Pratt算法）KMP算法是通过添加部分匹配表（Partial Match Table）来减少重复搜索工作的算法，它其实是对暴力遍历匹配方法的优化算法，在搜索字符串没有部分匹配字符串的时候，会退化成暴力遍历匹配方法。 如上图，在匹配失败时，无须回退到上一迭代器+1的位置，而是从下一个部分匹配字符串的位置开始迭代。 部分匹配字符串和部分匹配表 首先，先理解“前缀子字符串”和“后缀子字符串”的概念。 前缀子字符串：把搜索字符串的最后一个字符去掉，所有包含搜索字符串第一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的前缀字符串是a、ab、abc、abca、abcad、abcada、abcadab。 后缀子字符串：把搜索字符串的第一个字符去掉，所有包含搜索字符串最后一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的后缀字符串是bcadaba、cadaba、adaba、daba、aba、ba、a。 把同时出现在所有前缀字符串和后缀字符串中的，包含搜索字符串第一个字符且连续的子字符串称为部分匹配字符串，所有部分匹配字符串的集合称为部分匹配表。如上面的搜索字符串“abcadaba”，它的部分匹配表的元素有：a、ab。 代码实现部分匹配表 我们需要记录部分匹配字符串第二次出现的位置。 创建一个与搜索字符串相同长度的整型数组，默认初始化值为0，用于存储在搜索字符串对应位置上，部分匹配字符串的长度。如上面的搜索字符串“abcadaba”，它的部分匹配表最终为：[0, 0, 0, 1, 0, 1, 2, 0]。 123456789101112131415void GetPartialMatch(const std::string &amp;strTarget, int *arr)&#123; int max_pre_size &#x3D; strTarget.length() - 1; for (size_t i &#x3D; 0; i &lt; max_pre_size; i++)&#123; std::string strTmp1 &#x3D; strTarget.substr(0, i + 1); for (size_t j &#x3D; 1; j &lt; max_pre_size; j++)&#123; std::string strTmp2 &#x3D; strTarget.substr(j, i + 1); if (strTmp1 &#x3D;&#x3D; strTmp2) &#123; arr[j + i] &#x3D; i + 1; &#125; &#125; &#125;&#125; KMP算法实现 1234567891011121314151617181920212223void KMP(const std::string &amp;strSrc, const std::string &amp;strTarget, const int *arr)&#123; int match_index &#x3D; 0; for (size_t i &#x3D; 0; i &lt; strSrc.length();)&#123; if (strSrc[i] &#x3D;&#x3D; strTarget[match_index]) &#123; if (match_index + 1 &#x3D;&#x3D; strTarget.length()) &#123; printf(&quot;match success,sub str index[%d].\\n&quot;, i - match_index); return; &#125; i++; match_index++; &#125; else &#123; if (match_index &gt; 0) &#123; match_index &#x3D; arr[match_index]; &#125; else &#123; i++; &#125; &#125; &#125; printf(&quot;match fail.\\n&quot;);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"}]},{"title":"C/C++如何获取不定数量的输入参数？","slug":"C-knowledge-cin","date":"2021-04-09T09:15:26.000Z","updated":"2021-04-09T09:22:45.559Z","comments":true,"path":"2021/04/09/C-knowledge-cin/","link":"","permalink":"https://www.chaguake.com/2021/04/09/C-knowledge-cin/","excerpt":"","text":"刷题时偶尔会出现输入不定数量的参数，主要是使用std::cin来实现。 使用Ctrl Z（Windows）或Ctrl D（UNIX）结束输入： 12345std::vector&lt;int&gt; vec;int value;while(std::cin&gt;&gt;value)&#123; vec.push_back(value);&#125; 使用回车结束输入： 123456789std::vector&lt;int&gt; vec;int value;while(std::cin&gt;&gt;value)&#123; vec.push_back(value); if(std::cin.get() &#x3D;&#x3D; &#39;\\n&#39;)&#123; break; &#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"}],"tags":[{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"}]},{"title":"TCP对接异常——Server端宕机","slug":"tcp-docking-problem-01","date":"2021-04-08T00:42:22.000Z","updated":"2021-04-09T08:51:45.652Z","comments":true,"path":"2021/04/08/tcp-docking-problem-01/","link":"","permalink":"https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/","excerpt":"","text":"背景介绍问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。 Server端使用boost的asio库，性能应该有保障的。 首先，查看日志，排查对应代码片段，未发现有出现”死锁“的逻辑，只能从wireshark抓包分析了。 现场同事把抓包发回一看，好家伙，一堆的”TCP ZeroWindow”和”RST“！ 问题排查1、统计一下http请求情况， 才三百多次http请求，远远没达到正常水平，排除Server端处理瓶颈问题。 2、输入筛选条件tcp.flags.syn，看看tcp三次握手情况。 Client新连接都直接被Server端拒绝了，Server端的连接数已经达到了极限。 而Server端在处理完http请求之后都会断开当前连接，并非长连接模式。并且，根据Server端的http处理耗时来看，还算正常。 问题估计在已建立但是未正常关闭的连接上，粗略看下，基本都会出现”TCP ZeroWindow“标记。 3、随机追踪一条出现”TCP ZeroWindow“的tcp连接， 统计了下，出现这情况的连接大概有两百条，那就有可能出现同时并发的连接数大于CPU数量*2+1的情况。 而且，100个tcp包就出现滑动窗口占满的情况是不可能的，问题肯定出现在这里了。 经过排查，终于发现问题所在： 如上图，Server端最后回复给Client端包中，Win的值为5632，表示Server端还能接收5632个包。 并且Ack值为126929，希望Client下一个包的Seq序号值从126929开始。果不其然，Client端紧接着的包中Seq序号值为126929。 看Server端回复“TCP ZeroWindow”包的前一个由Client端发出的包LAST，它的Seq值为131273。 不难看出，131273 - 126929 = 4344 &lt; 5632，这时还可以正常接收。 但是展开那个包LAST中的Next Seq值是132609，132609 - 126929 = 5680 &gt; 5632，已经超出Win大小，所以，Server端接收到包LAST之后就返回“TCP ZeroWindow”包。 解决办法1、Client端更改Seq的生成规则，使得Seq自增步长减少。 抓包中可以看出，Client端Seq的自增步长是1448。 2、Server端将滑动窗口变大。 由于Client端会发送PSH包通知Srever端清空缓冲，那么Server端可以将滑动窗口变大，避免出现“TCP ZeroWindow”情况。 3、优化Srever端“接收请求-&gt;回复请求”的耗时，避免同时出现异常连接并发数大于CPU数量*2+1的情况。 这种方法依旧是没办法解决问题所在的，只是尽量避免宕机情况出现。 4、Server端添加tcp连接的timeout处理。 Server端主动关闭超过timeout时间没有接收到http请求的连接。","categories":[{"name":"问题排查","slug":"问题排查","permalink":"https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"问题排查之TCP","slug":"问题排查之TCP","permalink":"https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"}]},{"title":"TCP的三次握手","slug":"tcp-three-way-handshake","date":"2021-04-07T02:13:50.000Z","updated":"2021-04-07T07:03:49.700Z","comments":true,"path":"2021/04/07/tcp-three-way-handshake/","link":"","permalink":"https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/","excerpt":"","text":"最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。 参考文献有： TCP三次握手、四次挥手出现意外情况时，为保证稳定，是如何处理的？ 面试官，不要再问我三次握手和四次挥手 三次握手正常流程三次是TCP建立连接的最小次数，因为在三次握手中，双方都经历了”请求-&gt;应答“的过程。 三次握手流程步骤： 在初始时，双端处于CLOSE状态，服务端(Server)为了提供服务，会主动监听某个端口，进入LISTEN状态。 客户端(Client)主动发送连接的SYN包，之后进入SYN-SENT状态，服务端在收到客户端发来的SYN包后，回复SYN,ACK包，之后进入SYN-RCVD状态。 客户端收到服务端发来的SYN,ACK包后，可以确认对方存在，此时回复ACK包，并进入ESTABLISHED状态。 服务端收到最后一个ACK包后，也进入ESTABLISHED状态。 三次握手重点是客户端和服务端的状态变化过程，比如：客户端在发送第三个ACK包的时候，状态就会变更成ESTABLISHED，而服务端需要在接收到客户端发出的第三个ACK包的时候，才将状态转换成ESTABLISHED。 三次握手异常情况计算机网络的异常处理有时比正常处理得流程更为重要，毕竟，需要花费更大的消耗去判断是网络故障还是连接异常。 1. SYN包丢失 对于服务端，客户端还是”不存在的“。 对于客户端，无法清楚服务端是否接收到SYN包，所以客户端会进行重传SYN包的操作，一般重传三次，三次加起来大约是76s（采用指数退避算法）。 在代码层次上，客户端会阻塞在connect函数上，失败会返回异常信息。 可通过更改系统配置（Linux点击这里、Windows点击这里）来实现配置重连次数和重连耗时。 也可以通过”ioctl(1)+select(timeout)“方式来间接实现连接超时控制。TCP/IP Connect时间自主设定 2. SYN+ACK包丢失 对于客户端，跟SYN包丢失的处理流程是一样的。 对于服务端，会触发重传操作，毕竟无法确定客户端是否收到SYN+ACK包，此时服务端的状态是SYN_RCVD。 当超过重传次数之后，服务端系统会发送RST包。 3. ACK包丢失 对于服务端，跟SYN+ACK包丢失的处理流程是一样的，处于SYN-RCVD状态。 对于客户端，connect函数已经正常返回，客户端已经进入ESTABLISHED状态，可以发送/接收数据了。 现在，服务端和客户端的状态不对等，那么客户端发给服务端的数据会怎么处理呢？ 结合文章来看，假如客户端发送的第一个数据包的Seq确认序号跟ACK包的Seq确认序号一样，那么，服务端将进入ESTABLISHED状态，正常连接。假如不一样，服务端会发送RST包，结束该连接。而在代码实现中，connect函数是在客户端回复ACK包之后就返回了，这时三次握手还没完成。 所以，可以在conenct函数返回之后，立即发送一个跟ACK包相同Seq确认序号的数据包（默认第一个数据包的Seq是跟ACK一样），哪怕服务端没有接收到ACK包，也可以正常进入ESTABLISHED状态。并且也可以验证连接是否成功，假如服务端返回RST包，则连接失败。 应用层上，使用select、poll或者epoll机制判断socket是否可写来确认连接是否已经建立。非阻塞socket 的连接","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://www.chaguake.com/tags/TCP/"}]},{"title":"Reservoir Sampling 抽样算法","slug":"reservoir-sampling-alg","date":"2021-04-04T16:20:31.000Z","updated":"2021-04-06T08:23:01.651Z","comments":true,"path":"2021/04/05/reservoir-sampling-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/","excerpt":"","text":"“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。 但是，当m不是确定值呢？ 可以使用Reservoir Sampling 抽样算法。 由于m是不确定的，那么使用[0,m]范围内随机产生数的方式就没办法使用。所以，需要设计一种方法，使得每个数被抽取的概率都是$\\frac{n}{m}$。 一、”每次都是 $\\frac{1}{i}$”问题对于n(n&gt;=1)，如果每次（基数k从0到n递增）以$\\frac{1}{i}$的概率决定是否替换选中元素直到n，那么最后每个元素被选中的概率相等，即为$\\frac{1}{n}。$ 证明： 假设最后被选中的元素a(a&lt;=n)，它是在第k(k&lt;=n)次被选中。也就是说在第k次之后都不会有元素被选中，这样子才能确保最后选中的元素是a。 那么它被选中的概率等于第k次被选中的概率*第k次以后都没有元素选中。 \\frac{1}{k} × \\frac{k}{k+1} × \\frac{k+1}{k+2} × ··· × \\frac{n-1}{n} = \\frac{1}{n}可以得到结论：在未知样本空间n中，随机抽取一个数a，它的概率是$\\frac{1}{n}$。 代码实现： 1234567void Sampling(std::vector&lt;int&gt; &amp;vec, int &amp;num)&#123; for (size_t i &#x3D; 1; i &lt; vec.size(); i++)&#123; int random &#x3D; rand() % i; num &#x3D; vec[random]; &#125;&#125; 二、如何从未知样本空间m随机抽取n个数假如按照第一点中的方法，抽取n个数。的确也是能实现$\\frac{n}{m}$的概率，但是要遍历n次，时间复杂度就顶不住了。 换个角度，假设，先取出前n个元素组成一个集合N，把第n+1个元素放进集合N，从集合N中抽取n个元素重新组成集合N，直至最后一个元素。 也就是说，第n+1个元素随机替换集合N中的一个元素。下面证明最后得出的集合N中，每个元素的概率是$\\frac{n}{m}$。 证明： 假设集合N中的任意一个元素a，它是第k(n&lt;=k&lt;=m)次被放进集合N，它最后留在集合N的概率 = 在它后面的元素都没有被抽中的概率 + 在它后面的元素被抽中的概率 * 没有替换元素a的概率。 根据第一点中的方法，第k(k&gt;=n)次某元素被选中并替换到集合N的概率是$\\frac{1}{k} × n = \\frac{n}{k}$。 \\frac{n}{k} × (\\frac{k+1-n}{k+1} + \\frac{n}{k+1} × \\frac{n-1}{n}) × (\\frac{k+2-n}{k+2} + \\frac{n}{k+2} × \\frac{n-1}{n}) × ··· × \\frac{m-n}{m} + \\frac{n}{m} × \\frac{n-1}{n} = \\frac{n}{k} × \\frac{k}{k+1} × \\frac{k+1}{k+2} × ··· × \\frac{m-1}{m} = \\frac{n}{m}证明成立，这个实现就是蓄水池抽样算法（Reservoir Sampling）。 代码实现： 123456789void ReservoirSampling(std::vector&lt;int&gt; &amp;vec,int n)&#123; for (size_t i &#x3D; n; i &lt; vec.size(); i++) &#123; int random &#x3D; rand() % i; if(random &lt; n)&#123; std::swap(vec[random], vec[i]); &#125; &#125;&#125; 分布式实现： 12345678910&#x2F;&#x2F;up-low&gt;nvoid ReservoirSampling(std::vector&lt;int&gt; &amp;vec, int n, int low, int up)&#123; for (size_t i &#x3D; low + n; i &lt; up; i++) &#123; int random &#x3D; rand() % (up - low) + low; if (random &lt; low + n) &#123; std::swap(vec[random], vec[i]); &#125; &#125;&#125; 可以看出，Reservoir Sampling 抽样算法的空间复杂度$O(1)$，时间复杂度$O(n)$。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"抽样算法","slug":"抽样算法","permalink":"https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"}]},{"title":"Fisher Yates 洗牌算法","slug":"fisher-yates-shuffle-alg","date":"2021-04-02T06:29:14.000Z","updated":"2021-04-06T08:20:16.075Z","comments":true,"path":"2021/04/02/fisher-yates-shuffle-alg/","link":"","permalink":"https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/","excerpt":"","text":"洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。 不加权模式Fisher Yates洗牌算法凭借着$O(1)$空间、$O(n)$时间复杂度，实现了“在n个不同的数中随机取出m个数”一类的问题。 实现大致是将从未抽取集合中随机抽中的数x与未抽取集合中的最后一个数交换，未抽取集合个数-1。不断重复，直至未抽取集合个数为0。 实现细节： 已知原始数组长度为n，将原始数组分为未抽取数组（长度为n）和取出数组（长度为0）。 在未抽取数组中，随机（算法依赖这个’随机‘是否够随机）选中一个数p，将数p的位置与原始数组最后一位（首位也行）交换。 重复上一个步骤，直到未抽取数组的个数为0。 有点像选择排序，差异在于每次在’未排序‘区中找的不是最小（或最大）的，而是随机选一个。 实现代码如下： 12345678void shuffle(int *arr,int nLen)&#123; for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123; int num &#x3D; rand() % i; std::swap(arr[i], arr[num]); &#125;&#125; 算法脱离数学是不讲武德的，下面就证明：集合set有n个不同的数字，第i次抽取到的数字p的概率是否是都是$\\frac{1}{n}$ 。 第i次才抽中数字p，那么前i-1次都是没抽到数字p的。 第一次抽取，没抽到数字p的概率是$\\frac{n-1}{n}$。 第二次抽取，没抽到数字p的概率是$\\frac{n-1}{n} × \\frac{n-2}{n-1}$。 …… 第i-1次抽取，没抽到数字p的概率是$\\frac{n-1}{n} × \\frac{n-2}{n-1} × ··· × \\frac{n-i}{n-i+1}$。 第i次抽取，抽到数字p的概率是$\\frac{n-1}{n} × \\frac{n-2}{n-1} × ··· × \\frac{n-i}{n-i+1} × \\frac{1}{n-i} = \\frac{1}{n}$。 Fisher Yates洗牌算法有两个随机因子，一个是每一次从未抽取集合抽取的元素，另一个是每一次未抽取集合最后一个元素，但最关键是第一个随机因子。 假如为每个元素加上权重，使得每个元素本身被抽中的优先度不一样，又如何用Fisher Yates洗牌算法来实现呢？ 加权模式一个比较笨重的办法,将元素按照其权重展开: 12&#123;a:2,b:3,c:1&#125;&#123;a,a,b,b,b,c&#125; （但显然不是好办法。=_=） 因为有了权重作为附加条件，再按照上面”从未抽取集合中随机抽取一个元素“的方式是不满足条件的，必须将权重参与到运算中（随机抽取）。 那么，可以将所有权重值加起来，得到一个权重总数sum，然后在0到sum的范围内随机产生一个数num，再将num与未抽取集合中每一个元素作某种比较，最后输出随机数。 步骤如下： 统计出所有元素的权重和sum。 在0到sum之间随机产生一个随机数num，遍历未抽取集合。 用随机数num和当前迭代元素n比较。假如num小于n，结束迭代，返回元素n（与最后一位元素交换），sum-=n，重复第二步；假如num大于n，则num-=n，继续迭代。 遍历到未抽取集合的最后一个元素时，如果num大于n，则输出最后一个元素，sum-=n。 重复第二步。 代码如下： 12345678910111213141516171819202122void shuffle2(int *arr, int nLen)&#123; int sum &#x3D; 0; for (size_t i &#x3D; 0; i &lt; nLen; i++)&#123; sum +&#x3D; arr[i]; &#125; for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123; int num &#x3D; rand() % sum; size_t j &#x3D; 0; for (; j &lt; i; j++)&#123; if (num &gt; arr[j]) &#123; num -&#x3D; arr[j]; &#125; else &#123; break; &#125; &#125; sum -&#x3D; arr[j]; std::swap(arr[i], arr[j]); &#125;&#125; 空间复杂度还是$O(1)$，但时间复杂度是$O(n+n^2)$。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"洗牌算法","slug":"洗牌算法","permalink":"https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"}]},{"title":"面试知识点——C/C++基础知识","slug":"interview-knowledge-C-base","date":"2021-04-02T01:52:14.000Z","updated":"2021-04-06T09:02:17.326Z","comments":true,"path":"2021/04/02/interview-knowledge-C-base/","link":"","permalink":"https://www.chaguake.com/2021/04/02/interview-knowledge-C-base/","excerpt":"","text":"一、extern关键字的使用1、外部变量声明，使得全局变量可跨文件使用。 不同.cpp文件在编译时是独立的，需要添加extern关键字声明该变量是在外部（其他.cpp文件）定义。 2、函数声明。 可以使用extern void fun();来代替引用#include *.h的方式，去声明外部函数。 这里有个问题，网络上说单方面修改extern函数原型时编译器不会报错，但博主在VS2008和VS2017上是会报错的（编译成功，链接失败）。 3、链接规范（extern “C”）。 链接规范的用法： 1234567extern &quot;C&quot; void fun();extern &quot;C&quot;&#123; void fun1(); void fun2();&#125; C++由于支持函数重载，在C++编译器工作时，会生成一个用于链接的中间函数名。 而C不支持函数重载，所以在C编译器工作时，生成的中间函数名只是简单的在函数名前加上一个下划线_。 在C++使用C函数时，会将C函数生成一个C++规则的中间函数名。这样子，在进行链接时，C编译生成的目标文件和C++编译生成的目标文件中的中间函数名就会不一样，导致链接失败。 所以，C++调用C的函数时，需要添加extern “C”来声明，按照C的规则编译C的函数。 而C调用C++的函数，除了使用extern “C”之外，还需要做一层包装函数（添加extern “C”为了生成C风格的中间函数名，添加包装函数为了支持重载）。 值得注意的是，不应该把头文件放在extern “C”的范围里，因为有可能会导致符号嵌套。 二、placement new当需要在一块已分配的内存上创建对象时，需要使用placement new。 1A *ptr &#x3D; new(buff) A; 使用强制转换的办法也可以在已分配的内存上创建对象，但是不会调用对象的构造函数，而且，有可能会有内存溢出的问题。 1A *ptr &#x3D; (A*)buff; 三、stdcall、cdecl和__fastcall三种函数调用协议参见参数传递和命名约定和C++知识回顾之stdcall、cdcel和__fastcall三者的区别 1、协议常用场合 __stdcall：Windows API默认的函数调用协议。 __cdecl：C/C++默认的函数调用协议。 __fastcall：适用于对性能要求高的场合（只适用于X86架构，在ARM和X64体系架构的编译器会直接忽略该关键字）。 2、函数入栈方式 __stdcall：函数参数由右向左入栈。 __cdecl：函数参数由右向左入栈。 __fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。 3、栈内数据清除方式 __stdcall：函数调用结束后由被调用函数清除栈内数据。 __cdecl：函数调用结束后由函数调用者清除栈内数据。 __fastcall：函数调用结束后由被调用函数清除栈内数据。 注： 1)不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。 2)某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。 3)由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。 4、C编译器函数名称修饰规则 __stdcall：编译后，函数名被修饰为“_functionname@number”（number为参数字节数）。 __cdecl：编译后，函数名被修饰为“_functionname”。 __fastcall：编译后，函数名给修饰为“@functionname@nmuber”（number为参数字节数）。 C++编译器函数名称修饰规则 __stdcall：编译后，函数名被修饰为“?functionname@@YG**@Z”。 __cdscl：编译后，函数名被修饰为“?functionname@@YA**@Z”。 __fastcall：编译后，函数名被修饰为“?functionname@@YI**@Z”。","categories":[{"name":"面试","slug":"面试","permalink":"https://www.chaguake.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"}]},{"title":"OpenGL入门（三）——生成三角形小结笔记","slug":"OpenGL-introduction-03","date":"2021-03-31T10:50:43.000Z","updated":"2021-04-02T01:39:54.200Z","comments":true,"path":"2021/03/31/OpenGL-introduction-03/","link":"","permalink":"https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/","excerpt":"","text":"英文原文地址 中文翻译地址 总结小结主要介绍了各类着色器的使用，特别是可编程的顶点着色器和片段着色器。 一、图形渲染管线图形渲染管线（简称管线）主要作用是将一堆物体的3D坐标转换成2D坐标输出，最后呈现在屏幕上。 管线接受一组3D坐标，然后通过几个串行的阶段处理（在GPU上并行处理），最终输出屏幕画面。 如上图。每一个阶段称为着色器，其中。标有蓝色的着色器有顶点着色器、几何着色器和片段着色器。它们允许我们自定义编写着色器处理逻辑。 二、各类着色器介绍OpenGL着色器语言 有些着色器允许自己设计，可以用OpenGL着色器语言（GLSL）编写。 顶点着色器 顶点着色器将用户输入的3D坐标转换成GLSL中的3D坐标，并且可以对顶点3D坐标做一些处理。 1234567#version 330 corelayout (location &#x3D; 0) in vec3 aPos;void main()&#123; gl_Position &#x3D; vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125; 在GLSL中，3D坐标是一个有4个分量的向量，x、y、z、w，最后一个用于透视除法上。 图元着色器 图元着色器将顶点着色器的顶点输出作为输入，然后将所有的顶点装配成指定图元的形状。 1glDrawArrays(GL_TRIANGLES, 0, 3); 几何着色器 几何着色器可以将图元着色器输出的顶点构造出其它的图元形状。 光栅化 光栅化将图元映射成屏幕上的像素形状，即片段。 片段着色器 片段着色器计算每一个像素的颜色，它需要接收场景的数据（例如：光照、阴影等），综合计算出像素点的颜色。 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125; 片段着色器只有一个颜色输出变量。 测试和混合 当每个片段的颜色都确定之后，还需要检查每个片段之间的层级关系和透明度叠加之后的显示颜色。 三、编译着色器着色器代码需要在运行时动态编译，代码以字符串形式传递给OpenGL。 首先，得创建着色器对象： 12unsigned int vertexShader;vertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER); glCreateShader函数需要输入当前需要创建的着色器类型，GL_FRAGMENT_SHADER是片段着色器，GL_VERTEX_SHADER是顶点着色器。 下一步，需要将着色器源码附加到着色器对象上，并且编译它： 12glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader); glShaderSource函数的第一个参数是着色器对象，第二个参数是着色器源码数量，第三个参数是着色器源码字符串数组首地址，第四个参数是着色器源码字符串长度数组首地址。 可以对着色器源码编译的结果检测： 12345678int success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if(!success)&#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;&#125; 四、着色器程序对象着色器编译出来之后，需要将他们链接到同一个着色器程序对象上。 同样的，需要创建着色器程序对象： 12unsigned int shaderProgram;shaderProgram &#x3D; glCreateProgram(); 下一步，把各个着色器附加到着色器程序对象上，然后进行链接： 123glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram); 同样，也可以捕捉链接失败信息： 12345glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ...&#125; 着色器对象链接到着色器程序对象之后，着色器对象就可以删除了： 12glDeleteShader(vertexShader);glDeleteShader(fragmentShader); 当需要使用着色器程序时，调用： 1glUseProgram(shaderProgram); 删除着色器程序，调用： 1glDeleteProgram(shaderProgram); 五、顶点缓冲对象（Vertex Buffer Object，VBO）顶点数据从内存发送到GPU是一件耗时费力的事情，所以尽可能一次性发送更多的数据到显卡上。 定点缓冲对象可包含顶点的多种属性： 1234567float vertices[] &#x3D; &#123; &#x2F;&#x2F; positions &#x2F;&#x2F; colors &#x2F;&#x2F; texture coords 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, &#x2F;&#x2F; top right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, &#x2F;&#x2F; bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, &#x2F;&#x2F; bottom left -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f &#x2F;&#x2F; top left &#125;; 创建VBO： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); 绑定数据，但在此之前需要声明接下来绑定的数据是哪种类型的，应该把它绑定到哪种缓冲对象上： 因为要做顶点缓冲类型的数据绑定，所以用GL_ARRAY_BUFFER。 12glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData函数第一个参数是目标缓冲类型，第二个参数是需绑定数据的大小，第三个参数是需绑定数据地址，第四个参数指定显卡如何管理当前绑定的数据。 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW ：数据会改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 根据值不同，需绑定数据会放在显卡不同的位置。 摧毁VBO对象： 1glDeleteBuffers(1, &amp;VBO); 六、索引缓冲对象（Element Buffer Object，EBO或Index Buffer Object，IBO）万物皆三角形。三角形可以说是3D图形最小的组成元素，毕竟三角形的三个顶点肯定在同一个平面上。 在绘制矩阵图形时，可以将矩阵分成两个三角形来绘制。但这样子，就会出现共同顶点，在VBO上则是重复存储，浪费开销。 12345678910float vertices[] &#x3D; &#123; &#x2F;&#x2F; 第一个三角形 0.5f, 0.5f, 0.0f, &#x2F;&#x2F; 右上角 0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 右下角 -0.5f, 0.5f, 0.0f, &#x2F;&#x2F; 左上角 &#x2F;&#x2F; 第二个三角形 0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 右下角 -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角 -0.5f, 0.5f, 0.0f &#x2F;&#x2F; 左上角&#125;; 索引缓冲对象可以使得VBO不用存储每个顶点重复的数据，然后通过固定索引来描绘出每个三角形。 1234567891011float vertices[] &#x3D; &#123; 0.5f, 0.5f, 0.0f, &#x2F;&#x2F; 右上角 0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 右下角 -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角 -0.5f, 0.5f, 0.0f &#x2F;&#x2F; 左上角&#125;;unsigned int indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! 0, 1, 3, &#x2F;&#x2F; 第一个三角形 1, 2, 3 &#x2F;&#x2F; 第二个三角形&#125;; 创建索引缓冲对象： 12unsigned int EBO;glGenBuffers(1, &amp;EBO); 绑定数据（跟VBO类似）到VAO： 12glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 一般的，在绘制时使用glDrawArrays函数： 12&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是顶点坐标指针的起始索引，第三个参数是绘制顶点数量glDrawArrays(GL_TRIANGLES, 0, 3); 使用索引绘制时需要用到glDrawElements函数： 12&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是绘制顶点数量，第三个参数是索引的类型，第四个是EBO数组地址的偏移量glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 摧毁EBO对象： 1glDeleteBuffers(1, &amp;EBO); 七、顶点数组对象（Vertex Array Object，VAO）顶点数组对象封装了顶点所有属性数据（例如：坐标，颜色，纹理等），记录了顶点缓冲对像（VBO）和索引缓冲对象（EBO）的指针地址。 在配置顶点属性之后，VAO记录了配置的状态，在需要的时候绑定不同的VAO实现： glEnableVertexAttribArray函数和glDisableVertexAttribArray函数分别启用/禁用某个顶点属性，默认是禁用。 glVertexAttribPointer函数用于设置顶点属性配置和关联的顶点缓冲对象。一般顶点属性会放在同一个VBO或EBO中，增加复用性。 创建VAO： 12unsigned int VAO;glGenVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时创建多个VAO 使用VAO，需要先进行绑定： 1glBindVertexArray(VAO); 设置VBO、EBO： 12345glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 接下来，就可以设置VAO的顶点属性。 12glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); glVertexAttribPointer函数参数定义： 第一个参数是配置的顶点属性。在顶点着色器源码中使用layout(location = 0)来设置位置值位0，所以这里要传入对应的值。 第二个参数是顶点属性的大小。 第三个参数是数据的类型。 第四个参数是是否将数据标准化。如果设置为GL_TRUE，那么数据就会被映射在0到1之间。 第五个参数是步长。表示顶点属性之间的间隔。 第六个参数是当前使用的数据在缓冲数组中的偏移量（Offset）。 解绑VAO： 1glBindVertexArray(NULL); 摧毁VAO： 1glDeleteVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时删除多个VAO 八、线框模式与填充模式 如果只想获取图元的形状，而不用填充颜色，可以使用线框模式： 1glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) 填充模式（默认模式）则用： 1glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（二）——Hello Window小节笔记","slug":"OpenGL-introduction-02","date":"2021-03-31T06:59:55.000Z","updated":"2021-03-31T10:53:13.460Z","comments":true,"path":"2021/03/31/OpenGL-introduction-02/","link":"","permalink":"https://www.chaguake.com/2021/03/31/OpenGL-introduction-02/","excerpt":"","text":"英文原文地址 中文翻译地址 整个小节看这一份完整的源码就可以了。这里。 总结初始化GLFW。 1glfwInit(); 调用glfwWindowHint函数配置GLFW。 123glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 调用glfwCreateWindow函数创建窗口对象， 1GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL); 把窗口的上下文设置为当前线程的上下文。 1glfwMakeContextCurrent(window); 传递OpenGL函数指针给GLAD。 12345if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123; std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1;&#125; 传递窗口大小给OpenGL，由于窗口大小会变化，所以通过注册函数来实现动态更新。 12345void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; glViewport(0, 0, width, height);&#125;glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); 循环渲染，直到窗口退出。 1234567891011121314151617void processInput(GLFWwindow *window)&#123; if(glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;while(!glfwWindowShouldClose(window))&#123; processInput(window);&#x2F;&#x2F;捕捉用户输入。 &#x2F;&#x2F;渲染指令 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window);&#x2F;&#x2F;交换颜色缓冲。 glfwPollEvents();&#x2F;&#x2F;检测事件。&#125; 退出时释放资源。 1glfwTerminate();","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"OpenGL入门（一）——GLFW库与GLAD库","slug":"OpenGL-introduction-01","date":"2021-03-31T06:22:54.000Z","updated":"2021-03-31T10:53:27.400Z","comments":true,"path":"2021/03/31/OpenGL-introduction-01/","link":"","permalink":"https://www.chaguake.com/2021/03/31/OpenGL-introduction-01/","excerpt":"","text":"OpenGL入门系列是博主学习LearnOpenGL教程的笔录。 LearnOpenGL中文翻译版教程地址：https://learnopengl-cn.github.io/ LearnOpenGL英文原作者版地址：https://learnopengl.com/ GLFW GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。 官网：https://www.glfw.org/ GLFW提供了简单的API，方便开发者创建windows、contexts、surfaces、input和events等一系列操作。 官网一般提供了现成的二进制文件库和头文件，将它引用到项目中使用。 GLAD由于OpenGL的接口函数地址一般是未知的，需要在运行期间动态获取。如下： 1234567&#x2F;&#x2F; 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);&#x2F;&#x2F; 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers &#x3D; (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);&#x2F;&#x2F; 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer); GLAD提供了一个在线服务，通过一些自定义配置，生成一个文件库，把它引用到项目中使用。 值得注意的是，在引用GLFW的头文件之前要先引用GLAD的头文件，因为GLAD包含了OpenGL的头文件。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"}],"tags":[{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"}]},{"title":"lua 基础知识","slug":"lua-base-knowledge","date":"2021-03-24T11:35:05.000Z","updated":"2021-03-31T01:50:42.780Z","comments":true,"path":"2021/03/24/lua-base-knowledge/","link":"","permalink":"https://www.chaguake.com/2021/03/24/lua-base-knowledge/","excerpt":"","text":"注释单行注释 两个连续减号。 1--我是注释 多行注释 结构类似多行字符串。 1234--[[第一行注释第二行注释]]-- 数据类型lua的变量不需要声明数据类型，并且变量的数据类型是不确定的，前一秒可以赋值数值，下一秒可以赋值字符串。 数据类型 描述 nil 只有值nil属于该类型，表示一个无效值 boolean 包含两个值：true和false number 表示双精度类型的实浮点数 string 由单引号或者双引号表示的字符串 function 由C或Lua编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 作用域变量的作用域默认是全局的，哪怕是在函数里定义的。 想要删除一个变量，把它赋值为nil。 局部变量需要在变量前加上local关键字。 迭代器lua的迭代器函数有两个：pairs和ipairs。前者遇到nil不会结束迭代，而是将nil过滤；后者遇到nil会结束迭代，直接返回。 12345678910111213141516171819202122232425array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;, nil, &quot;!&quot;&#125;for key,value in ipairs(array)do print(key, value)end&#x2F;*HelloWorld*&#x2F;array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;, nil, &quot;!&quot;&#125;for key,value in pairs(array)do print(key, value)end&#x2F;*HelloWorld!*&#x2F; 迭代器函数每次调用会返回下一组元素，根据返回的元素组是否包含迭代状态的元素来区分是无状态的迭代器还是多状态的迭代器。 无状态的迭代器 它返回每次迭代的状态元素，并且接受上一次迭代元素，例如ipairs。 123456789101112131415161718function iter (a, i) i &#x3D; i + 1 local v &#x3D; a[i] if v then return i, v endend function ipairs (a) return iter, a, 0endt &#x3D; &#123;1,2,3,4,5&#125;for k,v in ipairs(t)do print(k ,v)end 多状态的迭代器 如果迭代器需要维护不止一个状态元素，那可以使用闭包来实现将状态信息存放。 1234567891011121314151617181920array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;&#125;function elementIterator (collection) local index &#x3D; 0 local count &#x3D; #collection -- 闭包函数 return function () index &#x3D; index + 1 if index &lt;&#x3D; count then -- 返回迭代器的当前元素 return collection[index] end endendfor element in elementIterator(array)do print(element)end 模块与包从Lua5.1开始，Lua加入了标准的模块管理机制。 自定义模块module.lua代码： 123456789101112131415161718192021-- 文件名为 module.lua-- 定义一个名为 module 的模块module &#x3D; &#123;&#125; -- 定义一个常量module.constant &#x3D; &quot;这是一个常量&quot; -- 定义一个函数function module.func1() io.write(&quot;这是一个公有函数！\\n&quot;)end local function func2() print(&quot;这是一个私有函数！&quot;)end function module.func3() func2()end return module 加载模块示例： 1234567-- test_module.lua 文件-- module 模块为上文提到到 module.luarequire(&quot;module&quot;) print(module.constant) module.func3() 模块别名： 12345678-- test_module2.lua 文件-- module 模块为上文提到到 module.lua-- 别名变量 mlocal m &#x3D; require(&quot;module&quot;) print(m.constant) m.func3() C包 Lua可以引用C的库. 1234local path &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lua&#x2F;lib&#x2F;libluasocket.so&quot;-- 或者 path &#x3D; &quot;C:\\\\windows\\\\luasocket.dll&quot;，这是 Window 平台下local f &#x3D; assert(loadlib(path, &quot;luaopen_socket&quot;))f() -- 真正打开库 元表元表提供了对table的扩展操作，通过元方法，可以对table做对应的关联行为。 12setmetatable(table,metatable)getmetatable(table) __index元方法 提供了当使用在table中不存在的键访问table时的控制操作。 1234567891011121314mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __index &#x3D; function(mytable, key) if key &#x3D;&#x3D; &quot;key2&quot; then return &quot;metatablevalue&quot; else return nil end end&#125;)print(mytable.key1,mytable.key2)&#x2F;*value1 metatablevalue*&#x2F; 上面代码也可以写成： 12mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __index &#x3D; &#123; key2 &#x3D; &quot;metatablevalue&quot; &#125; &#125;)print(mytable.key1,mytable.key2) __newindex元方法 当给table做一个不存在的键赋值时，就会触发__newindex元方法。 12345678910111213141516mymetatable &#x3D; &#123;&#125;mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __newindex &#x3D; mymetatable &#125;)print(mytable.key1)mytable.newkey &#x3D; &quot;新值2&quot;print(mytable.newkey,mymetatable.newkey)mytable.key1 &#x3D; &quot;新值1&quot;print(mytable.key1,mymetatable.key1)&#x2F;*value1nil 新值2新值1 nil*&#x2F; 操作符元方法 12345678910111213141516171819202122232425262728293031323334353637-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数function table_maxn(t) local mn &#x3D; 0 for k, v in pairs(t) do if mn &lt; k then mn &#x3D; k end end return mnend-- 两表相加操作mytable &#x3D; setmetatable(&#123; 1, 2, 3 &#125;, &#123; __add &#x3D; function(mytable, newtable) for i &#x3D; 1, table_maxn(newtable) do table.insert(mytable, table_maxn(mytable)+1,newtable[i]) end return mytable end&#125;)secondtable &#x3D; &#123;4,5,6&#125;mytable &#x3D; mytable + secondtable for k,v in ipairs(mytable) doprint(k,v)end&#x2F;*1 12 23 34 45 56 6*&#x2F; 操作符元方法 描述 __add 加 __sub 减 __mul 乘 __div 商 ‘/’ __mod 余数 ‘%’ __unm 负数 ‘-’ __concat 连接符号 ‘..’ __eq 判断相等 ‘==’ __lt 小于 ‘&lt;’ __le 小于等于 ‘&lt;=’ __call元方法 提供元组一个调用函数的方法。 12345678910111213141516171819202122232425262728293031-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数function table_maxn(t) local mn &#x3D; 0 for k, v in pairs(t) do if mn &lt; k then mn &#x3D; k end end return mnend-- 定义元方法__callmytable &#x3D; setmetatable(&#123;10&#125;, &#123; __call &#x3D; function(mytable, newtable) sum &#x3D; 0 for i &#x3D; 1, table_maxn(mytable) do sum &#x3D; sum + mytable[i] end for i &#x3D; 1, table_maxn(newtable) do sum &#x3D; sum + newtable[i] end return sum end&#125;)newtable &#x3D; &#123;10,20,30&#125;print(mytable(newtable))&#x2F;*70*&#x2F; __tostring元方法 提供table格式化输出的方法。 12345678910mytable &#x3D; setmetatable(&#123; 10, 20, 30 &#125;, &#123; __tostring &#x3D; function(mytable) sum &#x3D; 0 for k, v in pairs(mytable) do sum &#x3D; sum + v end return &quot;表所有元素的和为 &quot; .. sum end&#125;)print(mytable)","categories":[{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/categories/lua/"}],"tags":[{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/tags/lua/"}]},{"title":"c++ 时间与日期相关函数的使用","slug":"c-usage-of-time-and-date","date":"2021-03-23T03:21:14.000Z","updated":"2021-03-23T09:41:02.578Z","comments":true,"path":"2021/03/23/c-usage-of-time-and-date/","link":"","permalink":"https://www.chaguake.com/2021/03/23/c-usage-of-time-and-date/","excerpt":"","text":"基础类型介绍C/C++中，跟时间与日期相关的数据类型有clock_t、time_t和tm，它们的定义如下： 12345678910111213141516171819202122232425262728#include&lt;time.h&gt; &#x2F;&#x2F;for c#include&lt;ctime&gt; &#x2F;&#x2F;for c++typedef long clock_t;typedef long __time32_t;typedef __int64 __time64_t;#ifndef _CRT_NO_TIME_T #ifdef _USE_32BIT_TIME_T typedef __time32_t time_t; #else typedef __time64_t time_t; #endif#endifstruct tm&#123; int tm_sec; &#x2F;&#x2F; seconds after the minute - [0, 60] including leap second int tm_min; &#x2F;&#x2F; minutes after the hour - [0, 59] int tm_hour; &#x2F;&#x2F; hours since midnight - [0, 23] int tm_mday; &#x2F;&#x2F; day of the month - [1, 31] int tm_mon; &#x2F;&#x2F; months since January - [0, 11] int tm_year; &#x2F;&#x2F; years since 1900 int tm_wday; &#x2F;&#x2F; days since Sunday - [0, 6] int tm_yday; &#x2F;&#x2F; days since January 1 - [0, 365] int tm_isdst; &#x2F;&#x2F; daylight savings time flag&#125;; 常用函数介绍一、time函数函数定义 获取从1970-01-01 00:00:00到现在经过的秒数。 1234567time_t time(time_t *seconds);&#x2F;*params:- seconds: 假如seconds非NULL，该函数会将返回值填充到这里。return: 返回从 1970-01-01 00:00:00到现在经过的秒数。*&#x2F; 实例 123456789101112#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t seconds; seconds &#x3D; time(NULL); printf(&quot;自 1970-01-01 起的小时数 &#x3D; %ld\\n&quot;, seconds&#x2F;3600); return(0);&#125; 二、ctime函数函数定义 获取指定时间点的时间格式化字符串。 1234567char* ctime(const time_t *timer);&#x2F;*params:- timer: 需要输出时间格式化字符串的时间点。return: 返回指定时间点的时间格式化字符串。格式如：Mon Aug 13 08:23:14 2021*&#x2F; 实例 12345678910111213#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t curtime; time(&amp;curtime); printf(&quot;当前时间 &#x3D; %s&quot;, ctime(&amp;curtime)); return(0);&#125; 三、localtime函数函数定义 将time_t的时间类型转换成tm结构体的时间类型。 返回的时间为本地时间，即默认加上了电脑上配置的时区偏移小时差。 1struct tm *localtime(const time_t *timer); 实例 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t rawtime; struct tm *info; char buffer[80]; time( &amp;rawtime ); info &#x3D; localtime( &amp;rawtime ); printf(&quot;当前的本地时间和日期：%s&quot;, asctime(info)); return(0);&#125; 四、clock函数函数定义 获取从程序执行起，处理器时钟所使用的时间。 假如需要获取CPU所使用的秒数，需要除以CLOCKS_PER_SEC。 123456clock_t clock(void);&#x2F;*return:返回自程序启动起，处理器时钟所使用的时间。如果失败，则返回 -1 值。*&#x2F; 示例 12345678910111213141516171819202122232425#include &lt;time.h&gt;#include &lt;stdio.h&gt; int main()&#123; clock_t start_t, end_t; double total_t; int i; start_t &#x3D; clock(); printf(&quot;程序启动，start_t &#x3D; %ld\\n&quot;, start_t); printf(&quot;开始一个大循环，start_t &#x3D; %ld\\n&quot;, start_t); for(i&#x3D;0; i&lt; 10000000; i++) &#123; &#125; end_t &#x3D; clock(); printf(&quot;大循环结束，end_t &#x3D; %ld\\n&quot;, end_t); total_t &#x3D; (double)(end_t - start_t) &#x2F; CLOCKS_PER_SEC; printf(&quot;CPU 占用的总时间：%f\\n&quot;, total_t ); printf(&quot;程序退出...\\n&quot;); return(0);&#125; 五、asctime函数函数定义 输出结构体tm时间的格式化字符串。 1234567char *asctime(const struct tm *timeptr);&#x2F;*return:输出结构体&#96;tm&#96;时间的格式化字符串。格式如：Sat Mar 25 06:10:10 1989*&#x2F; 示例 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;int main()&#123; struct tm t; t.tm_sec &#x3D; 10; t.tm_min &#x3D; 10; t.tm_hour &#x3D; 6; t.tm_mday &#x3D; 25; t.tm_mon &#x3D; 2; t.tm_year &#x3D; 89; t.tm_wday &#x3D; 6; puts(asctime(&amp;t)); return(0);&#125; 六、gmtime函数函数定义 将time_t的时间类型转换成tm结构体的时间类型。 返回的时间为格林尼治标准时间，不会自动加上电脑上配置的时区偏移小时差。 1struct tm *gmtime(const time_t *timer); 示例 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;time.h&gt; #define BST (+1)#define CCT (+8) int main ()&#123; time_t rawtime; struct tm *info; time(&amp;rawtime); &#x2F;* 获取 GMT 时间 *&#x2F; info &#x3D; gmtime(&amp;rawtime ); printf(&quot;当前的世界时钟：\\n&quot;); printf(&quot;伦敦：%2d:%02d\\n&quot;, (info-&gt;tm_hour+BST)%24, info-&gt;tm_min); printf(&quot;中国：%2d:%02d\\n&quot;, (info-&gt;tm_hour+CCT)%24, info-&gt;tm_min); return(0);&#125; 七、mktime函数函数定义 输出由结构体tm的时间变量转换成time_t类型的本地时间戳。 1time_t mktime(struct tm *timeptr) 示例 123456789101112131415161718192021222324252627282930&#x2F;* 输入日期判断是周几 *&#x2F;#include &lt;stdio.h&gt; &#x2F;* printf, scanf *&#x2F;#include &lt;time.h&gt; &#x2F;* time_t, struct tm, time, mktime *&#x2F; int main ()&#123; time_t rawtime; struct tm * timeinfo; int year, month ,day; const char * weekday[] &#x3D; &#123; &quot;周日&quot;, &quot;周一&quot;,&quot;周二&quot;, &quot;周三&quot;,&quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot;&#125;; &#x2F;* 用户输入日期 *&#x2F; printf (&quot;年: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;year); printf (&quot;月: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;month); printf (&quot;日: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;day); &#x2F;* 获取当前时间信息，并修改用户输入的输入信息 *&#x2F; time ( &amp;rawtime ); timeinfo &#x3D; localtime ( &amp;rawtime ); timeinfo-&gt;tm_year &#x3D; year - 1900; timeinfo-&gt;tm_mon &#x3D; month - 1; timeinfo-&gt;tm_mday &#x3D; day; &#x2F;* 调用 mktime: timeinfo-&gt;tm_wday *&#x2F; mktime ( timeinfo ); printf (&quot;那一天是：%s\\n&quot;, weekday[timeinfo-&gt;tm_wday]); return 0;&#125; 八、difftime函数函数定义 输出两个time_t类型的时间变量之间的秒数差。 1double difftime(time_t time1, time_t time2) 示例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;time.h&gt;#ifdef _WIN32#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#endif int main ()&#123; time_t start_t, end_t; double diff_t; printf(&quot;程序启动...\\n&quot;); time(&amp;start_t); printf(&quot;休眠 5 秒...\\n&quot;); sleep(5); time(&amp;end_t); diff_t &#x3D; difftime(end_t, start_t); printf(&quot;执行时间 &#x3D; %f\\n&quot;, diff_t); printf(&quot;程序退出...\\n&quot;); return(0);&#125; 九、strftime函数函数定义 输出结构体tm类型的变量的时间格式化字符串。 123456789101112size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr);&#x2F;*params:- str：输出的时间格式化字符串存储空间。- maxsize：存储空间str的最大字符数。- format：格式化模版。- timeptr：需要输出时间格式化字符串的变量。return:返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。*&#x2F; 格式化模版使用的含义符参见：菜鸟教程 示例 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main ()&#123; time_t rawtime; struct tm *info; char buffer[80]; time( &amp;rawtime ); info &#x3D; localtime( &amp;rawtime ); strftime(buffer, 80, &quot;%Y-%m-%d %H:%M:%S&quot;, info); printf(&quot;格式化的日期 &amp; 时间 : |%s|\\n&quot;, buffer ); return(0);&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"}],"tags":[{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"}]},{"title":"GC标记-清除算法","slug":"GC_mark_sweep_algorithm","date":"2021-03-14T16:00:00.000Z","updated":"2021-04-20T09:13:22.502Z","comments":true,"path":"2021/03/15/GC_mark_sweep_algorithm/","link":"","permalink":"https://www.chaguake.com/2021/03/15/GC_mark_sweep_algorithm/","excerpt":"","text":"GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的内存空间重新得到利用。 伪代码标记-清除算法的伪代码： 12345mark_sweep()&#123; mark_phase(); sweep_phase();&#125; 回收内存部分以下图的堆为例子，对各个阶段进行说明： 标记阶段根据上面出现的mark_phase()函数来进行标记阶段的处理。 mark_phase()函数伪代码： 12345mark_phase()&#123; for(r : $roots); mark(*r);&#125; 在标记阶段中，collector 会为堆里的所有活动对象打上标记。为此，我们首先要标记通过根直接引用的对象。首先我们标记这样的对象，然后递归地标记通过指针数组能访问到的对象。这样就能把所有活动对象都标记上了。 mark()函数伪代码： 1234567891011mark(obj)&#123; if(obj.mark == FALSE) &#123; obj.mark == TRUE; for(child : children(obj)) &#123; mark(*child); &#125; &#125;&#125; 在第 2 行中，检查作为实参传递的 obj 是否已被标记。在引用中包含了循环等的情况下，即使对已被标记的对象，有时程序也会调用 mark() 函数。出现类似这种情况的时候，我们就要避免重复进行标记处理。 如果标记未完成，则程序会在对象的头部进行置位操作。这个位要分配在对象的头之中，并且能用 obj.mark 访问。意思是若 obj.mark 为真，则表示对象已标记；若 obj.mark 为假，则对象没有被标记。 标记完所有活动对象后，标记阶段就结束了。标记阶段结束时的堆如下图所示： 在标记阶段中，程序会标记所有活动对象。毫无疑问，标记所花费的时间是与“活动对象的总数”成正比的。 以上是关于标记阶段的说明。用一句话概括，标记阶段就是“遍历对象并标记”的处理过程。这个“遍历对象”的处理过程在 GC 中是一个非常重要的概念，在之后还会多次出现，请务必记牢。 专栏深度优先搜索 广度优先搜索 比较一下内存使用量（已存储的对象数量）就可以知道，深度优先搜索比广度优先搜索更能压低内存使用量。 清除阶段在清除阶段中，collector 会遍历整个堆，回收没有打上标记的对象（即垃圾），使其能再次得到利用。 sweep_phase()函数伪代码： 123456789101112131415sweep_phase()&#123; sweeping = $heap_start; while(sweeping &lt; $heap_end) &#123; if(sweeping.mark == TRUE) sweeping.mark == FALSE; else &#123; sweeping.next = $free_list; $file_list = sweeping; &#125; &#125; sweeping += sweeping.size;&#125; 在此出现了叫作 size 的域，这是存储对象大小（字节数）的域。跟 mark 域一样，我们事先在各对象的头中定义它们。 在清除阶段，我们使用变量 sweeping 遍历堆，具体来说就是从堆首地址 $heap_start 开始，按顺序一个个遍历对象的标志位。 设置了标志位，就说明这个对象是活动对象。活动对象必然是不能回收的。在第 5 行我们取消标志位，准备下一次的 GC。 我们必须把非活动对象回收再利用。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。 我们在 sweep_phase() 函数的第 7 行、第 8 行进行这项操作。 在第 7 行新出现了叫作 next 的域。我们只在生成空闲链表以及从这个空闲链表中取出分块时才会使用到它。没有必要为各个对象特别准备域，从对象已有的域之中分出来一个就够了。在本章中，next 表示对象（或者分块）最初的域，即 field1。也就是说，给 field1 这个域起个别名叫 next。这跟 C 语言中的联合体（union）的概念相同。 在清除阶段，程序会遍历所有堆，进行垃圾回收。也就是说，所花费时间与堆大小成正比。堆越大，清除阶段所花费的时间就会越长。 分配部分分配这里的分配是指将回收的垃圾进行再利用。当 mutator 申请分块时，怎样才能把大小合适的分块分配给 mutator 呢？ 在清除阶段已经把垃圾对象连接到空闲链表了。搜索空闲链表并寻找大小合适的分块，这项操作就叫作分配。 执行分配的函数new_obj()伪代码： 12345678new_obj(size)&#123; chunk = pickup_chunk(size, $free_list); if(chunk != NULL) return chunk; else allocation_fail();&#125; 第 2 行的 pickup_chunk() 函数用于遍历 $free_list，寻找大于等于 size 的分块。它不光会返回和 size 大小相同的分块，还会返回比 size 大的分块。如果它找到和 size 大小相同的分块，则会直接返回该分块；如果它找到比 size 大的分块，则会将其分割成 size 大小的分块和去掉 size 后剩余大小的分块，并把剩余的分块返回空闲链表。 如果此函数没有找到合适的分块，则会返回 NULL。返回 NULL 时分配是不会进行的。 专栏First - fit、Best - fit、Worst - fit 的不同之前我们讲的分配策略叫作 First - fit。因为在 pickup_chunk() 函数中，最初发现大于等于 size 的分块时就会立即返回该分块。 然而，分配策略不止这些。还有遍历空闲链表，返回大于等于 size 的最小分块，这种策略叫作 Best - fit。 还有一种策略叫作 Worst - fit，即找出空闲链表中最大的分块，将其分割成 mutator 申请的大小和分割后剩余的大小，目的是将分割后剩余的分块最大化。但因为 Worst - fit 很容易生成大量小的分块，所以不推荐大家使用此方法。 除去 Worst - fit，剩下的还有 Best - fit 和 First - fit 这两种。当我们使用单纯的空闲链表时，考虑到分配所需的时间，选择使用 First - fit 更为明智。 合并前文中已经提过，根据分配策略的不同可能会产生大量的小分块。但如果它们是连续的，我们就能把所有的小分块连在一起形成一个大分块。这种“连接连续分块”的操作就叫作合并（coalescing），合并是在清除阶段进行的。 执行合并的函数sweep_phase()伪代码： 1234567891011121314151617181920sweep_phase()&#123; sweeping = $heap_start; while(sweeping &lt; $heap_end) &#123; if(sweeping.mark == TRUE) sweeping.mark = FALSE; else &#123; if(sweeping == $free_list + $free_list.size) $free_list.size +=sweeping.size; else &#123; sweeping.next = $free_list; $free_list = sweeping; &#125; &#125; sweeping += sweeping.size; &#125;&#125; 上面的sweep_phase() 函数只有第 7 行、第 8 行与上文的sweep_phase() 函数不同。第 7 行用于调查这次发现的分块和上次发现的分块是否连续，如果发现分块连续，则在第 8 行将邻接的 2 个分块合并，整理成 1 个分块。 优点实现简单与保守式 GC 算法兼容 GC 标记 - 清除算法因为不会移动对象，所以非常适合搭配保守式 GC 算法。 缺点碎片化在 GC 标记 - 清除算法的使用过程中会逐渐产生被细化的分块，不久后就会导致无数的小分块散布在堆的各处。我们称这种状况为碎片化（fragmentation）。 如果发生碎片化，那么即使堆中分块的总大小够用，也会因为一个个的分块都太小而不能执行分配。 此外，如果发生碎片化，就会增加 mutator 的执行负担。（把具有引用关系的对象安排在堆中较远的位置，就会增加访问所需的时间） 因为分块在堆中的分布情况取决于 mutator 的运行情况，所以只要使用 GC 标记 - 清除算法，就会或多或少地产生碎片化。 为了避免碎片化，需要对其进行“压缩”，或者采用“BiBOP 法”。 分配速度GC 标记 - 清除算法中分块不是连续的，因此每次分配都必须遍历空闲链表，找到足够大的分块。最糟的情况就是每次进行分配都得把空闲链表遍历到最后。 另一方面，因为在 GC 复制算法和 GC 标记 - 压缩算法中，分块是作为一个连续的内存空间存在的，所以没必要遍历空闲链表，分配就能非常高速地进行，而且还能在堆允许范围内分配很大的对象。 多个空闲链表（multiple free-list）和 BiBOP 法都是为了能在 GC 标记 - 清除算法中高速进行分配而想出的方法。 与写时复制技术不兼容写时复制技术（copy-on-write）是在 Linux 等众多 UNIX 操作系统的虚拟存储中用到的高速化方法。打个比方，在 Linux 中复制进程，也就是使用 fork() 函数时，大部分内存空间都不会被复制。只是复制进程，就复制了所有内存空间的话也太说不过去了吧。因此，写时复制技术只是装作已经复制了内存空间，实际上是将内存空间共享了。 在各个进程中访问数据时，能够访问共享内存就没什么问题了。 然而，当我们对共享内存空间进行写入时，不能直接重写共享内存。因为从其他程序访问时，会发生数据不一致的情况。在重写时，要复制自己私有空间的数据，对这个私有空间进行重写。复制后只访问这个私有空间，不访问共享内存。像这样，因为这门技术是“在写入时进行复制”的，所以才被称为写时复制技术。 这样的话，GC 标记 - 清除算法就会存在一个问题 —— 与写时复制技术不兼容。即使没重写对象，GC 也会设置所有活动对象的标志位，这样就会频繁发生本不应该发生的复制，压迫到内存空间。 为了处理这个问题，我们采用位图标记（bitmap marking）的方法。 多个空闲链表之前我们讲的标记 - 清除算法中只用到了一个空闲链表，在这个空闲链表中，对大的分块和小的分块进行同样的处理。但是这样一来，每次分配的时候都要遍历一次空闲链表来寻找合适大小的分块，这样非常浪费时间。 因此，我们有一种方法，就是利用分块大小不同的空闲链表，即创建只连接大分块的空闲链表和只连接小分块的空闲链表。这样一来，只要按照 mutator 所申请的分块大小选择空闲链表，就能在短时间内找到符合条件的分块了。 当只利用一个空闲链表时，需要遍历多次空闲链表才能分配 3 个字的分块。 这次数组的各个元素都位于空闲链表的前面，第 1 个元素是由 2 个字的分块连接的空闲链表的开头，第 2 个元素是由 3 个字的分块连接的空闲链表的开头。因此，例如在分配 3 个字的分块时，只要查询用于 3 个字的空闲链表就够了。比起只利用一个空闲链表来说，此方法大幅节约了分配所需要的时间。 不过请稍等，这里有一处需要我们留意。那就是到底制造多少个空闲链表才好呢？用于 2 个字的空闲链表、用于 3 个字的、用于 500 个字的 …… 照这样下去，我们就得准备无数个空闲链表了。 一般情况下，mutator 很少会申请非常大的分块。为了应对这种极少出现的情况而大量制造空闲链表，会使得空闲链表的数组过于巨大，结果压迫到内存空间。 因此，我们通常会给分块大小设定一个上限，分块如果大于等于这个大小，就全部采用一个空闲链表处理。有人可能会想：“这样一来，最后不还是没能有效率地搜索大的分块吗？”然而，因为这种分配非常大的分块的情况是极为罕见的，所以效率低一点也不是什么大问题。比这更为重要的是怎么去更快地搜索 mutator 频繁申请分配的小分块，把关注的重点移到这上面来才是更精明的做法。打个比方，如果设定分块大小上限为 100 个字，那么准备用于 2 个字、3 个字、……、100 个字，以及大于等于 101 个字的总共 100 个空闲链表就可以了。 利用多个空闲链表时，我们需要修正 new_obj() 函数以及 sweep_phase() 函数。修正后的 new_obj() 函数以及 sweep_phase() 函数： 利用多个空闲链表的 new_obj() 函数伪代码： 1234567891011121314151617181920new_obj(size)&#123; index = size / (WORD_LENGTH / BYTE_LENGTH) if(index &lt;= 100) &#123; if($free_list[index] != NULL) &#123; chunk = $free_list[index]; $free_list[index] = $free_list[index].next; return chunk; &#125; &#125; else &#123; chunk = pickup_chunk(size, $free_list[101]); if(chunk != NULL) return chunk; &#125; allocation_fail();&#125; 利用多个空闲链表的 sweep_phase() 函数伪代码： 1234567891011121314151617181920212223242526sweep_phase()&#123; for(i:2..101) $free_list[i] = NULL; sweeping = $heap_start; while(sweeping &lt; $heap_end) &#123; if(sweeping.mark == TRUE) sweeping.mark = FALSE; else &#123; index = size / (WORK_LENGHT / BYTE_LENGHT); if(index &lt;= 100) &#123; sweeping.next = $free_list[index]; $free_list[index] = sweeping; &#125; else &#123; sweeping.next = $free_list[101]; $free_list[101] = sweeping; &#125; &#125; sweeping += sweeping.size; &#125;&#125; BiBOP 法BiBOP 是 Big Bag Of Pages 的缩写。含义是将大小相近的对象整理成固定大小的块进行管理的做法。 GC 标记 - 清除算法中会发生碎片化。碎片化的原因之一就是堆上杂乱散布着大小各异的对象。 对此，我们可以用这个方法：把堆分割成固定大小的块，让每个块只能配置同样大小的对象。这就是 BiBOP 法。 3 个字的对象被整合分配到左数第 1 个和第 3 个块，2 个字的对象被整合分配到左数第 2 个块。像这样配置对象，就会提高内存的使用效率。因为每个块中只能配置同样大小的对象，所以不可能出现大小不均的分块。 但是，使用 BiBOP 法并不能完全消除碎片化。比方说在全部用于 2 个字的块中，只有 1 到 2 个活动对象，这种情况下就不能算是有效利用了堆。 BiBOP 法原本是为了消除碎片化，提高堆使用效率而采用的方法。但像上面这样，在多个块中分散残留着同样大小的对象，反而会降低堆使用效率。 位图标记在单纯的 GC 标记 - 清除算法中，用于标记的位是被分配到各个对象的头中的。也就是说，算法是把对象和头一并处理的。然而这跟写时复制技术不兼容。 对此我们有个方法，那就是只收集各个对象的标志位并表格化，不跟对象一起管理。在标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。像这样集合了用于标记的位的表格称为“位图表格”（bitmap table），利用这个表格进行标记的行为称为“位图标记”。位图表格的实现方法有多种，例如散列表和树形结构等。为了简单起见，这里我们采用整数型数组。 在位图标记中重要的是，位图表格中位的位置要和堆里的各个对象切实对应。一般来说，堆中的 1 个字会分配到 1 个位。 位图标记中的 mark() 函数伪代码： 123456789101112mark(obj)&#123; obj_num = (obj - $heap_start) / WORD_LENGHT; index = obj_num / WORD_LENGHT; offset = obj_num % WORD_LENGHT; if(($bitmap_tbl[index] &amp; (1 &lt;&lt; offset)) == 0) &#123; $bitmap_tbl[index] != (1 &lt;&lt; offset); for(child : children(obj)) mark(*child); &#125;&#125; 在这里，WORD_LENGTH 是个常量，表示的是各机器中 1 个字的位宽（例如 32 位机器的 WORD_LENGTH 就是 32）。obj_num 指的是从位图表格前面数起，obj 的标志位在第几个。如上图的 E，它的 obj_num 值就是 8。但下图中位的排序顺序和上图是相反的。因此，E 的标志位是从 bitmap_table[0] 的右边起第 9 个位。 我们用 obj_num 除以 WORD_LENGTH 得到的商 index 以及余数 offset 来分别表示位图表格的行编号和列编号。第 6 行和第 7 行中用到了位运算，看上去有些复杂，实际上只是干了件非常简单的事情。 和在对象的头中直接置标志位的方法相比，该方法稍微有些复杂，但是这样做有两个好处。 优点与写时复制技术兼容以往的标记操作都是直接对对象设置标志位，这会产生无谓的复制。 然而，使用位图标记是不会对对象设置标志位的，所以也不会发生无谓的复制。当然，因为对位图表格进行了重写，所以在此处会发生复制。不过，因为位图表格非常小，所以即使被复制也不会有什么大的影响。 此外，以上问题只发生在写时复制技术的运行环境（Linux 等）中，以及频繁执行 fork() 函数的应用程序中。也就是说，它对于一般的程序来说完全不是问题。 清除操作更高效不仅在标记阶段，在清除阶段也可以得到好处。以往的清除操作都必须遍历整个堆，把非活动对象连接到空闲链表，同时取消活动对象的标志位。 利用了位图表格的清除操作则把所有对象的标志位集合到一处，所以可以快速消去标志位。 位图标记的sweep_phase() 函数伪代码： 1234567891011121314151617181920sweep_phase()&#123; sweeping = $heap_start; index = 0; offset = 0; while(sweeping &lt; $heap_end) &#123; if($bitmap_tbl[index] &amp; (1 &lt;&lt; offset) == 0) &#123; sweeping.next = $free_list; $free_list = sweeping &#125; index += (offset + sweeping.size) / WORD_LENGTH; offset = (offset + sweeping.size) % WORD_LENGTH; sweeping += sweeping.size; &#125; for(i : 0..(HEAP_SIZE / WORD_LENGTH - 1)) $bitmap_tbl[i] = 0&#125; 与一般的清除阶段相同，我们用 sweeping 指针遍历整个堆。不过，这里使用了 index 和 offset 两个变量，在遍历堆的同时也遍历位图表格。 第 6 行到第 12 行是从堆的开头开始遍历。第 7 行是调查遍历过程中与对象对应的标志位。当对象没有设置标志位时，程序会在第 8 行和第 9 行将此对象连接到空闲链表。当对象已经设立了标志位时，程序就不会在此进行消除位的操作，而是放到之后一并进行。 第 10 行、第 11 行是遍历位图表格，第 12 行是遍历堆。 第 14 行、第 15 行是把所有在位图表格中设置的位取消。因为能够一并消除标志位，所以能够有效地取消位。 要注意的地方在进行位图标记的过程中，有件事情我们必须注意，那就是对象地址和位图表格的对应。就像之前和大家说明的那样，想通过对象的地址求与其对应的标志位的位置，是要进行位运算的。然而在堆有多个，对象地址不连续的情况下，我们无法用单纯的位运算求出标志位的位置。因此，在堆为多个的情况下，一般会为每个堆都准备一个位图表格。 延迟清除法清除操作所花费的时间是与堆大小成正比的。也就是说，处理的堆越大，GC 标记 - 清除算法所花费的时间就越长，结果就会妨碍到 mutator 的处理。 延迟清除法（Lazy Sweep）是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在标记操作结束后，不一并进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。 延迟清除法中的 new_obj() 函数伪代码： 1234567891011new_obj(size)&#123; chunk = lazy_sweep(size); if(chunk != NULL) return chunk; mark_phase(); chunk = lazy_sweep(size); if(chunk != NULL) return chunk; allocation_fail();&#125; 在分配时直接调用 lazy_sweep() 函数，进行清除操作。如果它能用清除操作来分配分块，就会返回分块；如果不能分配分块，就会执行标记操作。当 lazy_sweep() 函数返回 NULL 时，也就是没有找到分块时，会调用 mark_phase() 函数进行一遍标记操作，再调用 lazy_sweep() 函数来分配分块。在这里没能分配分块也就意味着堆上没有分块，mutator 也就不能再进行下一步处理了。 lazy_sweep() 函数伪代码： 12345678910111213141516171819lazy_sweep(size)&#123; while($sweeping &lt; $heap_end) &#123; if($sweeping.mark == TRUE) &#123; $sweeping.mark = FALSE; &#125; else if($sweeping.size &gt;= size) &#123; chunk = $sweeping; $sweeping += $sweeping.size; return chunk; &#125; $sweeping += $sweeping.size; &#125; $sweeping = $heap_start; return NULL;&#125; lazy_sweep() 函数会一直遍历堆，直到找到大于等于所申请大小的分块为止。在找到合适分块时会将其返回。但是在这里 $sweeping 变量是全局变量。也就是说，遍历的开始位置位于上一次清除操作中发现的分块的右边。 当 lazy_sweep() 函数遍历到堆最后都没有找到分块时，会返回 NULL。 因为延迟清除法不是一下遍历整个堆，它只在分配时执行必要的遍历，所以可以压缩因清除操作而导致的 mutator 的暂停时间。这就是“延迟”清除操作的意思。 我们已经知道，通过延迟清除法可以缩减 mutator 的暂停时间，不过这是真的吗？稍微想想看就会明白，延迟清除的效果是不均衡的。打个比方，假设刚标记完的堆的情况如下图 所示。 也就是说，垃圾变成了垃圾堆，活动对象变成了活动对象堆，它们形成了一种邻接的状态。在这种情况下，程序在清除垃圾较多的部分时能马上获得分块，所以能减少 mutator 的暂停时间。然而一旦程序开始清除活动对象周围，就怎么也无法获得分块了，这样就增加了 mutator 的暂停时间。 结果，如果一下子清除的堆大小不一定，那么 mutator 的暂停时间就会增大。 关于保持所清除的堆大小的方法，后文详细说明。 虽然在这里没有特别提及，不过标记阶段导致的暂停时间和清除阶段导致的暂停时间一样，也是个问题。关于如何改善这个问题，也是在后文详细说明。","categories":[{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"《垃圾回收的算法与实现》","slug":"《垃圾回收的算法与实现》","permalink":"https://www.chaguake.com/tags/%E3%80%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"}]},{"title":"C++多态之虚函数与虚函数表","slug":"virtual_function_or_table_of_polymorphism","date":"2021-03-13T16:00:00.000Z","updated":"2021-03-14T10:53:29.587Z","comments":true,"path":"2021/03/14/virtual_function_or_table_of_polymorphism/","link":"","permalink":"https://www.chaguake.com/2021/03/14/virtual_function_or_table_of_polymorphism/","excerpt":"","text":"虚函数，是用关键字virtual修饰的类成员函数，但不包括静态函数（static）和构造函数。 内联函数（inline）可以是虚函数。因为内联函数是作用于编译期间，用于通知编译器是否要将内联函数展开。当虚函数标记为内联函数时，假如该函数呈现运行时多态，那么编译器会忽略关键字inline。 12345678910111213141516171819202122class Base&#123;public: Base(); ~Base(); virtual void fun1(); virtual void fun2();&#125;class Device:public Base&#123;public: Device(); virtual ~Device();&#x2F;&#x2F;确保Device类正常析构 virtual void fun1(); void fun2();&#x2F;&#x2F;不加关键字virtual也可以 virtual void print();&#125;&#x2F;&#x2F;Device dev;&#x2F;&#x2F;dev.fun1();&#x2F;&#x2F;dev.fun2(); 运行上面代码，可以发现，对象dev有一个指针对象__vfptr。 指针对象__vfptr是虚函数指针，类型为void(*)()，它指向对象dev的数组vftable，即虚函数表。 定义另一个Device类对象，可以看到，两个Device类对象的指针对象__vfptr的地址是一样的，这就意味着，Device类的虚函数表全局只有一份，所有Device类对象都会创建一个虚函数指针，并指向它。 在Device类中定义虚函数print，会发现在__vfptr中并没有发现它，但vftable大小+1，派生另一个类，继承于Device类，其__vfptr和vftable跟Device类一样。 这就说明，继承于Base类，但属于其子类的虚函数都会按顺序写入基类的vftable里。（假如有多继承，那属于其子类的虚函数都会按顺序写入第一个基类的vftable里。） 那假如基类并没有虚函数呢？ 可以看出，vftable会挂在基类的下一级子类中（或者再下一级）。 其他博客的相关文章：C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"}],"tags":[{"name":"C++多态","slug":"C-多态","permalink":"https://www.chaguake.com/tags/C-%E5%A4%9A%E6%80%81/"}]}],"categories":[{"name":"blender","slug":"blender","permalink":"https://www.chaguake.com/categories/blender/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.chaguake.com/categories/OpenGL/"},{"name":"书籍","slug":"书籍","permalink":"https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"},{"name":"数据库","slug":"数据库","permalink":"https://www.chaguake.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.chaguake.com/categories/C-C/"},{"name":"问题排查","slug":"问题排查","permalink":"https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"面试","permalink":"https://www.chaguake.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/categories/lua/"}],"tags":[{"name":"blender工具","slug":"blender工具","permalink":"https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"},{"name":"OpenGL入门","slug":"OpenGL入门","permalink":"https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"},{"name":"《Go语言高级编程》","slug":"《Go语言高级编程》","permalink":"https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"},{"name":"Mysql","slug":"Mysql","permalink":"https://www.chaguake.com/tags/Mysql/"},{"name":"字符串算法","slug":"字符串算法","permalink":"https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"},{"name":"C/C++知识","slug":"C-C-知识","permalink":"https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"},{"name":"问题排查之TCP","slug":"问题排查之TCP","permalink":"https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"},{"name":"TCP","slug":"TCP","permalink":"https://www.chaguake.com/tags/TCP/"},{"name":"抽样算法","slug":"抽样算法","permalink":"https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"},{"name":"洗牌算法","slug":"洗牌算法","permalink":"https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"name":"lua","slug":"lua","permalink":"https://www.chaguake.com/tags/lua/"},{"name":"《垃圾回收的算法与实现》","slug":"《垃圾回收的算法与实现》","permalink":"https://www.chaguake.com/tags/%E3%80%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"},{"name":"C++多态","slug":"C-多态","permalink":"https://www.chaguake.com/tags/C-%E5%A4%9A%E6%80%81/"}]}