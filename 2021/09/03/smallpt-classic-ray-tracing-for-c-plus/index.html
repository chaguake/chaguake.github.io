<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="解衣又作茶瓜客，倚槛同看烟雨峰">
    

    <!--Author-->
    
        <meta name="author" content="茶瓜客">
    

    <!-- Title -->
    
    <title>smallpt | 茶瓜客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="茶瓜客" type="application/atom+xml">
</head>

<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                smallpt
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <p>smallpt是一个C++实现的经典光线追踪代码，只有99行。</p>
<span id="more"></span>
<p>原文：<a target="_blank" rel="noopener" href="http://www.kevinbeason.com/smallpt/">http://www.kevinbeason.com/smallpt/</a></p>
<p>翻译：<a target="_blank" rel="noopener" href="https://samuel92.blog.csdn.net/article/details/108189198">https://samuel92.blog.csdn.net/article/details/108189198</a></p>
<p>文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/148759248">https://zhuanlan.zhihu.com/p/148759248</a></p>
<p align="center">
    <img src="http://www.kevinbeason.com/smallpt/result_25k.png" width="95%">
    <br />    <small> global illumination renderer </small>
</p>


<p>smallpt 是一个全局光照渲染器，基于无偏蒙特卡洛路径追踪算法。</p>
<blockquote>
<p>首先，蒙特卡洛路径追踪算法知识可看GAMES101教程的第16节。然后，无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。</p>
</blockquote>
<h2 id="一、特征"><a href="#一、特征" class="headerlink" title="一、特征"></a>一、特征</h2><ul>
<li>基于无偏蒙特卡罗路径跟踪的全局照明。</li>
<li>多线程使用OpenMP。</li>
<li>漫反射的软阴影。</li>
<li>镜面反射、漫反射和玻璃BRDF。</li>
<li>通过重要性采样的超采样（2x2子像素）来抗锯齿。</li>
<li>射线球交点。</li>
<li>场景使用改进的Cornell box。</li>
<li>半球漫反射的余弦重要性采样。</li>
<li>俄罗斯轮盘赌实现路径终止。</li>
<li>俄罗斯轮盘赌和分割，用于选择玻璃BRDF的反射和（或）折射。</li>
<li>显式灯光采样和非分支光线树。</li>
<li>CUDA和BSGP的端口具有交互式显示和场景编辑功能。</li>
</ul>
<h2 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;   &#x2F;&#x2F; smallpt, a Path Tracer by Kevin Beason, 2008</span><br><span class="line">#include &lt;stdlib.h&gt; &#x2F;&#x2F; Make : g++ -O3 -fopenmp smallpt.cpp -o smallpt</span><br><span class="line">#include &lt;stdio.h&gt;  &#x2F;&#x2F;        Remove &quot;-fopenmp&quot; for g++ version &lt; 4.2</span><br><span class="line">struct Vec &#123;        &#x2F;&#x2F; Usage: time .&#x2F;smallpt 5000 &amp;&amp; xv image.ppm</span><br><span class="line">  double x, y, z;                  &#x2F;&#x2F; position, also color (r,g,b)</span><br><span class="line">  Vec(double x_&#x3D;0, double y_&#x3D;0, double z_&#x3D;0)&#123; x&#x3D;x_; y&#x3D;y_; z&#x3D;z_; &#125;</span><br><span class="line">  Vec operator+(const Vec &amp;b) const &#123; return Vec(x+b.x,y+b.y,z+b.z); &#125;</span><br><span class="line">  Vec operator-(const Vec &amp;b) const &#123; return Vec(x-b.x,y-b.y,z-b.z); &#125;</span><br><span class="line">  Vec operator*(double b) const &#123; return Vec(x*b,y*b,z*b); &#125;</span><br><span class="line">  Vec mult(const Vec &amp;b) const &#123; return Vec(x*b.x,y*b.y,z*b.z); &#125;</span><br><span class="line">  Vec&amp; norm()&#123; return *this &#x3D; *this * (1&#x2F;sqrt(x*x+y*y+z*z)); &#125;</span><br><span class="line">  double dot(const Vec &amp;b) const &#123; return x*b.x+y*b.y+z*b.z; &#125; &#x2F;&#x2F; cross:</span><br><span class="line">  Vec operator%(Vec&amp;b)&#123;return Vec(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Ray &#123; Vec o, d; Ray(Vec o_, Vec d_) : o(o_), d(d_) &#123;&#125; &#125;;</span><br><span class="line">enum Refl_t &#123; DIFF, SPEC, REFR &#125;;  &#x2F;&#x2F; material types, used in radiance()</span><br><span class="line">struct Sphere &#123;</span><br><span class="line">  double rad;       &#x2F;&#x2F; radius</span><br><span class="line">  Vec p, e, c;      &#x2F;&#x2F; position, emission, color</span><br><span class="line">  Refl_t refl;      &#x2F;&#x2F; reflection type (DIFFuse, SPECular, REFRactive)</span><br><span class="line">  Sphere(double rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_):</span><br><span class="line">    rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125;</span><br><span class="line">  double intersect(const Ray &amp;r) const &#123; &#x2F;&#x2F; returns distance, 0 if nohit</span><br><span class="line">    Vec op &#x3D; p-r.o; &#x2F;&#x2F; Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 &#x3D; 0</span><br><span class="line">    double t, eps&#x3D;1e-4, b&#x3D;op.dot(r.d), det&#x3D;b*b-op.dot(op)+rad*rad;</span><br><span class="line">    if (det&lt;0) return 0; else det&#x3D;sqrt(det);</span><br><span class="line">    return (t&#x3D;b-det)&gt;eps ? t : ((t&#x3D;b+det)&gt;eps ? t : 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Sphere spheres[] &#x3D; &#123;&#x2F;&#x2F;Scene: radius, position, emission, color, material</span><br><span class="line">  Sphere(1e5, Vec( 1e5+1,40.8,81.6), Vec(),Vec(.75,.25,.25),DIFF),&#x2F;&#x2F;Left</span><br><span class="line">  Sphere(1e5, Vec(-1e5+99,40.8,81.6),Vec(),Vec(.25,.25,.75),DIFF),&#x2F;&#x2F;Rght</span><br><span class="line">  Sphere(1e5, Vec(50,40.8, 1e5),     Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Back</span><br><span class="line">  Sphere(1e5, Vec(50,40.8,-1e5+170), Vec(),Vec(),           DIFF),&#x2F;&#x2F;Frnt</span><br><span class="line">  Sphere(1e5, Vec(50, 1e5, 81.6),    Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Botm</span><br><span class="line">  Sphere(1e5, Vec(50,-1e5+81.6,81.6),Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Top</span><br><span class="line">  Sphere(16.5,Vec(27,16.5,47),       Vec(),Vec(1,1,1)*.999, SPEC),&#x2F;&#x2F;Mirr</span><br><span class="line">  Sphere(16.5,Vec(73,16.5,78),       Vec(),Vec(1,1,1)*.999, REFR),&#x2F;&#x2F;Glas</span><br><span class="line">  Sphere(600, Vec(50,681.6-.27,81.6),Vec(12,12,12),  Vec(), DIFF) &#x2F;&#x2F;Lite</span><br><span class="line">&#125;;</span><br><span class="line">inline double clamp(double x)&#123; return x&lt;0 ? 0 : x&gt;1 ? 1 : x; &#125;</span><br><span class="line">inline int toInt(double x)&#123; return int(pow(clamp(x),1&#x2F;2.2)*255+.5); &#125;</span><br><span class="line">inline bool intersect(const Ray &amp;r, double &amp;t, int &amp;id)&#123;</span><br><span class="line">  double n&#x3D;sizeof(spheres)&#x2F;sizeof(Sphere), d, inf&#x3D;t&#x3D;1e20;</span><br><span class="line">  for(int i&#x3D;int(n);i--;) if((d&#x3D;spheres[i].intersect(r))&amp;&amp;d&lt;t)&#123;t&#x3D;d;id&#x3D;i;&#125;</span><br><span class="line">  return t&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">Vec radiance(const Ray &amp;r, int depth, unsigned short *Xi)&#123;</span><br><span class="line">  double t;                               &#x2F;&#x2F; distance to intersection</span><br><span class="line">  int id&#x3D;0;                               &#x2F;&#x2F; id of intersected object</span><br><span class="line">  if (!intersect(r, t, id)) return Vec(); &#x2F;&#x2F; if miss, return black</span><br><span class="line">  const Sphere &amp;obj &#x3D; spheres[id];        &#x2F;&#x2F; the hit object</span><br><span class="line">  Vec x&#x3D;r.o+r.d*t, n&#x3D;(x-obj.p).norm(), nl&#x3D;n.dot(r.d)&lt;0?n:n*-1, f&#x3D;obj.c;</span><br><span class="line">  double p &#x3D; f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; &#x2F;&#x2F; max refl</span><br><span class="line">  if (++depth&gt;5) if (erand48(Xi)&lt;p) f&#x3D;f*(1&#x2F;p); else return obj.e; &#x2F;&#x2F;R.R.</span><br><span class="line">  if (obj.refl &#x3D;&#x3D; DIFF)&#123;                  &#x2F;&#x2F; Ideal DIFFUSE reflection</span><br><span class="line">    double r1&#x3D;2*M_PI*erand48(Xi), r2&#x3D;erand48(Xi), r2s&#x3D;sqrt(r2);</span><br><span class="line">    Vec w&#x3D;nl, u&#x3D;((fabs(w.x)&gt;.1?Vec(0,1):Vec(1))%w).norm(), v&#x3D;w%u;</span><br><span class="line">    Vec d &#x3D; (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1-r2)).norm();</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,d),depth,Xi));</span><br><span class="line">  &#125; else if (obj.refl &#x3D;&#x3D; SPEC)            &#x2F;&#x2F; Ideal SPECULAR reflection</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,r.d-n*2*n.dot(r.d)),depth,Xi));</span><br><span class="line">  Ray reflRay(x, r.d-n*2*n.dot(r.d));     &#x2F;&#x2F; Ideal dielectric REFRACTION</span><br><span class="line">  bool into &#x3D; n.dot(nl)&gt;0;                &#x2F;&#x2F; Ray from outside going in?</span><br><span class="line">  double nc&#x3D;1, nt&#x3D;1.5, nnt&#x3D;into?nc&#x2F;nt:nt&#x2F;nc, ddn&#x3D;r.d.dot(nl), cos2t;</span><br><span class="line">  if ((cos2t&#x3D;1-nnt*nnt*(1-ddn*ddn))&lt;0)    &#x2F;&#x2F; Total internal reflection</span><br><span class="line">    return obj.e + f.mult(radiance(reflRay,depth,Xi));</span><br><span class="line">  Vec tdir &#x3D; (r.d*nnt - n*((into?1:-1)*(ddn*nnt+sqrt(cos2t)))).norm();</span><br><span class="line">  double a&#x3D;nt-nc, b&#x3D;nt+nc, R0&#x3D;a*a&#x2F;(b*b), c &#x3D; 1-(into?-ddn:tdir.dot(n));</span><br><span class="line">  double Re&#x3D;R0+(1-R0)*c*c*c*c*c,Tr&#x3D;1-Re,P&#x3D;.25+.5*Re,RP&#x3D;Re&#x2F;P,TP&#x3D;Tr&#x2F;(1-P);</span><br><span class="line">  return obj.e + f.mult(depth&gt;2 ? (erand48(Xi)&lt;P ?   &#x2F;&#x2F; Russian roulette</span><br><span class="line">    radiance(reflRay,depth,Xi)*RP:radiance(Ray(x,tdir),depth,Xi)*TP) :</span><br><span class="line">    radiance(reflRay,depth,Xi)*Re+radiance(Ray(x,tdir),depth,Xi)*Tr);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  int w&#x3D;1024, h&#x3D;768, samps &#x3D; argc&#x3D;&#x3D;2 ? atoi(argv[1])&#x2F;4 : 1; &#x2F;&#x2F; # samples</span><br><span class="line">  Ray cam(Vec(50,52,295.6), Vec(0,-0.042612,-1).norm()); &#x2F;&#x2F; cam pos, dir</span><br><span class="line">  Vec cx&#x3D;Vec(w*.5135&#x2F;h), cy&#x3D;(cx%cam.d).norm()*.5135, r, *c&#x3D;new Vec[w*h];</span><br><span class="line">#pragma omp parallel for schedule(dynamic, 1) private(r)       &#x2F;&#x2F; OpenMP</span><br><span class="line">  for (int y&#x3D;0; y&lt;h; y++)&#123;                       &#x2F;&#x2F; Loop over image rows</span><br><span class="line">    fprintf(stderr,&quot;\rRendering (%d spp) %5.2f%%&quot;,samps*4,100.*y&#x2F;(h-1));</span><br><span class="line">    for (unsigned short x&#x3D;0, Xi[3]&#x3D;&#123;0,0,y*y*y&#125;; x&lt;w; x++)   &#x2F;&#x2F; Loop cols</span><br><span class="line">      for (int sy&#x3D;0, i&#x3D;(h-y-1)*w+x; sy&lt;2; sy++)     &#x2F;&#x2F; 2x2 subpixel rows</span><br><span class="line">        for (int sx&#x3D;0; sx&lt;2; sx++, r&#x3D;Vec())&#123;        &#x2F;&#x2F; 2x2 subpixel cols</span><br><span class="line">          for (int s&#x3D;0; s&lt;samps; s++)&#123;</span><br><span class="line">            double r1&#x3D;2*erand48(Xi), dx&#x3D;r1&lt;1 ? sqrt(r1)-1: 1-sqrt(2-r1);</span><br><span class="line">            double r2&#x3D;2*erand48(Xi), dy&#x3D;r2&lt;1 ? sqrt(r2)-1: 1-sqrt(2-r2);</span><br><span class="line">            Vec d &#x3D; cx*( ( (sx+.5 + dx)&#x2F;2 + x)&#x2F;w - .5) +</span><br><span class="line">                    cy*( ( (sy+.5 + dy)&#x2F;2 + y)&#x2F;h - .5) + cam.d;</span><br><span class="line">            r &#x3D; r + radiance(Ray(cam.o+d*140,d.norm()),0,Xi)*(1.&#x2F;samps);</span><br><span class="line">          &#125; &#x2F;&#x2F; Camera rays are pushed ^^^^^ forward to start in interior</span><br><span class="line">          c[i] &#x3D; c[i] + Vec(clamp(r.x),clamp(r.y),clamp(r.z))*.25;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  FILE *f &#x3D; fopen(&quot;image.ppm&quot;, &quot;w&quot;);         &#x2F;&#x2F; Write image to PPM file.</span><br><span class="line">  fprintf(f, &quot;P3\n%d %d\n%d\n&quot;, w, h, 255);</span><br><span class="line">  for (int i&#x3D;0; i&lt;w*h; i++)</span><br><span class="line">    fprintf(f,&quot;%d %d %d &quot;, toInt(c[i].x), toInt(c[i].y), toInt(c[i].z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -O3 -fopenmp smallpt.cpp -o smallpt </span><br><span class="line">time .&#x2F;smallpt 5000</span><br><span class="line">display image.ppm</span><br></pre></td></tr></table></figure>
<h2 id="四、细节"><a href="#四、细节" class="headerlink" title="四、细节"></a>四、细节</h2><p align="center">
    <img src="https://z3.ax1x.com/2021/08/06/fnD54K.png" width="95%">
    <br />    <small> 2.4 GHz 两核四线程，每个像素的不同采样数（spp）的计时和结果图像  </small>
</p>

<p>通过使用数值积分求解渲染方程来计算图像。具体的算法是蒙特卡罗路径跟踪与俄罗斯轮盘赌路径终止。由于尺寸限制和简单性，不使用显式灯光采样，也不使用任何光线相交加速数据结构。</p>
<p><code>#pragma omp parallel for schedule(dynamic, 1) private(r)</code> 语句，使用OpenMP动态地将映像行分配给不同的线程，每个处理器或内核有一个线程。</p>
<p>变量 <code>Xi</code> 用于存储随机数生成器  <code>erand48</code> 的状态，使用行数来做随机值种子，这样子序列就是跟行数有关，与并行计算的先后顺序等无关。</p>
<p>抗锯齿是使用超级采样完成的，超级采样将删除除灯光周围以外的所有锯齿。通过使用2x2子像素进行处理，这些子像素先被clamp操作，然后求平均。</p>
<h2 id="五、扩展"><a href="#五、扩展" class="headerlink" title="五、扩展"></a>五、扩展</h2><p><strong>（一）Vec 类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span><br><span class="line">struct Vec &#123;        &#x2F;&#x2F; Usage: time .&#x2F;smallpt 5000 &amp;&amp; xv image.ppm</span><br><span class="line">  double x, y, z;                  &#x2F;&#x2F; position, also color (r,g,b)</span><br><span class="line">  Vec(double x_&#x3D;0, double y_&#x3D;0, double z_&#x3D;0)&#123; x&#x3D;x_; y&#x3D;y_; z&#x3D;z_; &#125;</span><br><span class="line">  Vec operator+(const Vec &amp;b) const &#123; return Vec(x+b.x,y+b.y,z+b.z); &#125;</span><br><span class="line">  Vec operator-(const Vec &amp;b) const &#123; return Vec(x-b.x,y-b.y,z-b.z); &#125;</span><br><span class="line">  Vec operator*(double b) const &#123; return Vec(x*b,y*b,z*b); &#125;</span><br><span class="line">  Vec mult(const Vec &amp;b) const &#123; return Vec(x*b.x,y*b.y,z*b.z); &#125;</span><br><span class="line">  Vec&amp; norm()&#123; return *this &#x3D; *this * (1&#x2F;sqrt(x*x+y*y+z*z)); &#125;</span><br><span class="line">  double dot(const Vec &amp;b) const &#123; return x*b.x+y*b.y+z*b.z; &#125; &#x2F;&#x2F; cross:</span><br><span class="line">  Vec operator%(Vec&amp;b)&#123;return Vec(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用</span><br><span class="line">Vec cx&#x3D;Vec(w*.5135&#x2F;h), cy&#x3D;(cx%cam.d).norm()*.5135, r, *c&#x3D;new Vec[w*h];</span><br></pre></td></tr></table></figure>
<p>Vec 类实现了向量的运算。</p>
<p>成员 norm 函数的计算公式其实是将三个分量分别乘以比例系数，从而达到归一化操作。</p>
<p>成员 dot 函数对应的是向量的点乘运算：</p>
<script type="math/tex; mode=display">
\vec{a} \cdot \vec{b} = 

\begin{pmatrix}
x_{a} \\ y_{a} \\ z_{a}
\end{pmatrix}

\cdot

\begin{pmatrix}
x_{b} \\ y_{b} \\ z_{b}
\end{pmatrix}

=

x_{a}x_{b} + y_{a}y_{b} + z_{a}z_{b}</script><p>% 操作运算符对应的是向量的叉乘运算：</p>
<script type="math/tex; mode=display">
\vec{a} \times \vec{b} = 

\begin{pmatrix}
x_{a} \\
y_{a} \\
z_{a} 
\end{pmatrix}

\times

\begin{pmatrix}
x_{b} \\
y_{b} \\
z_{b} 
\end{pmatrix}

=

\begin{pmatrix}
y_{a}z_{b} - y_{b}z_{a} \\
z_{a}x_{b} - x_{a}z_{b} \\
x_{a}y_{b} - y_{a}x_{b}
\end{pmatrix}</script><script type="math/tex; mode=display">
\vec{a} \times \vec{b} = A^{*}b = 
\underset{\text{dual matrix of vector a}}{
\begin{pmatrix}
0 & -z_{a} & y_{a} \\
z_{a} & 0 & -x_{a} \\
-y_{a} & x_{a} & 0
\end{pmatrix} 
}

\begin{pmatrix}
x_{b} \\
y_{b} \\
z_{b} 
\end{pmatrix}</script><p>应用上，变量 cx 为摄像机在 x 轴上的方向分量（右轴），同理变量 cy 是摄像机在 y 轴上的方向分量（上轴）。0.5135是视场系数，控制摄像机看到的范围，变量 cx 通过对输出图像的分辨率比例求得，而变量 cy 是通过摄像机方向和变量 cx 叉乘得到（见：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">LearnOpenGL-摄像机</a>）。</p>
<p>变量 r 是当前像素点的光照辐射值，通过对子像素点计算累加求得。</p>
<p>变量 c 是输出图像的数据数组，记录每个像素点的颜色值。</p>
<p><strong>（二）main 函数的5个 for 循环</strong></p>
<ol>
<li>第一个 for 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int y&#x3D;0; y&lt;h; y++)</span><br></pre></td></tr></table></figure>
<p>遍历输出像素分辨率的每一行。</p>
<ol>
<li>第二个 for 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (unsigned short x&#x3D;0, Xi[3]&#x3D;&#123;0,0,y*y*y&#125;; x&lt;w; x++)</span><br></pre></td></tr></table></figure>
<p>遍历每一行分辨率的每一个像素（每一列）。</p>
<ol>
<li>第三个 for 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int sy&#x3D;0, i&#x3D;(h-y-1)*w+x; sy&lt;2; sy++)</span><br></pre></td></tr></table></figure>
<p>从右下角开始，由于采用的是2x2超级采样，所以每个像素分为四个子像素。这一层对应每个像素。</p>
<ol>
<li>第四个 for 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int sx&#x3D;0; sx&lt;2; sx++, r&#x3D;Vec())</span><br></pre></td></tr></table></figure>
<p>由于采用的是2x2超级采样，所以每个像素分为四个子像素。这一层对应每个子像素。</p>
<p>这一层主要做两件事情，多次采样以及将每一个子像素计算结果累加到该像素点的数值上。</p>
<ol>
<li>第五个 for 循环</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int s&#x3D;0; s&lt;samps; s++)</span><br></pre></td></tr></table></figure>
<p>每个子像素采样 samps 次。</p>
<p>在该循环中，首先采用 Tent Filter 实现抗锯齿，然后计算该子像素点的光线方向 d，最后求得该子像素点的辐射值，并累加到像素点的辐射值变量 r 上。</p>
<p><strong>（三）Tent Filter</strong></p>
<p>先看 Tent Filter 的函数定义：</p>
<script type="math/tex; mode=display">
f_{tent}(x) = \begin{cases}
1- \vert x \vert , &  \vert x \vert < 1 \\[2ex]
0,  & \text{otherwise}
\end{cases}</script><p>低通滤波，只输出 x 的绝对值小于时的结果，再看代码的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double r1&#x3D;2*erand48(Xi), dx&#x3D;r1&lt;1 ? sqrt(r1)-1: 1-sqrt(2-r1);</span><br><span class="line">double r2&#x3D;2*erand48(Xi), dy&#x3D;r2&lt;1 ? sqrt(r2)-1: 1-sqrt(2-r2);</span><br></pre></td></tr></table></figure>
<p>变量 r1 和 r2 的取值在 $[0,2)$，然后变量 dx 和 dy 的取值根据 变量 r1 和 r2 的取值不同有着不同的取值，但总体范围在 $[-1,1]$：</p>
<script type="math/tex; mode=display">
d(r) =  \begin{cases}
\sqrt{r} - 1, &  0 \leq r < 1 \\[2ex]
1- \sqrt{2 - r},  &  1 \leq r < 2
\end{cases}</script><p>可以看到与原生 Tent Filter 的取值范围不同，先看下怎么使用结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vec d &#x3D; cx*( ( (sx+.5 + dx )&#x2F;2 + x)&#x2F;w - .5) +</span><br><span class="line">                    cy*( ( (sy+.5 + dy )&#x2F;2 + y)&#x2F;h - .5) + cam.d;</span><br></pre></td></tr></table></figure>
<p>子像素的光线方向 d 与摄像机在 xy 轴上的方向分量、当前子像素序号以及摄像机的方向有关。<code>sx+.5</code> 或 <code>sy+.5</code> 是将采样点移动到子像素的中心点，然后再加上 Tent Filter 值。</p>
<p>最终，<code>cx*( ( (sx+.5 + dx )/2 + x)/w - .5)</code> 或 <code>cy*( ( (sy+.5 + dy )/2 + y)/h - .5)</code> 对应分量的取值范围在 $[-0.5,0.5)$。也就是在当前像素点的面积内做偏移。</p>
<p><strong>上面解释的有问题，得看下面截图：</strong></p>
<p align="center">
    <img src="https://z3.ax1x.com/2021/08/09/f81oMd.png" width="95%">
    <br />    <small>  </small>
</p>

<p><strong>（四）OpenMP</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel for schedule(dynamic, 1) private(r)</span><br></pre></td></tr></table></figure>
<p>实现并行计算。</p>
<p><strong>（五）Sphere 类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Sphere &#123;</span><br><span class="line">  double rad;       &#x2F;&#x2F; radius</span><br><span class="line">  Vec p, e, c;      &#x2F;&#x2F; position, emission, color</span><br><span class="line">  Refl_t refl;      &#x2F;&#x2F; reflection type (DIFFuse, SPECular, REFRactive)</span><br><span class="line">  Sphere(double rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_):</span><br><span class="line">    rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125;</span><br><span class="line">  double intersect(const Ray &amp;r) const &#123; &#x2F;&#x2F; returns distance, 0 if nohit</span><br><span class="line">    Vec op &#x3D; p-r.o; &#x2F;&#x2F; Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 &#x3D; 0</span><br><span class="line">    double t, eps&#x3D;1e-4, b&#x3D;op.dot(r.d), det&#x3D;b*b-op.dot(op)+rad*rad;</span><br><span class="line">    if (det&lt;0) return 0; else det&#x3D;sqrt(det);</span><br><span class="line">    return (t&#x3D;b-det)&gt;eps ? t : ((t&#x3D;b+det)&gt;eps ? t : 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义场景各种物体的球体类。</p>
<p>成员变量 rad 定义球体半径，变量 p 定义球心位置，变量 e 定义物体自发光属性，变量 c 定义物体颜色，结构体变量 refl 定义物体散射性质（漫反射、镜面反射、折射）。</p>
<p>成员 intersect 函数判断物体与光线是否相交，相交则返回交点与光线原点的距离。而其判断方法为<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136763389">参数方程法</a>。</p>
<p><strong>（六）radiance 函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec radiance(const Ray &amp;r, int depth, unsigned short *Xi)</span><br></pre></td></tr></table></figure>
<p>radiance 函数接受三个参数，第一个是光线，第二个是光线追踪的深度，第三个是随机值种子。</p>
<p>在 main 函数中调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radiance(Ray(cam.o+d*140,d.norm()),0,Xi)</span><br></pre></td></tr></table></figure>
<p>因为重新计算了光线的方向，所以传入初始的光线位置和方向也需要对应改变。</p>
<ol>
<li>判断是否与物体相交，否则直接返回</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double t;                               &#x2F;&#x2F; distance to intersection</span><br><span class="line">int id&#x3D;0;                               &#x2F;&#x2F; id of intersected object</span><br><span class="line">if (!intersect(r, t, id)) return Vec(); &#x2F;&#x2F; if miss, return black</span><br></pre></td></tr></table></figure>
<p>全局 intersect 函数遍历每一个球体物体，然后判断光线是否与它们相交，并且返回最近的一个物体的交点距离。</p>
<ol>
<li>计算/定义一些相交之后的信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Sphere &amp;obj &#x3D; spheres[id];        &#x2F;&#x2F; the hit object</span><br><span class="line">Vec x&#x3D;r.o+r.d*t, n&#x3D;(x-obj.p).norm(), nl&#x3D;n.dot(r.d)&lt;0?n:n*-1, f&#x3D;obj.c;</span><br></pre></td></tr></table></figure>
<p>变量 obj 为本次光线路径追踪相交的物体。</p>
<p>变量 x 是通过光线函数表达式计算得到的交点坐标。</p>
<p>变量 n 是物体在交点上的表面法线。</p>
<p>变量 nl 是朝向法线（oriented normal），通过计算光线方向与物体交点表面法线之间的夹角余弦值，判断其正负来决定光线是打在物体表面还是从物体内部穿出来。</p>
<p>变量 f 为物体颜色。</p>
<ol>
<li>俄罗斯轮盘赌，决定光线追踪是否结束</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double p &#x3D; f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; &#x2F;&#x2F; max refl</span><br><span class="line">if (++depth&gt;5) if (erand48(Xi)&lt;p) f&#x3D;f*(1&#x2F;p); else return obj.e; &#x2F;&#x2F;R.R.</span><br></pre></td></tr></table></figure>
<p>变量 p 是取当前物体颜色三个分量中的最大值。</p>
<p>只有在深度大于5之后，才进行俄罗斯轮盘赌。</p>
<ol>
<li>计算漫反射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (obj.refl &#x3D;&#x3D; DIFF)&#123;                  &#x2F;&#x2F; Ideal DIFFUSE reflection</span><br><span class="line">    double r1&#x3D;2*M_PI*erand48(Xi), r2&#x3D;erand48(Xi), r2s&#x3D;sqrt(r2);</span><br><span class="line">    Vec w&#x3D;nl, u&#x3D;((fabs(w.x)&gt;.1?Vec(0,1):Vec(1))%w).norm(), v&#x3D;w%u;</span><br><span class="line">    Vec d &#x3D; (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1-r2)).norm();</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,d),depth,Xi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 r1 是随机抽样半球散射光线中一条的角度，变量 r2 和 r2s 是一个距离中心点的随机长度。</p>
<p>变量 w 和 u 和 v 则分别是局部坐标系的三个轴。变量 w 取朝向法线的方向。变量 u 根据变量 w 的 x 轴分量来决定是以哪个垂直轴来做叉乘变量 w ，这样子使得叉乘结果更好（感觉没啥用）。变量 v 则是另外两个轴叉乘得到。</p>
<p>变量 d 是求出随机抽样半球散射光线中一条光线的方向。由于局部坐标系是通过世界坐标系的朝向法线建立起来的，那么分别求出光线在各个方向的分量之后，合起来的结果便是该光线在世界坐标系上的坐标。</p>
<p><code>w*sqrt(1-r2)</code> 中的 <code>1-r2</code> 这个随机值是因为 z 轴跟 xy 轴不同，随着角度增大， z 轴的值是减少的。</p>
<p>这篇<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/148759248">文章</a>解释了变量 r2s 的定义。</p>
<p>使用了概率密度函数的概念。</p>
<p>返回结果则是继续递归。</p>
<ol>
<li>计算镜面反射</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (obj.refl &#x3D;&#x3D; SPEC)            &#x2F;&#x2F; Ideal SPECULAR reflection</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,r.d-n*2*n.dot(r.d)),depth,Xi));</span><br></pre></td></tr></table></figure>
<p>镜面反射就一句代码。</p>
<p>与漫反射不同之处在于镜面反射之后的光线方向由 <code>r.d-n*2*n.dot(r.d)</code> 求得。</p>
<p align="center">
    <img src="https://z3.ax1x.com/2021/08/09/f85BfP.png" width="95%">
    <br />    <small>  </small>
</p>

<ol>
<li>计算折射（同样包含反射）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ray reflRay(x, r.d-n*2*n.dot(r.d));     &#x2F;&#x2F; Ideal dielectric REFRACTION</span><br><span class="line">bool into &#x3D; n.dot(nl)&gt;0;                &#x2F;&#x2F; Ray from outside going in?</span><br><span class="line">double nc&#x3D;1, nt&#x3D;1.5, nnt&#x3D;into?nc&#x2F;nt:nt&#x2F;nc, ddn&#x3D;r.d.dot(nl), cos2t;</span><br><span class="line">if ((cos2t&#x3D;1-nnt*nnt*(1-ddn*ddn))&lt;0)    &#x2F;&#x2F; Total internal reflection</span><br><span class="line">    return obj.e + f.mult(radiance(reflRay,depth,Xi));</span><br><span class="line">Vec tdir &#x3D; (r.d*nnt - n*((into?1:-1)*(ddn*nnt+sqrt(cos2t)))).norm();</span><br><span class="line">double a&#x3D;nt-nc, b&#x3D;nt+nc, R0&#x3D;a*a&#x2F;(b*b), c &#x3D; 1-(into?-ddn:tdir.dot(n));</span><br><span class="line">double Re&#x3D;R0+(1-R0)*c*c*c*c*c,Tr&#x3D;1-Re,P&#x3D;.25+.5*Re,RP&#x3D;Re&#x2F;P,TP&#x3D;Tr&#x2F;(1-P);</span><br><span class="line">return obj.e + f.mult(depth&gt;2 ? (erand48(Xi)&lt;P ?   &#x2F;&#x2F; Russian roulette</span><br><span class="line">    radiance(reflRay,depth,Xi)*RP:radiance(Ray(x,tdir),depth,Xi)*TP) :</span><br><span class="line">    radiance(reflRay,depth,Xi)*Re+radiance(Ray(x,tdir),depth,Xi)*Tr);</span><br></pre></td></tr></table></figure>
<p>玻璃材质的物体既有折射也有反射，根据全反射原理，有可能会出现完全反射的情况。所以，先进行反射计算，然后再进行折射计算。</p>
<p>变量 reflRay 为反射方向光线。</p>
<p>变量 into 判定光线是从外部进入物体，还是从物体内部照射出来。</p>
<p>变量 nc 为空气介质密度，变量 nt 为物体介质密度。变量 nnt 则为折射率，变量 ddn 为光线方向与朝向法线角度的余弦值。</p>
<p>表达式 <code>(cos2t=1-nnt*nnt*(1-ddn*ddn))&lt;0</code> 判断是否全反射。如果满足全反射，则不用计算折射，直接返回反射递归调用。</p>
<p>接下来计算折射部分。</p>
<p>变量 tdir 为 折射光方向。</p>
<p align="center">
    <img src="https://img-blog.csdnimg.cn/20200824003230970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2cxMWQxMTE=,size_16,color_FFFFFF,t_70#pic_center" width="95%">
    <br />    <small>  </small>
</p>

<p>接下来使用菲涅尔项来计算校准之后的折射光的反射比。</p>
<p>变量 Re 为折射光的菲涅尔项。</p>
<p>最后，再进行一次俄罗斯轮盘赌，变量 RP 是产生菲涅尔项效果的概率，变量 TP 是不产生菲涅尔项效果的概率。当深度大于2时，启动俄罗斯轮盘赌，判断为真则启用反射计算（叠加菲涅尔项），判断为假则进行折射计算（叠加对立比例）。当深度小于2时，则是反射和折射两者的叠加效果计算（当然没有俄罗斯轮盘赌）。</p>
<ol>
<li>其他</li>
</ol>
<p>可以看到，在每个 return 语句上，都是当前相交点的物体的辐射值加上物体颜色乘以下一次光线追踪返回结果的值。这样子一直递归到最后一层，这样子反递归的时候，就会将源头的结果叠加回来。</p>


                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                        

<a href="/tags/Ray-Tracing/">#Ray Tracing</a>


                                            
                                </div>
                                <div class="post-date">
                                    
                                        2021-09-03
                                    
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    

<!-- TOC -->

    <aside id="article-toc" role="navigation" class="fixed">
        <div id="article-toc-inner">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-text">一、特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81"><span class="toc-text">二、源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%94%A8%E6%B3%95"><span class="toc-text">三、用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%86%E8%8A%82"><span class="toc-text">四、细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%A9%E5%B1%95"><span class="toc-text">五、扩展</span></a></li></ol>
        </div>
    </aside>

    <!-- Scripts -->
    <script type="text/javascript">
    console.log("© chaguake 🙋 2021-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    

    <!-- Service Worker -->
    <!-- if using service worker -->

    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>