<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="解衣又作茶瓜客，倚槛同看烟雨峰">
    

    <!--Author-->
    
        <meta name="author" content="茶瓜客">
    

    <!-- Title -->
    
    <title>RayMarching And SDF | 茶瓜客</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="茶瓜客" type="application/atom+xml">
</head>

<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                RayMarching And SDF
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <p>《Ray Marching and Signed Distance Functions》的译文。</p>
<span id="more"></span>
<p><a target="_blank" rel="noopener" href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/">原文</a></p>
<h2 id="Signed-Distance-Functions"><a href="#Signed-Distance-Functions" class="headerlink" title="Signed Distance Functions"></a>Signed Distance Functions</h2><p>SDF，符号距离函数，用于计算点和平面的位置关系，根据返回值的符号，来判断点是在平面内部还是外部。</p>
<p>（原文这里使用了一个圆心在原点、半径为1的球体做示例。）</p>
<p>对一些常见的3D物体的SDF函数，参见<a target="_blank" rel="noopener" href="https://iquilezles.org/www/articles/distfunctions/distfunctions.htm">Modeling with Distance Functions</a>。</p>
<h2 id="The-Raymarching-Algorithm"><a href="#The-Raymarching-Algorithm" class="headerlink" title="The Raymarching Algorithm"></a>The Raymarching Algorithm</h2><p>与光线跟踪一样，我们为相机选择一个位置，在其前面放置一个网格，通过网格中的每个点从相机发送光线，每个网格点对应于输出图像中的一个像素。</p>
<p align="center">
    <img src="http://jamie-wong.com/images/16-07-11/raytrace.png" width="95%">
    <br />    <small> From "Ray tracing" on Wikipedia </small>
</p>

<p>在光线跟踪中，整个场景是根据有符号距离函数定义的。使用SDF可以快速而安全地让光线前进最大步伐（maximum step），直至物体表面（surface）。</p>
<p>如图，$p_0$ 是摄像机。蓝色线段是从摄像机穿过视图平面的光线。</p>
<p align="center">
    <img src="http://jamie-wong.com/images/16-07-11/spheretrace.jpg" width="95%">
    <br />    <small> From [GPU Gems 2: Chapter 8.](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-8-pixel-displacement-mapping-distance-functions) </small>
</p>

<p>在GLSL的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">float depth &#x3D; start;</span><br><span class="line">for (int i &#x3D; 0; i &lt; MAX_MARCHING_STEPS; i++) &#123;</span><br><span class="line">    float dist &#x3D; sceneSDF(eye + depth * viewRayDirection);</span><br><span class="line">    if (dist &lt; EPSILON) &#123;</span><br><span class="line">        &#x2F;&#x2F; We&#39;re inside the scene surface!</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Move along the view ray</span><br><span class="line">    depth +&#x3D; dist;</span><br><span class="line"></span><br><span class="line">    if (depth &gt;&#x3D; end) &#123;</span><br><span class="line">        &#x2F;&#x2F; Gone too far; give up</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return end;</span><br></pre></td></tr></table></figure>
<p>其实就是每次前进当前光点与球表面的距离，知道值小于0.001。</p>
<p>shadertoy：<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/llt3R4">Ray Marching: Part 1</a>。</p>
<h2 id="Surface-Normals-and-Lighting"><a href="#Surface-Normals-and-Lighting" class="headerlink" title="Surface Normals and Lighting"></a>Surface Normals and Lighting</h2><p>计算机图形学中的大多数照明模型都使用曲面法线的一些概念来计算曲面上给定点处材质的颜色。当曲面由显式几何体（如多边形）定义时，通常会为每个顶点指定法线，并且可以通过插值周围顶点法线找到面上任何给定点的法线。</p>
<p>在使用SDF时，用梯度（gradient）来定义曲面法线。在点 $(x,y,z)$ 上的梯度函数 $f$ ，表示的是沿着某个方向，使得移动点 $(x,y,z)$ 变化最快的值。</p>
<p>$f(x,y,z)$ 的梯度写作 $\nabla f$ 。</p>
<script type="math/tex; mode=display">
\nabla f =
\left(
\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}
\right)</script><p>但是没有必要在这里进行微积分运算。我们将通过采样曲面上点周围的点来进行近似，而不是取函数的实导数，这很像在学习如何进行导数之前，如何计算函数中的斜率。</p>
<script type="math/tex; mode=display">
\overset{\to}{n}  = \begin{bmatrix}
f(x + \varepsilon,y,z) - f(x - \varepsilon,y,z) \\
f(x ,y+ \varepsilon,z) - f(x,y - \varepsilon,z) \\
f(x ,y,z+ \varepsilon) - f(x ,y,z- \varepsilon) 
\end{bmatrix}</script><p>GLSL的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Using the gradient of the SDF, estimate the normal on the surface at point p.</span><br><span class="line"> *&#x2F;</span><br><span class="line">vec3 estimateNormal(vec3 p) &#123;</span><br><span class="line">    return normalize(vec3(</span><br><span class="line">        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),</span><br><span class="line">        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),</span><br><span class="line">        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shadertoy：<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/lt33z7">Ray Marching: Part 2</a>。</p>
<h2 id="Moving-the-Camera"><a href="#Moving-the-Camera" class="headerlink" title="Moving the Camera"></a>Moving the Camera</h2><p>在GLSL中，实现类似gluLookAt函数的功能，提供一个变换矩阵。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Return a transformation matrix that will transform a ray from view space</span><br><span class="line"> * to world coordinates, given the eye point, the camera target, and an up vector.</span><br><span class="line"> *</span><br><span class="line"> * This assumes that the center of the camera is aligned with the negative z axis in</span><br><span class="line"> * view space when calculating the ray marching direction.</span><br><span class="line"> *&#x2F;</span><br><span class="line">mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) &#123;</span><br><span class="line">	vec3 f &#x3D; normalize(center - eye);</span><br><span class="line">	vec3 s &#x3D; normalize(cross(f, up));</span><br><span class="line">	vec3 u &#x3D; cross(s, f);</span><br><span class="line">	return mat4(</span><br><span class="line">		vec4(s, 0.0),</span><br><span class="line">		vec4(u, 0.0),</span><br><span class="line">		vec4(-f, 0.0),</span><br><span class="line">		vec4(0.0, 0.0, 0.0, 1)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shadertoy：<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/Xtd3z7">Ray Marching: Part 3</a>。</p>
<h2 id="Constructive-Solid-Geometry"><a href="#Constructive-Solid-Geometry" class="headerlink" title="Constructive Solid Geometry"></a>Constructive Solid Geometry</h2><p>CSG，构建实体几何，使用简单几何体通过集合运算得到的复杂几何体。集合运算有交集（intersection）、并集（union）以及差集（difference）。</p>
<p align="center">
    <img src="http://jamie-wong.com/images/16-07-11/csg.png" width="95%">
    <br />    <small> From "Constructive solid geometry" on Wikipedia </small>
</p>

<p>当组合表示为SDF的两个曲面时，这些操作都可以简洁地表达。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float intersectSDF(float distA, float distB) &#123;</span><br><span class="line">    return max(distA, distB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float unionSDF(float distA, float distB) &#123;</span><br><span class="line">    return min(distA, distB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float differenceSDF(float distA, float distB) &#123;</span><br><span class="line">    return max(distA, -distB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几何体组合函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line">    float cubeDist &#x3D; cubeSDF(samplePoint) * 1.2;</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shadertoy：<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/MttGz7">Ray Marching: Part 4</a>。</p>
<h2 id="Model-Transformations"><a href="#Model-Transformations" class="headerlink" title="Model Transformations"></a>Model Transformations</h2><p><strong>Rotation and Translation</strong></p>
<p>对一个SDF表面进行平移或变换，可以在计算SDF之前对这个点进行逆变换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line">    float cubeDist &#x3D; cubeSDF(samplePoint + vec3(0.0, sin(iGlobalTime), 0.0));</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shadertoy：<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/XtcGWn">Ray Marching: Part 5</a>。</p>
<p>进一步来说，添加一个旋转矩阵：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mat4 rotateY(float theta) &#123;</span><br><span class="line">    float c &#x3D; cos(theta);</span><br><span class="line">    float s &#x3D; sin(theta);</span><br><span class="line"></span><br><span class="line">    return mat4(</span><br><span class="line">        vec4(c, 0, s, 0),</span><br><span class="line">        vec4(0, 1, 0, 0),</span><br><span class="line">        vec4(-s, 0, c, 0),</span><br><span class="line">        vec4(0, 0, 0, 1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line"></span><br><span class="line">    vec3 cubePoint &#x3D; (invert(rotateY(iGlobalTime)) * vec4(samplePoint, 1.0)).xyz;</span><br><span class="line"></span><br><span class="line">    float cubeDist &#x3D; cubeSDF(cubePoint);</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用到sceneSDF函数就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line"></span><br><span class="line">    vec3 cubePoint &#x3D; (rotateY(-iGlobalTime) * vec4(samplePoint, 1.0)).xyz;</span><br><span class="line"></span><br><span class="line">    float cubeDist &#x3D; cubeSDF(cubePoint);</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Uniform Scaling</strong></p>
<p>缩放会改变两点之间的距离，引起距离场失真。</p>
<p>所以在缩放之后的点，经过SDF判断之后，需要对结果进行校准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float dist &#x3D; someSDF(samplePoint &#x2F; scalingFactor) * scalingFactor;</span><br></pre></td></tr></table></figure>
<p><strong>Non-uniform scaling and beyond</strong></p>
<p>首先计算下不均匀变换时导致的失真值：</p>
<script type="math/tex; mode=display">
sphereSDF(x,y,z) = \sqrt{(2x)^2 + y ^2 +z^2} - 1</script><p>经过变换之后，可以乘以他们之间最小值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float dist &#x3D; someSDF(samplePoint &#x2F; vec3(s_x, s_y, s_z)) * min(s_x, min(s_y, s_z));</span><br></pre></td></tr></table></figure>
<p>shadertoy：<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/4tcGDr">Ray Marching: Part 6</a>。</p>


                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                        

<a href="/tags/SDF/">#SDF</a>


                                            
                                </div>
                                <div class="post-date">
                                    
                                        2021-09-07
                                    
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    

<!-- TOC -->

    <aside id="article-toc" role="navigation" class="fixed">
        <div id="article-toc-inner">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Signed-Distance-Functions"><span class="toc-text">Signed Distance Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Raymarching-Algorithm"><span class="toc-text">The Raymarching Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Surface-Normals-and-Lighting"><span class="toc-text">Surface Normals and Lighting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Moving-the-Camera"><span class="toc-text">Moving the Camera</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Constructive-Solid-Geometry"><span class="toc-text">Constructive Solid Geometry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-Transformations"><span class="toc-text">Model Transformations</span></a></li></ol>
        </div>
    </aside>

    <!-- Scripts -->
    <script type="text/javascript">
    console.log("© zchen9 🙋 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    

    <!-- Service Worker -->
    <!-- if using service worker -->

    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>