<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶瓜客</title>
  
  <subtitle>解衣又作茶瓜客，倚槛同看烟雨峰</subtitle>
  <link href="https://www.chaguake.com/atom.xml" rel="self"/>
  
  <link href="https://www.chaguake.com/"/>
  <updated>2021-04-09T09:22:45.559Z</updated>
  <id>https://www.chaguake.com/</id>
  
  <author>
    <name>茶瓜客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C/C++如何获取不定数量的输入参数？</title>
    <link href="https://www.chaguake.com/2021/04/09/C-knowledge-cin/"/>
    <id>https://www.chaguake.com/2021/04/09/C-knowledge-cin/</id>
    <published>2021-04-09T09:15:26.000Z</published>
    <updated>2021-04-09T09:22:45.559Z</updated>
    
    <content type="html"><![CDATA[<p>刷题时偶尔会出现输入不定数量的参数，主要是使用<code>std::cin</code>来实现。</p><p>使用<code>Ctrl Z</code>（Windows）或<code>Ctrl D</code>（UNIX）结束输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">int value;</span><br><span class="line">while(std::cin&gt;&gt;value)&#123;</span><br><span class="line">    vec.push_back(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回车结束输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">int value;</span><br><span class="line">while(std::cin&gt;&gt;value)&#123;</span><br><span class="line">    vec.push_back(value);</span><br><span class="line">    if(std::cin.get() &#x3D;&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刷题时偶尔会出现输入不定数量的参数，主要是使用&lt;code&gt;std::cin&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Ctrl Z&lt;/code&gt;（Windows）或&lt;code&gt;Ctrl D&lt;/code&gt;（UNIX）结束输入：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.chaguake.com/categories/C-C/"/>
    
    
    <category term="C/C++知识" scheme="https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP对接异常——Server端宕机</title>
    <link href="https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/"/>
    <id>https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/</id>
    <published>2021-04-08T00:42:22.000Z</published>
    <updated>2021-04-09T08:51:45.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。</p><p>Server端使用boost的asio库，性能应该有保障的。</p><p>首先，查看日志，排查对应代码片段，未发现有出现”死锁“的逻辑，只能从wireshark抓包分析了。</p><p>现场同事把抓包发回一看，好家伙，一堆的”TCP ZeroWindow”和”RST“！</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>1、统计一下http请求情况，</p><p><img src="./http_statistic.jpg" alt="Http统计"></p><p>才三百多次http请求，远远没达到正常水平，排除Server端处理瓶颈问题。</p><p>2、输入筛选条件<code>tcp.flags.syn</code>，看看tcp三次握手情况。</p><p><img src="./syn.jpg" alt="syn统计"></p><p>Client新连接都直接被Server端拒绝了，Server端的连接数已经达到了极限。</p><p>而Server端在处理完http请求之后都会断开当前连接，并非长连接模式。并且，根据Server端的http处理耗时来看，还算正常。</p><p>问题估计在已建立但是未正常关闭的连接上，粗略看下，基本都会出现”TCP ZeroWindow“标记。</p><p>3、随机追踪一条出现”TCP ZeroWindow“的tcp连接，</p><p><img src="./tcp_zerowindow.jpg" alt="tcp zerowindow"></p><p>统计了下，出现这情况的连接大概有两百条，那就有可能出现同时并发的连接数大于<code>CPU数量*2+1</code>的情况。</p><p>而且，100个tcp包就出现滑动窗口占满的情况是不可能的，问题肯定出现在这里了。</p><p>经过排查，终于发现问题所在：</p><p><img src="./problem.jpg" alt="问题所在"></p><p>如上图，Server端最后回复给Client端包中，<code>Win</code>的值为5632，表示Server端还能接收5632个包。</p><p>并且<code>Ack</code>值为126929，希望Client下一个包的<code>Seq</code>序号值从126929开始。果不其然，Client端紧接着的包中<code>Seq</code>序号值为126929。</p><p>看Server端回复“TCP ZeroWindow”包的前一个由Client端发出的包LAST，它的<code>Seq</code>值为131273。</p><p>不难看出，<code>131273 - 126929 = 4344 &lt; 5632</code>，这时还可以正常接收。</p><p>但是展开那个包LAST中的<code>Next Seq</code>值是132609，<code>132609 - 126929 = 5680 &gt; 5632</code>，已经超出<code>Win</code>大小，所以，Server端接收到包LAST之后就返回“TCP ZeroWindow”包。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>1、Client端更改<code>Seq</code>的生成规则，使得<code>Seq</code>自增步长减少。</p><p>抓包中可以看出，Client端<code>Seq</code>的自增步长是1448。</p><p>2、Server端将滑动窗口变大。</p><p>由于Client端会发送<code>PSH</code>包通知Srever端清空缓冲，那么Server端可以将滑动窗口变大，避免出现“TCP ZeroWindow”情况。</p><p>3、优化Srever端“接收请求-&gt;回复请求”的耗时，避免同时出现异常连接并发数大于<code>CPU数量*2+1</code>的情况。</p><p>这种方法依旧是没办法解决问题所在的，只是尽量避免宕机情况出现。</p><p>4、Server端添加tcp连接的timeout处理。</p><p>Server端主动关闭超过timeout时间没有接收到http请求的连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。&lt;/p&gt;
&lt;p&gt;Server端</summary>
      
    
    
    
    <category term="问题排查" scheme="https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="问题排查之TCP" scheme="https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手</title>
    <link href="https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/"/>
    <id>https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/</id>
    <published>2021-04-07T02:13:50.000Z</published>
    <updated>2021-04-07T07:03:49.700Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。</p><p>参考文献有：</p><p><a href="https://segmentfault.com/a/1190000021740112">TCP三次握手、四次挥手出现意外情况时，为保证稳定，是如何处理的？</a></p><p><a href="https://yuanrengu.com/2020/77eef79f.html">面试官，不要再问我三次握手和四次挥手</a></p><h1 id="三次握手正常流程"><a href="#三次握手正常流程" class="headerlink" title="三次握手正常流程"></a>三次握手正常流程</h1><p>三次是TCP建立连接的最小次数，因为在三次握手中，双方都经历了”请求-&gt;应答“的过程。</p><p><img src="https://image-static.segmentfault.com/106/870/1068704971-3084b02c4479b0c7_fix732" alt="三次握手状态流程图"></p><p>三次握手流程步骤：</p><ol><li><p>在初始时，双端处于<code>CLOSE</code>状态，服务端(Server)为了提供服务，会主动监听某个端口，进入<code>LISTEN</code>状态。</p></li><li><p>客户端(Client)主动发送连接的<code>SYN</code>包，之后进入<code>SYN-SENT</code>状态，服务端在收到客户端发来的<code>SYN</code>包后，回复<code>SYN,ACK</code>包，之后进入<code>SYN-RCVD</code>状态。</p></li><li><p>客户端收到服务端发来的<code>SYN,ACK</code>包后，可以确认对方存在，此时回复<code>ACK</code>包，并进入<code>ESTABLISHED</code>状态。</p></li><li><p>服务端收到最后一个<code>ACK</code>包后，也进入<code>ESTABLISHED</code>状态。</p></li></ol><p>三次握手重点是客户端和服务端的状态变化过程，比如：客户端在发送第三个<code>ACK</code>包的时候，状态就会变更成<code>ESTABLISHED</code>，而服务端需要在接收到客户端发出的第三个<code>ACK</code>包的时候，才将状态转换成<code>ESTABLISHED</code>。</p><h1 id="三次握手异常情况"><a href="#三次握手异常情况" class="headerlink" title="三次握手异常情况"></a>三次握手异常情况</h1><p>计算机网络的异常处理有时比正常处理得流程更为重要，毕竟，需要花费更大的消耗去判断是网络故障还是连接异常。</p><p><strong>1. <code>SYN</code>包丢失</strong></p><p>对于服务端，客户端还是”不存在的“。</p><p>对于客户端，无法清楚服务端是否接收到<code>SYN</code>包，所以客户端会进行重传<code>SYN</code>包的操作，一般重传三次，三次加起来大约是76s（采用指数退避算法）。</p><p>在代码层次上，客户端会阻塞在<code>connect</code>函数上，失败会返回异常信息。</p><p>可通过更改系统配置（<a href="https://blog.csdn.net/chenyulancn/article/details/16339427">Linux点击这里</a>、<a href="https://blog.csdn.net/niejiangshuai/article/details/86573338">Windows点击这里</a>）来实现配置重连次数和重连耗时。</p><p>也可以通过”ioctl(1)+select(timeout)“方式来间接实现连接超时控制。<a href="https://blog.csdn.net/czh8706/article/details/84931785">TCP/IP Connect时间自主设定</a></p><p><strong>2. <code>SYN+ACK</code>包丢失</strong></p><p>对于客户端，跟<code>SYN</code>包丢失的处理流程是一样的。</p><p>对于服务端，会触发重传操作，毕竟无法确定客户端是否收到<code>SYN+ACK</code>包，此时服务端的状态是<code>SYN_RCVD</code>。</p><p>当超过重传次数之后，服务端系统会发送<code>RST</code>包。</p><p><strong>3. <code>ACK</code>包丢失</strong></p><p>对于服务端，跟<code>SYN+ACK</code>包丢失的处理流程是一样的，处于<code>SYN-RCVD</code>状态。</p><p>对于客户端，<code>connect</code>函数已经正常返回，客户端已经进入<code>ESTABLISHED</code>状态，可以发送/接收数据了。</p><p>现在，服务端和客户端的状态不对等，那么客户端发给服务端的数据会怎么处理呢？</p><p>结合<a href="https://blog.csdn.net/zerooffdate/article/details/79359726">文章</a>来看，假如客户端发送的第一个数据包的<code>Seq</code>确认序号跟<code>ACK</code>包的<code>Seq</code>确认序号一样，那么，服务端将进入<code>ESTABLISHED</code>状态，正常连接。假如不一样，服务端会发送<code>RST</code>包，结束该连接。而在代码实现中，<code>connect</code>函数是在客户端回复<code>ACK</code>包之后就返回了，这时三次握手还没完成。</p><p>所以，可以在<code>conenct</code>函数返回之后，立即发送一个跟<code>ACK</code>包相同<code>Seq</code>确认序号的数据包（默认第一个数据包的<code>Seq</code>是跟<code>ACK</code>一样），哪怕服务端没有接收到<code>ACK</code>包，也可以正常进入<code>ESTABLISHED</code>状态。并且也可以验证连接是否成功，假如服务端返回<code>RST</code>包，则连接失败。</p><p>应用层上，使用select、poll或者epoll机制判断socket是否可写来确认连接是否已经建立。<a href="https://blog.csdn.net/ruixj/article/details/1756440">非阻塞socket 的连接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。&lt;/p&gt;
&lt;p&gt;参考文献有：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/119000002174</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="https://www.chaguake.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Reservoir Sampling 抽样算法</title>
    <link href="https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/"/>
    <id>https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/</id>
    <published>2021-04-04T16:20:31.000Z</published>
    <updated>2021-04-06T08:23:01.651Z</updated>
    
    <content type="html"><![CDATA[<p>“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。</p><p>但是，当m不是确定值呢？</p><p>可以使用Reservoir Sampling 抽样算法。</p><p>由于m是不确定的，那么使用[0,m]范围内随机产生数的方式就没办法使用。所以，需要设计一种方法，使得每个数被抽取的概率都是$\frac{n}{m}$。</p><h1 id="一、”每次都是-frac-1-i-”问题"><a href="#一、”每次都是-frac-1-i-”问题" class="headerlink" title="一、”每次都是 $\frac{1}{i}$”问题"></a>一、”每次都是 $\frac{1}{i}$”问题</h1><p><em>对于<code>n</code>(n&gt;=1)，如果每次（基数<code>k</code>从0到n递增）以$\frac{1}{i}$的概率决定是否替换选中元素直到<code>n</code>，那么最后每个元素被选中的概率相等，即为$\frac{1}{n}。$ </em></p><p>证明：</p><ul><li><p>假设最后被选中的元素<code>a</code>(a&lt;=n)，它是在第<code>k</code>(k&lt;=n)次被选中。也就是说在第<code>k</code>次之后都不会有元素被选中，这样子才能确保最后选中的元素是<code>a</code>。</p></li><li><p>那么它被选中的概率等于第<code>k</code>次被选中的概率*第<code>k</code>次以后都没有元素选中。</p></li></ul><script type="math/tex; mode=display">\frac{1}{k} × \frac{k}{k+1} × \frac{k+1}{k+2} × ··· × \frac{n-1}{n} = \frac{1}{n}</script><p>可以得到结论：在未知样本空间<code>n</code>中，随机抽取一个数<code>a</code>，它的概率是$\frac{1}{n}$。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Sampling(std::vector&lt;int&gt; &amp;vec, int &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; 1; i &lt; vec.size(); i++)&#123;</span><br><span class="line">int random &#x3D; rand() % i;</span><br><span class="line">num &#x3D; vec[random];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、如何从未知样本空间m随机抽取n个数"><a href="#二、如何从未知样本空间m随机抽取n个数" class="headerlink" title="二、如何从未知样本空间m随机抽取n个数"></a>二、如何从未知样本空间m随机抽取n个数</h1><p>假如按照第一点中的方法，抽取n个数。的确也是能实现$\frac{n}{m}$的概率，但是要遍历n次，时间复杂度就顶不住了。</p><p>换个角度，假设，先取出前n个元素组成一个集合N，把第n+1个元素放进集合N，从集合N中抽取n个元素重新组成集合N，直至最后一个元素。</p><p>也就是说，第n+1个元素随机替换集合N中的一个元素。下面证明最后得出的集合N中，每个元素的概率是$\frac{n}{m}$。</p><p>证明：</p><ul><li><p>假设集合N中的任意一个元素<code>a</code>，它是第<code>k</code>(n&lt;=k&lt;=m)次被放进集合N，它最后留在集合N的概率 = 在它后面的元素都没有被抽中的概率 + 在它后面的元素被抽中的概率 * 没有替换元素<code>a</code>的概率。</p></li><li><p>根据第一点中的方法，第<code>k</code>(k&gt;=n)次某元素被选中并替换到集合N的概率是$\frac{1}{k} × n = \frac{n}{k}$。</p></li></ul><script type="math/tex; mode=display">\frac{n}{k} × (\frac{k+1-n}{k+1} + \frac{n}{k+1} × \frac{n-1}{n}) × (\frac{k+2-n}{k+2} + \frac{n}{k+2} × \frac{n-1}{n}) × ··· × \frac{m-n}{m} + \frac{n}{m} × \frac{n-1}{n}= \frac{n}{k} × \frac{k}{k+1} × \frac{k+1}{k+2} × ··· × \frac{m-1}{m} = \frac{n}{m}</script><p>证明成立，这个实现就是蓄水池抽样算法（Reservoir Sampling）。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ReservoirSampling(std::vector&lt;int&gt; &amp;vec,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; n; i &lt; vec.size(); i++) &#123;</span><br><span class="line">int random &#x3D; rand() % i;</span><br><span class="line">if(random &lt; n)&#123;</span><br><span class="line">    std::swap(vec[random], vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;up-low&gt;n</span><br><span class="line">void ReservoirSampling(std::vector&lt;int&gt; &amp;vec, int n, int low, int up)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; low + n; i &lt; up; i++) &#123;</span><br><span class="line">int random &#x3D; rand() % (up - low) + low;</span><br><span class="line">if (random &lt; low + n) &#123;</span><br><span class="line">    std::swap(vec[random], vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Reservoir Sampling 抽样算法的空间复杂度$O(1)$，时间复杂度$O(n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。&lt;/p&gt;
&lt;p&gt;但是，当m不是确定值呢？&lt;/p&gt;
&lt;p&gt;可以使用Reservoir Sampling 抽样算法。&lt;/p&gt;
&lt;p&gt;由于m是不确定的，那么使用</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="抽样算法" scheme="https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fisher Yates 洗牌算法</title>
    <link href="https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/"/>
    <id>https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/</id>
    <published>2021-04-02T06:29:14.000Z</published>
    <updated>2021-04-06T08:20:16.075Z</updated>
    
    <content type="html"><![CDATA[<p>洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。</p><h1 id="不加权模式"><a href="#不加权模式" class="headerlink" title="不加权模式"></a>不加权模式</h1><p>Fisher Yates洗牌算法凭借着$O(1)$空间、$O(n)$时间复杂度，实现了“在n个不同的数中随机取出m个数”一类的问题。</p><p>实现大致是将从未抽取集合中随机抽中的数x与未抽取集合中的最后一个数交换，未抽取集合个数-1。不断重复，直至未抽取集合个数为0。</p><p>实现细节：</p><ul><li><p>已知原始数组长度为n，将原始数组分为未抽取数组（长度为n）和取出数组（长度为0）。</p></li><li><p>在未抽取数组中，<strong>随机</strong>（算法依赖这个’随机‘是否够随机）选中一个数p，将数p的位置与原始数组最后一位（首位也行）交换。</p></li><li><p>重复上一个步骤，直到未抽取数组的个数为0。</p></li></ul><p><em>有点像选择排序，差异在于每次在’未排序‘区中找的不是最小（或最大）的，而是随机选一个。</em></p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void shuffle(int *arr,int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; nLen - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        int num &#x3D; rand() % i;</span><br><span class="line">        std::swap(arr[i], arr[num]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法脱离数学是不讲武德的，下面就证明：集合set有n个不同的数字，第i次抽取到的数字p的概率是否是都是$\frac{1}{n}$ 。</p><ul><li><p>第i次才抽中数字p，那么前i-1次都是没抽到数字p的。</p></li><li><p>第一次抽取，没抽到数字p的概率是$\frac{n-1}{n}$。</p></li><li><p>第二次抽取，没抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1}$。</p></li></ul><p>……</p><ul><li><p>第i-1次抽取，没抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1} × ··· × \frac{n-i}{n-i+1}$。</p></li><li><p>第i次抽取，抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1} × ··· × \frac{n-i}{n-i+1} × \frac{1}{n-i} = \frac{1}{n}$。</p></li></ul><p>Fisher Yates洗牌算法有两个随机因子，一个是每一次从未抽取集合抽取的元素，另一个是每一次未抽取集合最后一个元素，但最关键是第一个随机因子。</p><p>假如为每个元素加上权重，使得每个元素本身被抽中的优先度不一样，又如何用Fisher Yates洗牌算法来实现呢？</p><h1 id="加权模式"><a href="#加权模式" class="headerlink" title="加权模式"></a>加权模式</h1><p>一个比较笨重的办法,将元素按照其权重展开:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;a:2,b:3,c:1&#125;</span><br><span class="line">&#123;a,a,b,b,b,c&#125;</span><br></pre></td></tr></table></figure><p>（但显然不是好办法。=_=）</p><p>因为有了权重作为附加条件，再按照上面”从未抽取集合中随机抽取一个元素“的方式是不满足条件的，必须将权重参与到运算中（随机抽取）。</p><p>那么，可以将所有权重值加起来，得到一个权重总数sum，然后在0到sum的范围内随机产生一个数num，再将num与未抽取集合中每一个元素作某种比较，最后输出随机数。</p><p>步骤如下：</p><ul><li><p>统计出所有元素的权重和sum。</p></li><li><p>在0到sum之间随机产生一个随机数num，遍历未抽取集合。</p></li><li><p>用随机数num和当前迭代元素n比较。假如num小于n，结束迭代，返回元素n（与最后一位元素交换），sum-=n，重复第二步；假如num大于n，则num-=n，继续迭代。</p></li><li><p>遍历到未抽取集合的最后一个元素时，如果num大于n，则输出最后一个元素，sum-=n。</p></li><li><p>重复第二步。</p></li></ul><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void shuffle2(int *arr, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; nLen; i++)&#123;</span><br><span class="line">sum +&#x3D; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123;</span><br><span class="line">int num &#x3D; rand() % sum;</span><br><span class="line">size_t j &#x3D; 0;</span><br><span class="line">for (; j &lt; i; j++)&#123;</span><br><span class="line">    if (num &gt; arr[j]) &#123;</span><br><span class="line">num -&#x3D; arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -&#x3D; arr[j];</span><br><span class="line">std::swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度还是$O(1)$，但时间复杂度是$O(n+n^2)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。&lt;/p&gt;
&lt;h1 id=&quot;不加权模式&quot;&gt;&lt;a href=&quot;#不加权模式&quot; class=&quot;headerlink&quot; title=&quot;不加权模式&quot;&gt;&lt;/a&gt;不加权模式&lt;/h1&gt;&lt;p&gt;F</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="洗牌算法" scheme="https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试知识点——C/C++基础知识</title>
    <link href="https://www.chaguake.com/2021/04/02/interview-knowledge-C-base/"/>
    <id>https://www.chaguake.com/2021/04/02/interview-knowledge-C-base/</id>
    <published>2021-04-02T01:52:14.000Z</published>
    <updated>2021-04-06T09:02:17.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、extern关键字的使用"><a href="#一、extern关键字的使用" class="headerlink" title="一、extern关键字的使用"></a>一、extern关键字的使用</h1><p><strong>1、外部变量声明，使得全局变量可跨文件使用。</strong></p><p>不同.cpp文件在编译时是独立的，需要添加<code>extern</code>关键字声明该变量是在外部（其他.cpp文件）定义。</p><p><strong>2、函数声明。</strong></p><p>可以使用<code>extern void fun();</code>来代替引用<code>#include *.h</code>的方式，去声明外部函数。</p><p><em>这里有个问题，网络上说单方面修改extern函数原型时编译器不会报错，但博主在VS2008和VS2017上是会报错的（编译成功，链接失败）。</em></p><p><strong>3、链接规范（extern “C”）。</strong></p><p>链接规范的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; void fun();</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    void fun1();</span><br><span class="line">    void fun2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++由于支持函数重载，在C++编译器工作时，会生成一个用于链接的中间函数名。</p><p>而C不支持函数重载，所以在C编译器工作时，生成的中间函数名只是简单的在函数名前加上一个下划线<code>_</code>。</p><p>在C++使用C函数时，会将C函数生成一个C++规则的中间函数名。这样子，在进行链接时，C编译生成的目标文件和C++编译生成的目标文件中的中间函数名就会不一样，导致链接失败。</p><p>所以，C++调用C的函数时，需要添加extern “C”来声明，按照C的规则编译C的函数。</p><p>而C调用C++的函数，除了使用extern “C”之外，还需要做一层包装函数（添加extern “C”为了生成C风格的中间函数名，添加包装函数为了支持重载）。</p><p><em>值得注意的是，不应该把头文件放在extern “C”的范围里，因为有可能会导致符号嵌套。</em></p><h1 id="二、placement-new"><a href="#二、placement-new" class="headerlink" title="二、placement new"></a>二、placement new</h1><p>当需要在一块已分配的内存上创建对象时，需要使用placement new。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr &#x3D; new(buff) A;</span><br></pre></td></tr></table></figure><p>使用强制转换的办法也可以在已分配的内存上创建对象，但是不会调用对象的构造函数，而且，有可能会有内存溢出的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr &#x3D; (A*)buff;</span><br></pre></td></tr></table></figure><h1 id="三、stdcall、cdecl和-fastcall三种函数调用协议"><a href="#三、stdcall、cdecl和-fastcall三种函数调用协议" class="headerlink" title="三、stdcall、cdecl和__fastcall三种函数调用协议"></a>三、<strong>stdcall、</strong>cdecl和__fastcall三种函数调用协议</h1><p>参见<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160">参数传递和命名约定</a>和<a href="https://www.cnblogs.com/yejianyong/p/7506465.html">C++知识回顾之<strong>stdcall、</strong>cdcel和__fastcall三者的区别</a></p><p><strong>1、协议常用场合</strong></p><ul><li><p>__stdcall：Windows API默认的函数调用协议。</p></li><li><p>__cdecl：C/C++默认的函数调用协议。</p></li><li><p>__fastcall：适用于对性能要求高的场合（只适用于X86架构，在ARM和X64体系架构的编译器会直接忽略该关键字）。</p></li></ul><p><strong>2、函数入栈方式</strong></p><ul><li><p>__stdcall：函数参数由右向左入栈。</p></li><li><p>__cdecl：函数参数由右向左入栈。</p></li><li><p>__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。</p></li></ul><p><strong>3、栈内数据清除方式</strong></p><ul><li><p>__stdcall：函数调用结束后由被调用函数清除栈内数据。</p></li><li><p>__cdecl：函数调用结束后由函数调用者清除栈内数据。</p></li><li><p>__fastcall：函数调用结束后由被调用函数清除栈内数据。</p></li></ul><p>注：</p><p>1)不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。</p><p>2)某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。</p><p>3)由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。</p><p><strong>4、C编译器函数名称修饰规则</strong></p><ul><li><p>__stdcall：编译后，函数名被修饰为“_functionname@number”（number为参数字节数）。</p></li><li><p>__cdecl：编译后，函数名被修饰为“_functionname”。</p></li><li><p>__fastcall：编译后，函数名给修饰为“@functionname@nmuber”（number为参数字节数）。</p></li></ul><p><strong>C++编译器函数名称修饰规则</strong></p><ul><li><p>__stdcall：编译后，函数名被修饰为“?functionname@@YG<strong>**</strong>@Z”。</p></li><li><p>__cdscl：编译后，函数名被修饰为“?functionname@@YA<strong>**</strong>@Z”。</p></li><li><p>__fastcall：编译后，函数名被修饰为“?functionname@@YI<strong>**</strong>@Z”。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、extern关键字的使用&quot;&gt;&lt;a href=&quot;#一、extern关键字的使用&quot; class=&quot;headerlink&quot; title=&quot;一、extern关键字的使用&quot;&gt;&lt;/a&gt;一、extern关键字的使用&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、外部变量声明，使得全局变</summary>
      
    
    
    
    <category term="面试" scheme="https://www.chaguake.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C/C++知识" scheme="https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（三）——生成三角形小结笔记</title>
    <link href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/"/>
    <id>https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/</id>
    <published>2021-03-31T10:50:43.000Z</published>
    <updated>2021-04-02T01:39:54.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl.com/Getting-started/Hello-Triangle">英文原文地址</a> <a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">中文翻译地址</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小结主要介绍了各类着色器的使用，特别是可编程的顶点着色器和片段着色器。</p><h4 id="一、图形渲染管线"><a href="#一、图形渲染管线" class="headerlink" title="一、图形渲染管线"></a>一、图形渲染管线</h4><p>图形渲染管线（简称管线）主要作用是将一堆物体的3D坐标转换成2D坐标输出，最后呈现在屏幕上。</p><p>管线接受一组3D坐标，然后通过几个串行的阶段处理（在GPU上并行处理），最终输出屏幕画面。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="管线每个阶段的抽象显示图"></p><p>如上图。每一个阶段称为着色器，其中。标有蓝色的着色器有顶点着色器、几何着色器和片段着色器。它们允许我们自定义编写着色器处理逻辑。</p><h4 id="二、各类着色器介绍"><a href="#二、各类着色器介绍" class="headerlink" title="二、各类着色器介绍"></a>二、各类着色器介绍</h4><p><strong>OpenGL着色器语言</strong></p><p>有些着色器允许自己设计，可以用OpenGL着色器语言（GLSL）编写。</p><p><strong>顶点着色器</strong></p><p>顶点着色器将用户输入的3D坐标转换成GLSL中的3D坐标，并且可以对顶点3D坐标做一些处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos.x, aPos.y, aPos.z, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GLSL中，3D坐标是一个有4个分量的向量，<code>x</code>、<code>y</code>、<code>z</code>、<code>w</code>，最后一个用于透视除法上。</p><p><strong>图元着色器</strong></p><p>图元着色器将顶点着色器的顶点输出作为输入，然后将所有的顶点装配成指定图元的形状。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><p><strong>几何着色器</strong></p><p>几何着色器可以将图元着色器输出的顶点构造出其它的图元形状。</p><p><strong>光栅化</strong></p><p>光栅化将图元映射成屏幕上的像素形状，即片段。</p><p><strong>片段着色器</strong></p><p>片段着色器计算每一个像素的颜色，它需要接收场景的数据（例如：光照、阴影等），综合计算出像素点的颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>片段着色器只有一个颜色输出变量。</p><p><strong>测试和混合</strong></p><p>当每个片段的颜色都确定之后，还需要检查每个片段之间的层级关系和透明度叠加之后的显示颜色。</p><h4 id="三、编译着色器"><a href="#三、编译着色器" class="headerlink" title="三、编译着色器"></a>三、编译着色器</h4><p>着色器代码需要在运行时动态编译，代码以字符串形式传递给OpenGL。</p><p>首先，得创建着色器对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p><code>glCreateShader</code>函数需要输入当前需要创建的着色器类型，GL_FRAGMENT_SHADER是片段着色器，GL_VERTEX_SHADER是顶点着色器。</p><p>下一步，需要将着色器源码附加到着色器对象上，并且编译它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p><code>glShaderSource</code>函数的第一个参数是着色器对象，第二个参数是着色器源码数量，第三个参数是着色器源码字符串数组首地址，第四个参数是着色器源码字符串长度数组首地址。</p><p>可以对着色器源码编译的结果检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int  success;</span><br><span class="line">char infoLog[512];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、着色器程序对象"><a href="#四、着色器程序对象" class="headerlink" title="四、着色器程序对象"></a>四、着色器程序对象</h4><p>着色器编译出来之后，需要将他们链接到同一个着色器程序对象上。</p><p>同样的，需要创建着色器程序对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int shaderProgram;</span><br><span class="line">shaderProgram &#x3D; glCreateProgram();</span><br></pre></td></tr></table></figure><p>下一步，把各个着色器附加到着色器程序对象上，然后进行链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>同样，也可以捕捉链接失败信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">if(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着色器对象链接到着色器程序对象之后，着色器对象就可以删除了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>当需要使用着色器程序时，调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>删除着色器程序，调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteProgram(shaderProgram);</span><br></pre></td></tr></table></figure><h4 id="五、顶点缓冲对象（Vertex-Buffer-Object，VBO）"><a href="#五、顶点缓冲对象（Vertex-Buffer-Object，VBO）" class="headerlink" title="五、顶点缓冲对象（Vertex Buffer Object，VBO）"></a>五、顶点缓冲对象（Vertex Buffer Object，VBO）</h4><p>顶点数据从内存发送到GPU是一件耗时费力的事情，所以尽可能一次性发送更多的数据到显卡上。</p><p>定点缓冲对象可包含顶点的多种属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">        &#x2F;&#x2F; positions          &#x2F;&#x2F; colors           &#x2F;&#x2F; texture coords</span><br><span class="line">         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, &#x2F;&#x2F; top right</span><br><span class="line">         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, &#x2F;&#x2F; bottom right</span><br><span class="line">        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, &#x2F;&#x2F; bottom left</span><br><span class="line">        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  &#x2F;&#x2F; top left </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>创建VBO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VBO;</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br></pre></td></tr></table></figure><p>绑定数据，但在此之前需要声明接下来绑定的数据是哪种类型的，应该把它绑定到哪种缓冲对象上：</p><p>因为要做顶点缓冲类型的数据绑定，所以用<code>GL_ARRAY_BUFFER</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);  </span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><code>glBufferData</code>函数第一个参数是目标缓冲类型，第二个参数是需绑定数据的大小，第三个参数是需绑定数据地址，第四个参数指定显卡如何管理当前绑定的数据。</p><ul><li><p>GL_STATIC_DRAW ：数据不会或几乎不会改变。</p></li><li><p>GL_DYNAMIC_DRAW ：数据会改变很多。</p></li><li><p>GL_STREAM_DRAW ：数据每次绘制时都会改变。</p></li></ul><p>根据值不同，需绑定数据会放在显卡不同的位置。</p><p>摧毁VBO对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteBuffers(1, &amp;VBO);</span><br></pre></td></tr></table></figure><h4 id="六、索引缓冲对象（Element-Buffer-Object，EBO或Index-Buffer-Object，IBO）"><a href="#六、索引缓冲对象（Element-Buffer-Object，EBO或Index-Buffer-Object，IBO）" class="headerlink" title="六、索引缓冲对象（Element Buffer Object，EBO或Index Buffer Object，IBO）"></a>六、索引缓冲对象（Element Buffer Object，EBO或Index Buffer Object，IBO）</h4><p>万物皆三角形。三角形可以说是3D图形最小的组成元素，毕竟三角形的三个顶点肯定在同一个平面上。</p><p>在绘制矩阵图形时，可以将矩阵分成两个三角形来绘制。但这样子，就会出现共同顶点，在VBO上则是重复存储，浪费开销。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f,  &#x2F;&#x2F; 左上角</span><br><span class="line">    &#x2F;&#x2F; 第二个三角形</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引缓冲对象可以使得VBO不用存储每个顶点重复的数据，然后通过固定索引来描绘出每个三角形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned int indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! </span><br><span class="line">    0, 1, 3, &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    1, 2, 3  &#x2F;&#x2F; 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建索引缓冲对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><p>绑定数据（跟VBO类似）到VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects_ebo.png" alt="EBO使用"></p><p>一般的，在绘制时使用<code>glDrawArrays</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是顶点坐标指针的起始索引，第三个参数是绘制顶点数量</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><p>使用索引绘制时需要用到<code>glDrawElements</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是绘制顶点数量，第三个参数是索引的类型，第四个是EBO数组地址的偏移量</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><p>摧毁EBO对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><h4 id="七、顶点数组对象（Vertex-Array-Object，VAO）"><a href="#七、顶点数组对象（Vertex-Array-Object，VAO）" class="headerlink" title="七、顶点数组对象（Vertex Array Object，VAO）"></a>七、顶点数组对象（Vertex Array Object，VAO）</h4><p>顶点数组对象封装了顶点所有属性数据（例如：坐标，颜色，纹理等），记录了顶点缓冲对像（VBO）和索引缓冲对象（EBO）的指针地址。</p><p>在配置顶点属性之后，VAO记录了配置的状态，在需要的时候绑定不同的VAO实现：</p><p><code>glEnableVertexAttribArray</code>函数和<code>glDisableVertexAttribArray</code>函数分别启用/禁用某个顶点属性，默认是禁用。</p><p><code>glVertexAttribPointer</code>函数用于设置顶点属性配置和关联的顶点缓冲对象。一般顶点属性会放在同一个VBO或EBO中，增加复用性。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png" alt="VAO调用VBO图"></p><p>创建VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VAO;</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时创建多个VAO</span><br></pre></td></tr></table></figure><p>使用VAO，需要先进行绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><p>设置VBO、EBO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>接下来，就可以设置VAO的顶点属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code>函数参数定义：</p><ul><li><p>第一个参数是配置的顶点属性。在顶点着色器源码中使用<code>layout(location = 0)</code>来设置位置值位0，所以这里要传入对应的值。</p></li><li><p>第二个参数是顶点属性的大小。</p></li><li><p>第三个参数是数据的类型。</p></li><li><p>第四个参数是是否将数据标准化。如果设置为<code>GL_TRUE</code>，那么数据就会被映射在0到1之间。</p></li><li><p>第五个参数是步长。表示顶点属性之间的间隔。</p></li><li><p>第六个参数是当前使用的数据在缓冲数组中的偏移量（Offset）。</p></li></ul><p>解绑VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(NULL);</span><br></pre></td></tr></table></figure><p>摧毁VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时删除多个VAO</span><br></pre></td></tr></table></figure><h4 id="八、线框模式与填充模式"><a href="#八、线框模式与填充模式" class="headerlink" title="八、线框模式与填充模式"></a>八、线框模式与填充模式</h4><p><img src="https://learnopengl-cn.github.io/img/01/04/hellotriangle2.png" alt="线框模式与填充模式"></p><p>如果只想获取图元的形状，而不用填充颜色，可以使用线框模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</span><br></pre></td></tr></table></figure><p>填充模式（默认模式）则用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Hello-Triangle&quot;&gt;英文原文地址&lt;/a&gt; &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20star</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（二）——Hello Window小节笔记</title>
    <link href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-02/"/>
    <id>https://www.chaguake.com/2021/03/31/OpenGL-introduction-02/</id>
    <published>2021-03-31T06:59:55.000Z</published>
    <updated>2021-03-31T10:53:13.460Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://learnopengl.com/#!Getting-started/Hello-Window">英文原文地址</a> <a href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/">中文翻译地址</a></p><p>整个小节看这一份完整的源码就可以了。<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window_clear/hello_window_clear.cpp">这里</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初始化GLFW。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwInit();</span><br></pre></td></tr></table></figure><p>调用<code>glfwWindowHint</code>函数配置GLFW。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure><p>调用<code>glfwCreateWindow</code>函数创建窗口对象，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);</span><br></pre></td></tr></table></figure><p>把窗口的上下文设置为当前线程的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure><p>传递OpenGL函数指针给GLAD。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递窗口大小给OpenGL，由于窗口大小会变化，所以通过注册函数来实现动态更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void framebuffer_size_callback(GLFWwindow* window, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(0, 0, width, height);</span><br><span class="line">&#125;</span><br><span class="line">glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure><p>循环渲染，直到窗口退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void processInput(GLFWwindow *window)</span><br><span class="line">&#123;</span><br><span class="line">    if(glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    processInput(window);&#x2F;&#x2F;捕捉用户输入。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;渲染指令</span><br><span class="line">    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glfwSwapBuffers(window);&#x2F;&#x2F;交换颜色缓冲。</span><br><span class="line">    glfwPollEvents();&#x2F;&#x2F;检测事件。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出时释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://learnopengl.com/#!Getting-started/Hello-Window&quot;&gt;英文原文地址&lt;/a&gt; &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20start</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（一）——GLFW库与GLAD库</title>
    <link href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-01/"/>
    <id>https://www.chaguake.com/2021/03/31/OpenGL-introduction-01/</id>
    <published>2021-03-31T06:22:54.000Z</published>
    <updated>2021-03-31T10:53:27.400Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL入门系列是博主学习LearnOpenGL教程的笔录。</p><p>LearnOpenGL中文翻译版教程地址：<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p><p>LearnOpenGL英文原作者版地址：<a href="https://learnopengl.com/">https://learnopengl.com/</a></p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><blockquote><p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。</p></blockquote><p>官网：<a href="https://www.glfw.org/">https://www.glfw.org/</a></p><p>GLFW提供了简单的API，方便开发者创建windows、contexts、surfaces、input和events等一系列操作。</p><p>官网一般提供了现成的二进制文件库和头文件，将它引用到项目中使用。</p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>由于OpenGL的接口函数地址一般是未知的，需要在运行期间动态获取。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义函数原型</span><br><span class="line">typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);</span><br><span class="line">&#x2F;&#x2F; 找到正确的函数并赋值给函数指针</span><br><span class="line">GL_GENBUFFERS glGenBuffers  &#x3D; (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);</span><br><span class="line">&#x2F;&#x2F; 现在函数可以被正常调用了</span><br><span class="line">GLuint buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Dav1dde/glad">GLAD</a>提供了一个<a href="http://glad.dav1d.de/">在线服务</a>，通过一些自定义配置，生成一个文件库，把它引用到项目中使用。</p><p><strong><em>值得注意的是，在引用GLFW的头文件之前要先引用GLAD的头文件，因为GLAD包含了OpenGL的头文件。</em></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OpenGL入门系列是博主学习LearnOpenGL教程的笔录。&lt;/p&gt;
&lt;p&gt;LearnOpenGL中文翻译版教程地址：&lt;a href=&quot;https://learnopengl-cn.github.io/&quot;&gt;https://learnopengl-cn.github.io</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>lua 基础知识</title>
    <link href="https://www.chaguake.com/2021/03/24/lua-base-knowledge/"/>
    <id>https://www.chaguake.com/2021/03/24/lua-base-knowledge/</id>
    <published>2021-03-24T11:35:05.000Z</published>
    <updated>2021-03-31T01:50:42.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>单行注释</strong></p><p>两个连续减号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--我是注释</span><br></pre></td></tr></table></figure><p><strong>多行注释</strong></p><p>结构类似多行字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--[[</span><br><span class="line">第一行注释</span><br><span class="line">第二行注释</span><br><span class="line">]]--</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>lua的变量不需要声明数据类型，并且变量的数据类型是不确定的，前一秒可以赋值数值，下一秒可以赋值字符串。</p><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">nil</td><td style="text-align:center">只有值nil属于该类型，表示一个无效值</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">包含两个值：true和false</td></tr><tr><td style="text-align:center">number</td><td style="text-align:center">表示双精度类型的实浮点数</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">由单引号或者双引号表示的字符串</td></tr><tr><td style="text-align:center">function</td><td style="text-align:center">由C或Lua编写的函数</td></tr><tr><td style="text-align:center">userdata</td><td style="text-align:center">表示任意存储在变量中的C数据结构</td></tr><tr><td style="text-align:center">thread</td><td style="text-align:center">表示执行的独立线路，用于执行协同程序</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table></div><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>变量的作用域默认是全局的，哪怕是在函数里定义的。</p><p>想要删除一个变量，把它赋值为<code>nil</code>。</p><p>局部变量需要在变量前加上<code>local</code>关键字。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>lua的迭代器函数有两个：<code>pairs</code>和<code>ipairs</code>。前者遇到nil不会结束迭代，而是将nil过滤；后者遇到nil会结束迭代，直接返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;, nil, &quot;!&quot;&#125;</span><br><span class="line"></span><br><span class="line">for key,value in ipairs(array)</span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;, nil, &quot;!&quot;&#125;</span><br><span class="line"></span><br><span class="line">for key,value in pairs(array)</span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">!</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>迭代器函数每次调用会返回下一组元素，根据返回的元素组是否包含迭代状态的元素来区分是无状态的迭代器还是多状态的迭代器。</p><p><strong>无状态的迭代器</strong></p><p>它返回每次迭代的状态元素，并且接受上一次迭代元素，例如<code>ipairs</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function iter (a, i)</span><br><span class="line">    i &#x3D; i + 1</span><br><span class="line">    local v &#x3D; a[i]</span><br><span class="line">    if v then</span><br><span class="line">       return i, v</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function ipairs (a)</span><br><span class="line">    return iter, a, 0</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">t &#x3D; &#123;1,2,3,4,5&#125;</span><br><span class="line"></span><br><span class="line">for k,v in ipairs(t)</span><br><span class="line">do</span><br><span class="line">    print(k ,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>多状态的迭代器</strong></p><p>如果迭代器需要维护不止一个状态元素，那可以使用闭包来实现将状态信息存放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">array &#x3D; &#123;&quot;Hello&quot;, &quot;World&quot;&#125;</span><br><span class="line"></span><br><span class="line">function elementIterator (collection)</span><br><span class="line">   local index &#x3D; 0</span><br><span class="line">   local count &#x3D; #collection</span><br><span class="line">   -- 闭包函数</span><br><span class="line">   return function ()</span><br><span class="line">      index &#x3D; index + 1</span><br><span class="line">      if index &lt;&#x3D; count</span><br><span class="line">      then</span><br><span class="line">         --  返回迭代器的当前元素</span><br><span class="line">         return collection[index]</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for element in elementIterator(array)</span><br><span class="line">do</span><br><span class="line">   print(element)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><p>从Lua5.1开始，Lua加入了标准的模块管理机制。</p><p>自定义模块module.lua代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 文件名为 module.lua</span><br><span class="line">-- 定义一个名为 module 的模块</span><br><span class="line">module &#x3D; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 定义一个常量</span><br><span class="line">module.constant &#x3D; &quot;这是一个常量&quot;</span><br><span class="line"> </span><br><span class="line">-- 定义一个函数</span><br><span class="line">function module.func1()</span><br><span class="line">    io.write(&quot;这是一个公有函数！\n&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">local function func2()</span><br><span class="line">    print(&quot;这是一个私有函数！&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function module.func3()</span><br><span class="line">    func2()</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">return module</span><br></pre></td></tr></table></figure><p>加载模块示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- test_module.lua 文件</span><br><span class="line">-- module 模块为上文提到到 module.lua</span><br><span class="line">require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(module.constant)</span><br><span class="line"> </span><br><span class="line">module.func3()</span><br></pre></td></tr></table></figure><p>模块别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- test_module2.lua 文件</span><br><span class="line">-- module 模块为上文提到到 module.lua</span><br><span class="line">-- 别名变量 m</span><br><span class="line">local m &#x3D; require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure><p><strong>C包</strong></p><p>Lua可以引用C的库.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local path &#x3D; &quot;&#x2F;usr&#x2F;local&#x2F;lua&#x2F;lib&#x2F;libluasocket.so&quot;</span><br><span class="line">-- 或者 path &#x3D; &quot;C:\\windows\\luasocket.dll&quot;，这是 Window 平台下</span><br><span class="line">local f &#x3D; assert(loadlib(path, &quot;luaopen_socket&quot;))</span><br><span class="line">f()  -- 真正打开库</span><br></pre></td></tr></table></figure><h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><p>元表提供了对<code>table</code>的扩展操作，通过元方法，可以对<code>table</code>做对应的关联行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setmetatable(table,metatable)</span><br><span class="line">getmetatable(table)</span><br></pre></td></tr></table></figure><p><strong>__index元方法</strong></p><p>提供了当使用在<code>table</code>中不存在的键访问<code>table</code>时的控制操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123;</span><br><span class="line">  __index &#x3D; function(mytable, key)</span><br><span class="line">    if key &#x3D;&#x3D; &quot;key2&quot; then</span><br><span class="line">      return &quot;metatablevalue&quot;</span><br><span class="line">    else</span><br><span class="line">      return nil</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(mytable.key1,mytable.key2)</span><br><span class="line">&#x2F;*</span><br><span class="line">value1    metatablevalue</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>上面代码也可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __index &#x3D; &#123; key2 &#x3D; &quot;metatablevalue&quot; &#125; &#125;)</span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure><p><strong>__newindex元方法</strong></p><p>当给<code>table</code>做一个不存在的键赋值时，就会触发<code>__newindex元方法</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mymetatable &#x3D; &#123;&#125;</span><br><span class="line">mytable &#x3D; setmetatable(&#123;key1 &#x3D; &quot;value1&quot;&#125;, &#123; __newindex &#x3D; mymetatable &#125;)</span><br><span class="line"></span><br><span class="line">print(mytable.key1)</span><br><span class="line"></span><br><span class="line">mytable.newkey &#x3D; &quot;新值2&quot;</span><br><span class="line">print(mytable.newkey,mymetatable.newkey)</span><br><span class="line"></span><br><span class="line">mytable.key1 &#x3D; &quot;新值1&quot;</span><br><span class="line">print(mytable.key1,mymetatable.key1)</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">value1</span><br><span class="line">nil    新值2</span><br><span class="line">新值1    nil</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p><strong>操作符元方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span><br><span class="line">-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数</span><br><span class="line">function table_maxn(t)</span><br><span class="line">    local mn &#x3D; 0</span><br><span class="line">    for k, v in pairs(t) do</span><br><span class="line">        if mn &lt; k then</span><br><span class="line">            mn &#x3D; k</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return mn</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 两表相加操作</span><br><span class="line">mytable &#x3D; setmetatable(&#123; 1, 2, 3 &#125;, &#123;</span><br><span class="line">  __add &#x3D; function(mytable, newtable)</span><br><span class="line">    for i &#x3D; 1, table_maxn(newtable) do</span><br><span class="line">      table.insert(mytable, table_maxn(mytable)+1,newtable[i])</span><br><span class="line">    end</span><br><span class="line">    return mytable</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">secondtable &#x3D; &#123;4,5,6&#125;</span><br><span class="line"></span><br><span class="line">mytable &#x3D; mytable + secondtable</span><br><span class="line">        for k,v in ipairs(mytable) do</span><br><span class="line">print(k,v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">1    1</span><br><span class="line">2    2</span><br><span class="line">3    3</span><br><span class="line">4    4</span><br><span class="line">5    5</span><br><span class="line">6    6</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">操作符元方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">__add</td><td style="text-align:center">加</td></tr><tr><td style="text-align:center">__sub</td><td style="text-align:center">减</td></tr><tr><td style="text-align:center">__mul</td><td style="text-align:center">乘</td></tr><tr><td style="text-align:center">__div</td><td style="text-align:center">商 ‘/’</td></tr><tr><td style="text-align:center">__mod</td><td style="text-align:center">余数 ‘%’</td></tr><tr><td style="text-align:center">__unm</td><td style="text-align:center">负数 ‘-’</td></tr><tr><td style="text-align:center">__concat</td><td style="text-align:center">连接符号 ‘..’</td></tr><tr><td style="text-align:center">__eq</td><td style="text-align:center">判断相等 ‘==’</td></tr><tr><td style="text-align:center">__lt</td><td style="text-align:center">小于 ‘&lt;’</td></tr><tr><td style="text-align:center">__le</td><td style="text-align:center">小于等于 ‘&lt;=’</td></tr></tbody></table></div><p><strong>__call元方法</strong></p><p>提供元组一个调用函数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span><br><span class="line">-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数</span><br><span class="line">function table_maxn(t)</span><br><span class="line">    local mn &#x3D; 0</span><br><span class="line">    for k, v in pairs(t) do</span><br><span class="line">        if mn &lt; k then</span><br><span class="line">            mn &#x3D; k</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return mn</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 定义元方法__call</span><br><span class="line">mytable &#x3D; setmetatable(&#123;10&#125;, &#123;</span><br><span class="line">  __call &#x3D; function(mytable, newtable)</span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        for i &#x3D; 1, table_maxn(mytable) do</span><br><span class="line">                sum &#x3D; sum + mytable[i]</span><br><span class="line">        end</span><br><span class="line">    for i &#x3D; 1, table_maxn(newtable) do</span><br><span class="line">                sum &#x3D; sum + newtable[i]</span><br><span class="line">        end</span><br><span class="line">        return sum</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line">newtable &#x3D; &#123;10,20,30&#125;</span><br><span class="line">print(mytable(newtable))</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">70</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p><strong>__tostring元方法</strong></p><p>提供<code>table</code>格式化输出的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mytable &#x3D; setmetatable(&#123; 10, 20, 30 &#125;, &#123;</span><br><span class="line">  __tostring &#x3D; function(mytable)</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for k, v in pairs(mytable) do</span><br><span class="line">                sum &#x3D; sum + v</span><br><span class="line">        end</span><br><span class="line">    return &quot;表所有元素的和为 &quot; .. sum</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line">print(mytable)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单行注释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个连续减号。&lt;/p&gt;
&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    <category term="lua" scheme="https://www.chaguake.com/categories/lua/"/>
    
    
    <category term="lua" scheme="https://www.chaguake.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>c++ 时间与日期相关函数的使用</title>
    <link href="https://www.chaguake.com/2021/03/23/c-usage-of-time-and-date/"/>
    <id>https://www.chaguake.com/2021/03/23/c-usage-of-time-and-date/</id>
    <published>2021-03-23T03:21:14.000Z</published>
    <updated>2021-03-23T09:41:02.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础类型介绍"><a href="#基础类型介绍" class="headerlink" title="基础类型介绍"></a>基础类型介绍</h2><p>C/C++中，跟时间与日期相关的数据类型有<code>clock_t</code>、<code>time_t</code>和<code>tm</code>，它们的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;time.h&gt; &#x2F;&#x2F;for c</span><br><span class="line">#include&lt;ctime&gt; &#x2F;&#x2F;for c++</span><br><span class="line"></span><br><span class="line">typedef long clock_t;</span><br><span class="line"></span><br><span class="line">typedef long                          __time32_t;</span><br><span class="line">typedef __int64                       __time64_t;</span><br><span class="line"></span><br><span class="line">#ifndef _CRT_NO_TIME_T</span><br><span class="line">    #ifdef _USE_32BIT_TIME_T</span><br><span class="line">        typedef __time32_t time_t;</span><br><span class="line">    #else</span><br><span class="line">        typedef __time64_t time_t;</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct tm</span><br><span class="line">&#123;</span><br><span class="line">    int tm_sec;   &#x2F;&#x2F; seconds after the minute - [0, 60] including leap second</span><br><span class="line">    int tm_min;   &#x2F;&#x2F; minutes after the hour - [0, 59]</span><br><span class="line">    int tm_hour;  &#x2F;&#x2F; hours since midnight - [0, 23]</span><br><span class="line">    int tm_mday;  &#x2F;&#x2F; day of the month - [1, 31]</span><br><span class="line">    int tm_mon;   &#x2F;&#x2F; months since January - [0, 11]</span><br><span class="line">    int tm_year;  &#x2F;&#x2F; years since 1900</span><br><span class="line">    int tm_wday;  &#x2F;&#x2F; days since Sunday - [0, 6]</span><br><span class="line">    int tm_yday;  &#x2F;&#x2F; days since January 1 - [0, 365]</span><br><span class="line">    int tm_isdst; &#x2F;&#x2F; daylight savings time flag</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常用函数介绍"><a href="#常用函数介绍" class="headerlink" title="常用函数介绍"></a>常用函数介绍</h2><h4 id="一、time函数"><a href="#一、time函数" class="headerlink" title="一、time函数"></a>一、time函数</h4><p><strong>函数定义</strong></p><p>获取从1970-01-01 00:00:00到现在经过的秒数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">time_t time(time_t *seconds);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">params:</span><br><span class="line">- seconds: 假如seconds非NULL，该函数会将返回值填充到这里。</span><br><span class="line">return: 返回从 1970-01-01 00:00:00到现在经过的秒数。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  time_t seconds;</span><br><span class="line"> </span><br><span class="line">  seconds &#x3D; time(NULL);</span><br><span class="line">  printf(&quot;自 1970-01-01 起的小时数 &#x3D; %ld\n&quot;, seconds&#x2F;3600);</span><br><span class="line">  </span><br><span class="line">  return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、ctime函数"><a href="#二、ctime函数" class="headerlink" title="二、ctime函数"></a>二、ctime函数</h4><p><strong>函数定义</strong></p><p>获取指定时间点的时间格式化字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char* ctime(const time_t *timer);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">params:</span><br><span class="line">- timer: 需要输出时间格式化字符串的时间点。</span><br><span class="line">return: 返回指定时间点的时间格式化字符串。格式如：Mon Aug 13 08:23:14 2021</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   time_t curtime;</span><br><span class="line"> </span><br><span class="line">   time(&amp;curtime);</span><br><span class="line"> </span><br><span class="line">   printf(&quot;当前时间 &#x3D; %s&quot;, ctime(&amp;curtime));</span><br><span class="line"> </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、localtime函数"><a href="#三、localtime函数" class="headerlink" title="三、localtime函数"></a>三、localtime函数</h4><p><strong>函数定义</strong></p><p>将<code>time_t</code>的时间类型转换成<code>tm</code>结构体的时间类型。</p><p>返回的时间为本地时间，即默认加上了电脑上配置的时区偏移小时差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct tm *localtime(const time_t *timer);</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   time_t rawtime;</span><br><span class="line">   struct tm *info;</span><br><span class="line">   char buffer[80];</span><br><span class="line"> </span><br><span class="line">   time( &amp;rawtime );</span><br><span class="line"> </span><br><span class="line">   info &#x3D; localtime( &amp;rawtime );</span><br><span class="line">   printf(&quot;当前的本地时间和日期：%s&quot;, asctime(info));</span><br><span class="line"> </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、clock函数"><a href="#四、clock函数" class="headerlink" title="四、clock函数"></a>四、clock函数</h4><p><strong>函数定义</strong></p><p>获取从程序执行起，处理器时钟所使用的时间。</p><p>假如需要获取CPU所使用的秒数，需要除以CLOCKS_PER_SEC。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clock_t clock(void);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">return:</span><br><span class="line">返回自程序启动起，处理器时钟所使用的时间。如果失败，则返回 -1 值。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   clock_t start_t, end_t;</span><br><span class="line">   double total_t;</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   start_t &#x3D; clock();</span><br><span class="line">   printf(&quot;程序启动，start_t &#x3D; %ld\n&quot;, start_t);</span><br><span class="line">    </span><br><span class="line">   printf(&quot;开始一个大循环，start_t &#x3D; %ld\n&quot;, start_t);</span><br><span class="line">   for(i&#x3D;0; i&lt; 10000000; i++)</span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   end_t &#x3D; clock();</span><br><span class="line">   printf(&quot;大循环结束，end_t &#x3D; %ld\n&quot;, end_t);</span><br><span class="line">   </span><br><span class="line">   total_t &#x3D; (double)(end_t - start_t) &#x2F; CLOCKS_PER_SEC;</span><br><span class="line">   printf(&quot;CPU 占用的总时间：%f\n&quot;, total_t  );</span><br><span class="line">   printf(&quot;程序退出...\n&quot;);</span><br><span class="line"> </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、asctime函数"><a href="#五、asctime函数" class="headerlink" title="五、asctime函数"></a>五、asctime函数</h4><p><strong>函数定义</strong></p><p>输出结构体<code>tm</code>时间的格式化字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char *asctime(const struct tm *timeptr);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">return:</span><br><span class="line">输出结构体&#96;tm&#96;时间的格式化字符串。格式如：Sat Mar 25 06:10:10 1989</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   struct tm t;</span><br><span class="line"></span><br><span class="line">   t.tm_sec    &#x3D; 10;</span><br><span class="line">   t.tm_min    &#x3D; 10;</span><br><span class="line">   t.tm_hour   &#x3D; 6;</span><br><span class="line">   t.tm_mday   &#x3D; 25;</span><br><span class="line">   t.tm_mon    &#x3D; 2;</span><br><span class="line">   t.tm_year   &#x3D; 89;</span><br><span class="line">   t.tm_wday   &#x3D; 6;</span><br><span class="line"></span><br><span class="line">   puts(asctime(&amp;t));</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、gmtime函数"><a href="#六、gmtime函数" class="headerlink" title="六、gmtime函数"></a>六、gmtime函数</h4><p><strong>函数定义</strong></p><p>将<code>time_t</code>的时间类型转换成<code>tm</code>结构体的时间类型。</p><p>返回的时间为格林尼治标准时间，不会自动加上电脑上配置的时区偏移小时差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct tm *gmtime(const time_t *timer);</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line">#define BST (+1)</span><br><span class="line">#define CCT (+8)</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   time_t rawtime;</span><br><span class="line">   struct tm *info;</span><br><span class="line"> </span><br><span class="line">   time(&amp;rawtime);</span><br><span class="line">   &#x2F;* 获取 GMT 时间 *&#x2F;</span><br><span class="line">   info &#x3D; gmtime(&amp;rawtime );</span><br><span class="line">   </span><br><span class="line">   printf(&quot;当前的世界时钟：\n&quot;);</span><br><span class="line">   printf(&quot;伦敦：%2d:%02d\n&quot;, (info-&gt;tm_hour+BST)%24, info-&gt;tm_min);</span><br><span class="line">   printf(&quot;中国：%2d:%02d\n&quot;, (info-&gt;tm_hour+CCT)%24, info-&gt;tm_min);</span><br><span class="line"> </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="七、mktime函数"><a href="#七、mktime函数" class="headerlink" title="七、mktime函数"></a>七、mktime函数</h4><p><strong>函数定义</strong></p><p>输出由结构体<code>tm</code>的时间变量转换成<code>time_t</code>类型的本地时间戳。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time_t mktime(struct tm *timeptr)</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 输入日期判断是周几 *&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;      &#x2F;* printf, scanf *&#x2F;</span><br><span class="line">#include &lt;time.h&gt;       &#x2F;* time_t, struct tm, time, mktime *&#x2F;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    time_t rawtime;</span><br><span class="line">    struct tm * timeinfo;</span><br><span class="line">    int year, month ,day;</span><br><span class="line">    const char * weekday[] &#x3D; &#123; &quot;周日&quot;, &quot;周一&quot;,&quot;周二&quot;, &quot;周三&quot;,&quot;周四&quot;, &quot;周五&quot;, &quot;周六&quot;&#125;;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 用户输入日期 *&#x2F;</span><br><span class="line">    printf (&quot;年: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;year);</span><br><span class="line">    printf (&quot;月: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;month);</span><br><span class="line">    printf (&quot;日: &quot;); fflush(stdout); scanf (&quot;%d&quot;,&amp;day);</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 获取当前时间信息，并修改用户输入的输入信息 *&#x2F;</span><br><span class="line">    time ( &amp;rawtime );</span><br><span class="line">    timeinfo &#x3D; localtime ( &amp;rawtime );</span><br><span class="line">    timeinfo-&gt;tm_year &#x3D; year - 1900;</span><br><span class="line">    timeinfo-&gt;tm_mon &#x3D; month - 1;</span><br><span class="line">    timeinfo-&gt;tm_mday &#x3D; day;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 调用 mktime: timeinfo-&gt;tm_wday  *&#x2F;</span><br><span class="line">    mktime ( timeinfo );</span><br><span class="line"> </span><br><span class="line">    printf (&quot;那一天是：%s\n&quot;, weekday[timeinfo-&gt;tm_wday]);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="八、difftime函数"><a href="#八、difftime函数" class="headerlink" title="八、difftime函数"></a>八、difftime函数</h4><p><strong>函数定义</strong></p><p>输出两个<code>time_t</code>类型的时间变量之间的秒数差。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double difftime(time_t time1, time_t time2)</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#ifdef _WIN32</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#else</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   time_t start_t, end_t;</span><br><span class="line">   double diff_t;</span><br><span class="line"> </span><br><span class="line">   printf(&quot;程序启动...\n&quot;);</span><br><span class="line">   time(&amp;start_t);</span><br><span class="line"> </span><br><span class="line">   printf(&quot;休眠 5 秒...\n&quot;);</span><br><span class="line">   sleep(5);</span><br><span class="line"> </span><br><span class="line">   time(&amp;end_t);</span><br><span class="line">   diff_t &#x3D; difftime(end_t, start_t);</span><br><span class="line"> </span><br><span class="line">   printf(&quot;执行时间 &#x3D; %f\n&quot;, diff_t);</span><br><span class="line">   printf(&quot;程序退出...\n&quot;);</span><br><span class="line"> </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="九、strftime函数"><a href="#九、strftime函数" class="headerlink" title="九、strftime函数"></a>九、strftime函数</h4><p><strong>函数定义</strong></p><p>输出结构体<code>tm</code>类型的变量的时间格式化字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr);</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">params:</span><br><span class="line">- str：输出的时间格式化字符串存储空间。</span><br><span class="line">- maxsize：存储空间str的最大字符数。</span><br><span class="line">- format：格式化模版。</span><br><span class="line">- timeptr：需要输出时间格式化字符串的变量。</span><br><span class="line"></span><br><span class="line">return:</span><br><span class="line">返回复制到 str 中的字符总数（不包括空结束字符），否则返回零。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>格式化模版使用的含义符参见：<a href="https://www.runoob.com/cprogramming/c-function-strftime.html">菜鸟教程</a></p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   time_t rawtime;</span><br><span class="line">   struct tm *info;</span><br><span class="line">   char buffer[80];</span><br><span class="line"> </span><br><span class="line">   time( &amp;rawtime );</span><br><span class="line"> </span><br><span class="line">   info &#x3D; localtime( &amp;rawtime );</span><br><span class="line"> </span><br><span class="line">   strftime(buffer, 80, &quot;%Y-%m-%d %H:%M:%S&quot;, info);</span><br><span class="line">   printf(&quot;格式化的日期 &amp; 时间 : |%s|\n&quot;, buffer );</span><br><span class="line">  </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础类型介绍&quot;&gt;&lt;a href=&quot;#基础类型介绍&quot; class=&quot;headerlink&quot; title=&quot;基础类型介绍&quot;&gt;&lt;/a&gt;基础类型介绍&lt;/h2&gt;&lt;p&gt;C/C++中，跟时间与日期相关的数据类型有&lt;code&gt;clock_t&lt;/code&gt;、&lt;code&gt;time_t</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.chaguake.com/categories/C-C/"/>
    
    
    <category term="C/C++知识" scheme="https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>GC标记-清除算法</title>
    <link href="https://www.chaguake.com/2021/03/15/GC_mark_sweep_algorithm/"/>
    <id>https://www.chaguake.com/2021/03/15/GC_mark_sweep_algorithm/</id>
    <published>2021-03-14T16:00:00.000Z</published>
    <updated>2021-03-15T13:51:03.176Z</updated>
    
    <content type="html"><![CDATA[<p><img src="20191109103838961_28037.png" alt=""></p><p><em>GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这两个阶段，就可以令不能利用的内存空间重新得到利用。</em></p><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>标记-清除算法的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_sweep()</span><br><span class="line">&#123;</span><br><span class="line">    mark_phase();</span><br><span class="line">    sweep_phase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回收内存部分"><a href="#回收内存部分" class="headerlink" title="回收内存部分"></a>回收内存部分</h2><p>以下图的堆为例子，对各个阶段进行说明：</p><p><img src="20191109104158624_2433.png" alt="执行 GC 前堆的状态"></p><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>根据上面出现的mark_phase()函数来进行标记阶段的处理。</p><p>mark_phase()函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_phase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(r : $roots);</span><br><span class="line">    mark(*r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在标记阶段中，collector 会为堆里的所有活动对象打上标记。为此，我们首先要标记通过根直接引用的对象。首先我们标记这样的对象，然后递归地标记通过指针数组能访问到的对象。这样就能把所有活动对象都标记上了。</p><p>mark()函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mark(obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.mark == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.mark == TRUE;</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">        &#123;</span><br><span class="line">            mark(*child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 2 行中，检查作为实参传递的 obj 是否已被标记。在引用中包含了循环等的情况下，即使对已被标记的对象，有时程序也会调用 mark() 函数。出现类似这种情况的时候，我们就要避免重复进行标记处理。</p><p>如果标记未完成，则程序会在对象的头部进行置位操作。这个位要分配在对象的头之中，并且能用 obj.mark 访问。意思是若 obj.mark 为真，则表示对象已标记；若 obj.mark 为假，则对象没有被标记。</p><p><img src="20191109105212035_2737.png" alt="设置标志位的处理"></p><p>标记完所有活动对象后，标记阶段就结束了。标记阶段结束时的堆如下图所示：</p><p><img src="20191109105258485_30821.png" alt="标记阶段结束后的堆状态"></p><p>在标记阶段中，程序会标记所有活动对象。毫无疑问，标记所花费的时间是与“活动对象的总数”成正比的。</p><p>以上是关于标记阶段的说明。用一句话概括，标记阶段就是“遍历对象并标记”的处理过程。这个“遍历对象”的处理过程在 GC 中是一个非常重要的概念，在之后还会多次出现，请务必记牢。</p><h4 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h4><h5 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h5><p><img src="20191109105544224_18801.png" alt="深度优先搜索"></p><h5 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h5><p><img src="20191109105604497_32262.png" alt="广度优先搜索"></p><p>比较一下内存使用量（已存储的对象数量）就可以知道，深度优先搜索比广度优先搜索更能压低内存使用量。</p><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>在清除阶段中，collector 会遍历整个堆，回收没有打上标记的对象（即垃圾），使其能再次得到利用。</p><p>sweep_phase()函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()</span><br><span class="line">&#123;</span><br><span class="line">    sweeping = $heap_start;</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">            sweeping.mark == FALSE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sweeping.next = $free_list;</span><br><span class="line">            $file_list = sweeping;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sweeping += sweeping.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此出现了叫作 size 的域，这是存储对象大小（字节数）的域。跟 mark 域一样，我们事先在各对象的头中定义它们。</p><p>在清除阶段，我们使用变量 sweeping 遍历堆，具体来说就是从堆首地址 $heap_start 开始，按顺序一个个遍历对象的标志位。</p><p>设置了标志位，就说明这个对象是活动对象。活动对象必然是不能回收的。在第 5 行我们取消标志位，准备下一次的 GC。</p><p>我们必须把非活动对象回收再利用。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。</p><p>我们在 sweep_phase() 函数的第 7 行、第 8 行进行这项操作。</p><p>在第 7 行新出现了叫作 next 的域。我们只在生成空闲链表以及从这个空闲链表中取出分块时才会使用到它。没有必要为各个对象特别准备域，从对象已有的域之中分出来一个就够了。在本章中，next 表示对象（或者分块）最初的域，即 field1。也就是说，给 field1 这个域起个别名叫 next。这跟 C 语言中的联合体（union）的概念相同。</p><p><img src="20191109110300640_18062.png" alt="清除阶段结束后的堆状态"></p><p>在清除阶段，程序会遍历所有堆，进行垃圾回收。也就是说，所花费时间与堆大小成正比。堆越大，清除阶段所花费的时间就会越长。</p><h2 id="分配部分"><a href="#分配部分" class="headerlink" title="分配部分"></a>分配部分</h2><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>这里的分配是指将回收的垃圾进行再利用。当 mutator 申请分块时，怎样才能把大小合适的分块分配给 mutator 呢？</p><p>在清除阶段已经把垃圾对象连接到空闲链表了。搜索空闲链表并寻找大小合适的分块，这项操作就叫作分配。</p><p>执行分配的函数new_obj()伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)</span><br><span class="line">&#123;</span><br><span class="line">    chunk = pickup_chunk(size, $free_list);</span><br><span class="line">    <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        allocation_fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2 行的 pickup_chunk() 函数用于遍历 $free_list，寻找大于等于 size 的分块。它不光会返回和 size 大小相同的分块，还会返回比 size 大的分块。如果它找到和 size 大小相同的分块，则会直接返回该分块；如果它找到比 size 大的分块，则会将其分割成 size 大小的分块和去掉 size 后剩余大小的分块，并把剩余的分块返回空闲链表。</p><p>如果此函数没有找到合适的分块，则会返回 NULL。返回 NULL 时分配是不会进行的。</p><h4 id="专栏-1"><a href="#专栏-1" class="headerlink" title="专栏"></a>专栏</h4><h5 id="First-fit、Best-fit、Worst-fit-的不同"><a href="#First-fit、Best-fit、Worst-fit-的不同" class="headerlink" title="First - fit、Best - fit、Worst - fit 的不同"></a>First - fit、Best - fit、Worst - fit 的不同</h5><p>之前我们讲的分配策略叫作 First - fit。因为在 pickup_chunk() 函数中，最初发现大于等于 size 的分块时就会立即返回该分块。</p><p>然而，分配策略不止这些。还有遍历空闲链表，返回大于等于 size 的最小分块，这种策略叫作 Best - fit。</p><p>还有一种策略叫作 Worst - fit，即找出空闲链表中最大的分块，将其分割成 mutator 申请的大小和分割后剩余的大小，目的是将分割后剩余的分块最大化。但因为 Worst - fit 很容易生成大量小的分块，所以不推荐大家使用此方法。</p><p>除去 Worst - fit，剩下的还有 Best - fit 和 First - fit 这两种。当我们使用单纯的空闲链表时，考虑到分配所需的时间，选择使用 First - fit 更为明智。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>前文中已经提过，根据分配策略的不同可能会产生大量的小分块。但如果它们是连续的，我们就能把所有的小分块连在一起形成一个大分块。这种“连接连续分块”的操作就叫作合并（coalescing），合并是在清除阶段进行的。</p><p>执行合并的函数sweep_phase()伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()</span><br><span class="line">&#123;</span><br><span class="line">    sweeping = $heap_start;</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">            sweeping.mark = FALSE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sweeping == $free_list + $free_list.size)</span><br><span class="line">                $free_list.size +=sweeping.size;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            sweeping.next = $free_list;</span><br><span class="line">            $free_list = sweeping;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sweeping += sweeping.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的sweep_phase() 函数只有第 7 行、第 8 行与上文的sweep_phase() 函数不同。第 7 行用于调查这次发现的分块和上次发现的分块是否连续，如果发现分块连续，则在第 8 行将邻接的 2 个分块合并，整理成 1 个分块。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="实现简单"><a href="#实现简单" class="headerlink" title="实现简单"></a>实现简单</h3><h3 id="与保守式-GC-算法兼容"><a href="#与保守式-GC-算法兼容" class="headerlink" title="与保守式 GC 算法兼容"></a>与保守式 GC 算法兼容</h3><p> GC 标记 - 清除算法因为不会移动对象，所以非常适合搭配保守式 GC 算法。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="碎片化"><a href="#碎片化" class="headerlink" title="碎片化"></a>碎片化</h3><p>在 GC 标记 - 清除算法的使用过程中会逐渐产生被细化的分块，不久后就会导致无数的小分块散布在堆的各处。我们称这种状况为碎片化（fragmentation）。</p><p><img src="20191109111922311_25043.png" alt="碎片化"></p><p>如果发生碎片化，那么即使堆中分块的总大小够用，也会因为一个个的分块都太小而不能执行分配。</p><p>此外，如果发生碎片化，就会增加 mutator 的执行负担。（把具有引用关系的对象安排在堆中较远的位置，就会增加访问所需的时间）</p><p>因为分块在堆中的分布情况取决于 mutator 的运行情况，所以只要使用 GC 标记 - 清除算法，就会或多或少地产生碎片化。</p><p>为了避免碎片化，需要对其进行“压缩”，或者采用“BiBOP 法”。</p><h3 id="分配速度"><a href="#分配速度" class="headerlink" title="分配速度"></a>分配速度</h3><p>GC 标记 - 清除算法中分块不是连续的，因此每次分配都必须遍历空闲链表，找到足够大的分块。最糟的情况就是每次进行分配都得把空闲链表遍历到最后。</p><p>另一方面，因为在 GC 复制算法和 GC 标记 - 压缩算法中，分块是作为一个连续的内存空间存在的，所以没必要遍历空闲链表，分配就能非常高速地进行，而且还能在堆允许范围内分配很大的对象。</p><p>多个空闲链表（multiple free-list）和 BiBOP 法都是为了能在 GC 标记 - 清除算法中高速进行分配而想出的方法。</p><h3 id="与写时复制技术不兼容"><a href="#与写时复制技术不兼容" class="headerlink" title="与写时复制技术不兼容"></a>与写时复制技术不兼容</h3><p>写时复制技术（copy-on-write）是在 Linux 等众多 UNIX 操作系统的虚拟存储中用到的高速化方法。打个比方，在 Linux 中复制进程，也就是使用 fork() 函数时，大部分内存空间都不会被复制。只是复制进程，就复制了所有内存空间的话也太说不过去了吧。因此，写时复制技术只是装作已经复制了内存空间，实际上是将内存空间共享了。</p><p>在各个进程中访问数据时，能够访问共享内存就没什么问题了。</p><p>然而，当我们对共享内存空间进行写入时，不能直接重写共享内存。因为从其他程序访问时，会发生数据不一致的情况。在重写时，要复制自己私有空间的数据，对这个私有空间进行重写。复制后只访问这个私有空间，不访问共享内存。像这样，因为这门技术是“在写入时进行复制”的，所以才被称为写时复制技术。</p><p>这样的话，GC 标记 - 清除算法就会存在一个问题 —— 与写时复制技术不兼容。即使没重写对象，GC 也会设置所有活动对象的标志位，这样就会频繁发生本不应该发生的复制，压迫到内存空间。</p><p>为了处理这个问题，我们采用位图标记（bitmap marking）的方法。</p><h2 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h2><p>之前我们讲的标记 - 清除算法中只用到了一个空闲链表，在这个空闲链表中，对大的分块和小的分块进行同样的处理。但是这样一来，每次分配的时候都要遍历一次空闲链表来寻找合适大小的分块，这样非常浪费时间。</p><p>因此，我们有一种方法，就是利用分块大小不同的空闲链表，即创建只连接大分块的空闲链表和只连接小分块的空闲链表。这样一来，只要按照 mutator 所申请的分块大小选择空闲链表，就能在短时间内找到符合条件的分块了。</p><p><img src="20191109124050196_31525.png" alt="只利用一个空闲链表的情况"></p><p>当只利用一个空闲链表时，需要遍历多次空闲链表才能分配 3 个字的分块。</p><p><img src="20191109124115686_7370.png" alt="利用多个空闲链表的情况"></p><p>这次数组的各个元素都位于空闲链表的前面，第 1 个元素是由 2 个字的分块连接的空闲链表的开头，第 2 个元素是由 3 个字的分块连接的空闲链表的开头。因此，例如在分配 3 个字的分块时，只要查询用于 3 个字的空闲链表就够了。比起只利用一个空闲链表来说，此方法大幅节约了分配所需要的时间。</p><p>不过请稍等，这里有一处需要我们留意。那就是到底制造多少个空闲链表才好呢？用于 2 个字的空闲链表、用于 3 个字的、用于 500 个字的 …… 照这样下去，我们就得准备无数个空闲链表了。</p><p>一般情况下，mutator 很少会申请非常大的分块。为了应对这种极少出现的情况而大量制造空闲链表，会使得空闲链表的数组过于巨大，结果压迫到内存空间。</p><p>因此，我们通常会给分块大小设定一个上限，分块如果大于等于这个大小，就全部采用一个空闲链表处理。有人可能会想：“这样一来，最后不还是没能有效率地搜索大的分块吗？”然而，因为这种分配非常大的分块的情况是极为罕见的，所以效率低一点也不是什么大问题。比这更为重要的是怎么去更快地搜索 mutator 频繁申请分配的小分块，把关注的重点移到这上面来才是更精明的做法。打个比方，如果设定分块大小上限为 100 个字，那么准备用于 2 个字、3 个字、……、100 个字，以及大于等于 101 个字的总共 100 个空闲链表就可以了。</p><p>利用多个空闲链表时，我们需要修正 new_obj() 函数以及 sweep_phase() 函数。修正后的 new_obj() 函数以及 sweep_phase() 函数：</p><p>利用多个空闲链表的 new_obj() 函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)</span><br><span class="line">&#123;</span><br><span class="line">    index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>($free_list[index] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            chunk = $free_list[index];</span><br><span class="line">            $free_list[index] = $free_list[index].next;</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        chunk = pickup_chunk(size, $free_list[<span class="number">101</span>]);</span><br><span class="line">        <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    allocation_fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用多个空闲链表的 sweep_phase() 函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i:<span class="number">2.</span><span class="number">.101</span>)</span><br><span class="line">        $free_list[i] = <span class="literal">NULL</span>;</span><br><span class="line">    sweeping = $heap_start;</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sweeping.mark == TRUE)</span><br><span class="line">            sweeping.mark = FALSE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = size / (WORK_LENGHT / BYTE_LENGHT);</span><br><span class="line">            <span class="keyword">if</span>(index &lt;= <span class="number">100</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sweeping.next = $free_list[index];</span><br><span class="line">                $free_list[index] = sweeping;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sweeping.next = $free_list[<span class="number">101</span>];</span><br><span class="line">                $free_list[<span class="number">101</span>] = sweeping;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sweeping += sweeping.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BiBOP-法"><a href="#BiBOP-法" class="headerlink" title="BiBOP 法"></a>BiBOP 法</h2><p>BiBOP 是 Big Bag Of Pages 的缩写。含义是将大小相近的对象整理成固定大小的块进行管理的做法。</p><p>GC 标记 - 清除算法中会发生碎片化。碎片化的原因之一就是堆上杂乱散布着大小各异的对象。</p><p>对此，我们可以用这个方法：把堆分割成固定大小的块，让每个块只能配置同样大小的对象。这就是 BiBOP 法。</p><p><img src="20191109125137312_23472.png" alt="BiBOP 法的示意图"></p><p>3 个字的对象被整合分配到左数第 1 个和第 3 个块，2 个字的对象被整合分配到左数第 2 个块。像这样配置对象，就会提高内存的使用效率。因为每个块中只能配置同样大小的对象，所以不可能出现大小不均的分块。</p><p>但是，使用 BiBOP 法并不能完全消除碎片化。比方说在全部用于 2 个字的块中，只有 1 到 2 个活动对象，这种情况下就不能算是有效利用了堆。</p><p>BiBOP 法原本是为了消除碎片化，提高堆使用效率而采用的方法。但像上面这样，在多个块中分散残留着同样大小的对象，反而会降低堆使用效率。</p><h2 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h2><p>在单纯的 GC 标记 - 清除算法中，用于标记的位是被分配到各个对象的头中的。也就是说，算法是把对象和头一并处理的。然而这跟写时复制技术不兼容。</p><p>对此我们有个方法，那就是只收集各个对象的标志位并表格化，不跟对象一起管理。在标记的时候，不在对象的头里置位，而是在这个表格中的特定场所置位。像这样集合了用于标记的位的表格称为“位图表格”（bitmap table），利用这个表格进行标记的行为称为“位图标记”。位图表格的实现方法有多种，例如散列表和树形结构等。为了简单起见，这里我们采用整数型数组。</p><p><img src="20191109125314553_26348.png" alt="位图标记"></p><p>在位图标记中重要的是，位图表格中位的位置要和堆里的各个对象切实对应。一般来说，堆中的 1 个字会分配到 1 个位。</p><p>位图标记中的 mark() 函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mark(obj)</span><br><span class="line">&#123;</span><br><span class="line">    obj_num = (obj - $heap_start) / WORD_LENGHT;</span><br><span class="line">    index = obj_num / WORD_LENGHT;</span><br><span class="line">    offset = obj_num % WORD_LENGHT;</span><br><span class="line">    <span class="keyword">if</span>(($bitmap_tbl[index] &amp; (<span class="number">1</span> &lt;&lt; offset)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        $bitmap_tbl[index] != (<span class="number">1</span> &lt;&lt; offset);</span><br><span class="line">        <span class="keyword">for</span>(child : children(obj))</span><br><span class="line">            mark(*child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，WORD_LENGTH 是个常量，表示的是各机器中 1 个字的位宽（例如 32 位机器的 WORD_LENGTH 就是 32）。obj_num 指的是从位图表格前面数起，obj 的标志位在第几个。如上图的 E，它的 obj_num 值就是 8。但下图中位的排序顺序和上图是相反的。因此，E 的标志位是从 bitmap_table[0] 的右边起第 9 个位。</p><p><img src="20191109125834666_4895.png" alt="对象E 的标志位位置"></p><p>我们用 obj_num 除以 WORD_LENGTH 得到的商 index 以及余数 offset 来分别表示位图表格的行编号和列编号。第 6 行和第 7 行中用到了位运算，看上去有些复杂，实际上只是干了件非常简单的事情。</p><p>和在对象的头中直接置标志位的方法相比，该方法稍微有些复杂，但是这样做有两个好处。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><h4 id="与写时复制技术兼容"><a href="#与写时复制技术兼容" class="headerlink" title="与写时复制技术兼容"></a>与写时复制技术兼容</h4><p>以往的标记操作都是直接对对象设置标志位，这会产生无谓的复制。</p><p>然而，使用位图标记是不会对对象设置标志位的，所以也不会发生无谓的复制。当然，因为对位图表格进行了重写，所以在此处会发生复制。不过，因为位图表格非常小，所以即使被复制也不会有什么大的影响。</p><p>此外，以上问题只发生在写时复制技术的运行环境（Linux 等）中，以及频繁执行 fork() 函数的应用程序中。也就是说，它对于一般的程序来说完全不是问题。</p><h4 id="清除操作更高效"><a href="#清除操作更高效" class="headerlink" title="清除操作更高效"></a>清除操作更高效</h4><p>不仅在标记阶段，在清除阶段也可以得到好处。以往的清除操作都必须遍历整个堆，把非活动对象连接到空闲链表，同时取消活动对象的标志位。</p><p>利用了位图表格的清除操作则把所有对象的标志位集合到一处，所以可以快速消去标志位。</p><p>位图标记的sweep_phase() 函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()</span><br><span class="line">&#123;</span><br><span class="line">    sweeping = $heap_start;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(sweeping &lt; $heap_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>($bitmap_tbl[index] &amp; (<span class="number">1</span> &lt;&lt; offset) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sweeping.next = $free_list;</span><br><span class="line">            $free_list = sweeping</span><br><span class="line">        &#125;</span><br><span class="line">        index += (offset + sweeping.size) / WORD_LENGTH;</span><br><span class="line">        offset = (offset + sweeping.size) % WORD_LENGTH;</span><br><span class="line">        sweeping += sweeping.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0.</span>.(HEAP_SIZE / WORD_LENGTH - <span class="number">1</span>))</span><br><span class="line">        $bitmap_tbl[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与一般的清除阶段相同，我们用 sweeping 指针遍历整个堆。不过，这里使用了 index 和 offset 两个变量，在遍历堆的同时也遍历位图表格。</p><p>第 6 行到第 12 行是从堆的开头开始遍历。第 7 行是调查遍历过程中与对象对应的标志位。当对象没有设置标志位时，程序会在第 8 行和第 9 行将此对象连接到空闲链表。当对象已经设立了标志位时，程序就不会在此进行消除位的操作，而是放到之后一并进行。</p><p>第 10 行、第 11 行是遍历位图表格，第 12 行是遍历堆。</p><p>第 14 行、第 15 行是把所有在位图表格中设置的位取消。因为能够一并消除标志位，所以能够有效地取消位。</p><h3 id="要注意的地方"><a href="#要注意的地方" class="headerlink" title="要注意的地方"></a>要注意的地方</h3><p>在进行位图标记的过程中，有件事情我们必须注意，那就是对象地址和位图表格的对应。就像之前和大家说明的那样，想通过对象的地址求与其对应的标志位的位置，是要进行位运算的。然而在堆有多个，对象地址不连续的情况下，我们无法用单纯的位运算求出标志位的位置。因此，在堆为多个的情况下，一般会为每个堆都准备一个位图表格。</p><h2 id="延迟清除法"><a href="#延迟清除法" class="headerlink" title="延迟清除法"></a>延迟清除法</h2><p>清除操作所花费的时间是与堆大小成正比的。也就是说，处理的堆越大，GC 标记 - 清除算法所花费的时间就越长，结果就会妨碍到 mutator 的处理。</p><p>延迟清除法（Lazy Sweep）是缩减因清除操作而导致的 mutator 最大暂停时间的方法。在标记操作结束后，不一并进行清除操作，而是如其字面意思一样让它“延迟”，通过“延迟”来防止 mutator 长时间暂停。</p><p>延迟清除法中的 new_obj() 函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)</span><br><span class="line">&#123;</span><br><span class="line">    chunk = lazy_sweep(size);</span><br><span class="line">    <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    mark_phase();</span><br><span class="line">    chunk = lazy_sweep(size);</span><br><span class="line">    <span class="keyword">if</span>(chunk != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    allocation_fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分配时直接调用 lazy_sweep() 函数，进行清除操作。如果它能用清除操作来分配分块，就会返回分块；如果不能分配分块，就会执行标记操作。当 lazy_sweep() 函数返回 NULL 时，也就是没有找到分块时，会调用 mark_phase() 函数进行一遍标记操作，再调用 lazy_sweep() 函数来分配分块。在这里没能分配分块也就意味着堆上没有分块，mutator 也就不能再进行下一步处理了。</p><p>lazy_sweep() 函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lazy_sweep(size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>($sweeping &lt; $heap_end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>($sweeping.mark == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            $sweeping.mark = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>($sweeping.size &gt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            chunk = $sweeping;</span><br><span class="line">            $sweeping += $sweeping.size;</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line">        $sweeping += $sweeping.size;</span><br><span class="line">    &#125;</span><br><span class="line">    $sweeping = $heap_start;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lazy_sweep() 函数会一直遍历堆，直到找到大于等于所申请大小的分块为止。在找到合适分块时会将其返回。但是在这里 $sweeping 变量是全局变量。也就是说，遍历的开始位置位于上一次清除操作中发现的分块的右边。</p><p>当 lazy_sweep() 函数遍历到堆最后都没有找到分块时，会返回 NULL。</p><p>因为延迟清除法不是一下遍历整个堆，它只在分配时执行必要的遍历，所以可以压缩因清除操作而导致的 mutator 的暂停时间。这就是“延迟”清除操作的意思。</p><p>我们已经知道，通过延迟清除法可以缩减 mutator 的暂停时间，不过这是真的吗？稍微想想看就会明白，延迟清除的效果是不均衡的。打个比方，假设刚标记完的堆的情况如下图 所示。</p><p><img src="20191109130822826_29633.png" alt="堆里垃圾分布不均的情况"></p><p>也就是说，垃圾变成了垃圾堆，活动对象变成了活动对象堆，它们形成了一种邻接的状态。在这种情况下，程序在清除垃圾较多的部分时能马上获得分块，所以能减少 mutator 的暂停时间。然而一旦程序开始清除活动对象周围，就怎么也无法获得分块了，这样就增加了 mutator 的暂停时间。</p><p>结果，如果一下子清除的堆大小不一定，那么 mutator 的暂停时间就会增大。</p><p>关于保持所清除的堆大小的方法，后文详细说明。</p><p>虽然在这里没有特别提及，不过标记阶段导致的暂停时间和清除阶段导致的暂停时间一样，也是个问题。关于如何改善这个问题，也是在后文详细说明。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;20191109103838961_28037.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;GC 标记 - 清除算法由标记阶段和清除阶段构成。标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。通过这</summary>
      
    
    
    
    <category term="书籍" scheme="https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="垃圾回收的算法与实现" scheme="https://www.chaguake.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++多态之虚函数与虚函数表</title>
    <link href="https://www.chaguake.com/2021/03/14/virtual_function_or_table_of_polymorphism/"/>
    <id>https://www.chaguake.com/2021/03/14/virtual_function_or_table_of_polymorphism/</id>
    <published>2021-03-13T16:00:00.000Z</published>
    <updated>2021-03-14T10:53:29.587Z</updated>
    
    <content type="html"><![CDATA[<p>虚函数，是用关键字<code>virtual</code>修饰的<strong>类成员函数</strong>，但不包括静态函数（static）和构造函数。</p><p>内联函数（inline）可以是虚函数。因为内联函数是作用于编译期间，用于通知编译器是否要将内联函数展开。当虚函数标记为内联函数时，假如该函数呈现运行时多态，那么编译器会忽略关键字<code>inline</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    Base();</span><br><span class="line">    ~Base();</span><br><span class="line"></span><br><span class="line">    virtual void fun1();</span><br><span class="line">    virtual void fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Device:public Base&#123;</span><br><span class="line">public:</span><br><span class="line">    Device();</span><br><span class="line">    virtual ~Device();&#x2F;&#x2F;确保Device类正常析构</span><br><span class="line"></span><br><span class="line">    virtual void fun1();</span><br><span class="line">    void fun2();&#x2F;&#x2F;不加关键字virtual也可以</span><br><span class="line">    virtual void print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Device dev;</span><br><span class="line">&#x2F;&#x2F;dev.fun1();</span><br><span class="line">&#x2F;&#x2F;dev.fun2();</span><br></pre></td></tr></table></figure><p>运行上面代码，可以发现，对象<code>dev</code>有一个指针对象<code>__vfptr</code>。</p><p><img src="20210314133118453_13507.png" alt="图1"></p><p>指针对象<code>__vfptr</code>是虚函数指针，类型为<code>void(*)()</code>，它指向对象<code>dev</code>的数组<code>vftable</code>，即虚函数表。</p><p>定义另一个Device类对象，可以看到，两个Device类对象的指针对象<code>__vfptr</code>的地址是一样的，这就意味着，Device类的虚函数表全局只有一份，所有Device类对象都会创建一个虚函数指针，并指向它。</p><p>在Device类中定义虚函数<code>print</code>，会发现在<code>__vfptr</code>中并没有发现它，但<code>vftable</code>大小+1，派生另一个类，继承于Device类，其<code>__vfptr</code>和<code>vftable</code>跟Device类一样。</p><p>这就说明，继承于Base类，但属于其子类的虚函数都会按顺序写入基类的<code>vftable</code>里。（假如有多继承，那属于其子类的虚函数都会按顺序写入第一个基类的<code>vftable</code>里。）</p><p>那假如基类并没有虚函数呢？</p><p><img src="20210314135804590_12114.png" alt="图2"></p><p>可以看出，<code>vftable</code>会挂在基类的下一级子类中（或者再下一级）。</p><hr><p>其他博客的相关文章：<a href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虚函数，是用关键字&lt;code&gt;virtual&lt;/code&gt;修饰的&lt;strong&gt;类成员函数&lt;/strong&gt;，但不包括静态函数（static）和构造函数。&lt;/p&gt;
&lt;p&gt;内联函数（inline）可以是虚函数。因为内联函数是作用于编译期间，用于通知编译器是否要将内联函数展开。</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.chaguake.com/categories/C-C/"/>
    
    
    <category term="C++多态" scheme="https://www.chaguake.com/tags/C-%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
</feed>
