<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶瓜客</title>
  
  <subtitle>解衣又作茶瓜客，倚槛同看烟雨峰</subtitle>
  <link href="https://www.chaguake.com/atom.xml" rel="self"/>
  
  <link href="https://www.chaguake.com/"/>
  <updated>2021-05-11T01:41:03.309Z</updated>
  <id>https://www.chaguake.com/</id>
  
  <author>
    <name>茶瓜客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blender官方源码文档——RNA</title>
    <link href="https://www.chaguake.com/2021/05/10/Blender-source-code-study-07/"/>
    <id>https://www.chaguake.com/2021/05/10/Blender-source-code-study-07/</id>
    <published>2021-05-10T02:23:35.000Z</published>
    <updated>2021-05-11T01:41:03.309Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Architecture/RNA">这里</a></p><hr><h1 id="RNA"><a href="#RNA" class="headerlink" title="RNA"></a>RNA</h1><blockquote><p>这是一份数据API实现的文档。</p></blockquote><h2 id="实现（Implementation）"><a href="#实现（Implementation）" class="headerlink" title="实现（Implementation）"></a>实现（Implementation）</h2><p>RNA的实现在模块<code>makesrna</code>。其中，几个重要的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RNA_types.h: The important RNA data structures are defined here.</span><br><span class="line">RNA_access.h: API for accessing structs and properties at runtime.</span><br><span class="line">RNA_define.h: API for defining structs and properties.</span><br></pre></td></tr></table></figure><p><img src="https://wiki.blender.org/w/images/0/06/RNADataTypes.png" alt=""></p><h2 id="定义结构体和属性（Defining-Structs-and-Properties）"><a href="#定义结构体和属性（Defining-Structs-and-Properties）" class="headerlink" title="定义结构体和属性（Defining Structs and Properties）"></a>定义结构体和属性（Defining Structs and Properties）</h2><p>结构体和属性都定义在<code>makesrna</code>模块的<code>rna_*.c</code>这一类文件中，其定义作为构建系统的一部分生成。错误信息会在构建期间打印出来。</p><h3 id="结构体（Struct）"><a href="#结构体（Struct）" class="headerlink" title="结构体（Struct）"></a>结构体（Struct）</h3><ul><li><p>如果你没有在已存在的文件中添加它：</p><ul><li><p>拷贝已存在的文件，重命名并清理它。</p></li><li><p>在文件<code>makesrna.c</code>中，把它添加到列表<code>PROCESS_ITEMS</code>。</p></li></ul></li><li><p>在文件<code>rna_access.h</code>中，添加结构体<code>StructRNA</code>的extern描述。</p></li><li><p>对于数据块，在文件<code>rna_ID.c</code>中添加正确的ID_case到函数<code>rna_ID_refine()</code>。</p></li></ul><p>接下来，在函数<code>RNA_def_*</code>类函数中，对应的结构体将会被定义。函数<code>RNA_def_struct</code>定义了结构体本身。我们必须定义一个唯一名称且人类能理解的标识符去标识这些结构体。</p><p>系统就会自动尝试找到与标识符同名的DNA结构体。假如一个相应的结构体拥有不同的名称，函数<code>RNA_def_struct_sdna</code>可以找到正确的名称，这对于以后更加自动地定义属性很重要。</p><p>对于每一个结构体都尽可能地把其名称设置为字符串属性，这个名称将用于UI，并且可以在集合（collections）中使用字符串搜索。</p><p>对于ID数据块结构体（ID struct），它需要满足：</p><ul><li><p>在文件<code>rna_main.c</code>中，将“lists”数组中现有项改成正确的类型以代替“ID”，或者是添加新项。</p></li><li><p>在文件<code>rna_ID.c</code>中，使用函数<code>rna_ID_refine</code>添加改结构体。</p></li></ul><h3 id="属性（Property）"><a href="#属性（Property）" class="headerlink" title="属性（Property）"></a>属性（Property）</h3><p>对于每一个属性，始于函数<code>RNA_def_property</code>。其标识符一定要跟对应的结构体类似。然后我们必须定义一个类型和子类型。类型确定了数据类型，子类型则是对数据的解释，举个例子，一个float数组属性可以是颜色、向量或者矩阵。</p><p>同样地，系统会使用跟标识符一样的字符串在DNA结构体中查找属性，如果它有不一样的名称，下一步要做的是使用函数<code>RNA_def_*_sdna</code>正确指向它。DNA信息用于衍生各种各样的事物，比如说，<code>get/set</code>函数、集合的迭代器、数组长度、限制器等等，下一节将解释映射的工作规则。</p><p>如果这些自动值（the automatic values）不正确，则可以后置覆盖。文件<code>RNA_define.h</code>为不同的类型提供信息概括。重要的定义是数组长度、数字范围和枚举项。</p><p>接下来，我们需要定义默认值。如果没有显式定义，则数字的默认值为0，字符串的默认值为“”，指针的默认值为NULL，集合的默认值则为空。</p><p>为了构建更加自动的用户界面，需要为工具定义通俗易懂的名称和描述。对于可伸缩的数值，定义可拖拽的步长和精度。这些将是从RNA属性中生成按钮时的默认值。</p><p>在很多情况下，自动DNA的匹配会解决这个问题，但在某些情况下，我们必须为<code>get/set</code>函数设置回调函数。它们的名称可以使用函数<code>RNA_def_property_*_funcs</code>传递，参数请参见文件<code>RNA_type.h</code>。集合（collections）是最困难的，尽管可以自动支持<code>ListBase</code>和特定数组。请注意，有些函数调用是可选的，它们只对优化有帮助，举个例子，列表的查找函数。</p><h3 id="DNA匹配（DNA-Matching）"><a href="#DNA匹配（DNA-Matching）" class="headerlink" title="DNA匹配（DNA Matching）"></a>DNA匹配（DNA Matching）</h3><p><img src="https://wiki.blender.org/w/images/1/1b/RNAPreprocessing.png" alt=""></p><ul><li><p>Booleans/Ints/Floats：数组长度基于在float member[x]中的数值<code>x</code>。举个例子，只支持一维数组。如果变量本身不是数组，它会假设连续变量是数组的一部分。举个例子，指定变量<code>r</code>来自浮点型变量<code>r</code>、<code>g</code>和<code>b</code>，那么，可以假设数组的地址为<code>&amp;r</code>。</p></li><li><p>Booleans可以使用函数<code>RNA_def_property_boolean_sdna</code>指定为一个bit。如果定义了数组长度但没有数组成员SDNA，那么可以假设这个数组是通过由指定bit开始的bit标志位定义的。</p></li><li><p>Ints：数值值范围见<code>INT_MIN/INT_MAX</code>，如果检测出是char或者short，则使用对应的值范围。非负数类型现在并没有自动检测（SDNA不支持），所以，应该使用子类型<code>PROP_UNSIGNED</code>或者手动限制其值范围。</p></li><li><p>Enums：函数<code>RNA_def_property_enum_sdna</code>有一个参数去判断枚举是否是bit标志位的，在与其他标志位混用时应当被设置。</p></li><li><p>Strings：char数组，最大长度取决于数组大小。</p></li><li><p>Pointers：如果指针类型未定义，则会根据结构体对应的DNA自动定义，对于定义为指向数组指针的集合，也是使用指针。</p></li><li><p>Collections：基于ListBase，函数<code>begin/next/get</code>会自动生成。</p></li><li><p>Collections：当将包含集合长度的变量的名称传递给SDNA函数时，假设正在使用一个数组，则会为这个数组自动生成函数<code>begin/next/get/end</code>。如果成员的指针是像<code>MVert *mvert;</code>这样的简单指针，它会返回<code>&amp;mvert[i]</code>这样的items，如果它是像<code>Material **mat;</code>这样指向指针的指针，他就会返回<code>mat[i]</code>这样的items。</p></li><li><p>在嵌套结构体中的成员也可以被识别，举个例子，使用函数<code>RNA_def_property_*_sdna</code>传递一个值。</p></li></ul><h3 id="命名约束（Naming-Conventions）"><a href="#命名约束（Naming-Conventions）" class="headerlink" title="命名约束（Naming Conventions）"></a>命名约束（Naming Conventions）</h3><h2 id="运行时接入（Runtime-Access）"><a href="#运行时接入（Runtime-Access）" class="headerlink" title="运行时接入（Runtime Access）"></a>运行时接入（Runtime Access）</h2><p><img src="https://wiki.blender.org/w/images/5/5c/RNARuntimeAccess.png" alt=""></p><p>运行时接入属性值是通过定义在文件<code>RNA_access.h</code>的函数。支持函数<code>get/set</code>和集合迭代器。</p><p>这也是使用函数去检查属性是否可编辑的或已计算的。如果属性是可编辑的，这就意味着它可以被用户修改。如果它是可计算的，这就意味着它可以将一些函数设置为计算的一部分，例如：修改器、约束器或者动画系统的一部分。</p><h3 id="指针（Pointers）"><a href="#指针（Pointers）" class="headerlink" title="指针（Pointers）"></a>指针（Pointers）</h3><p><img src="https://wiki.blender.org/w/images/b/b2/RNAPointerID.png" alt=""></p><p>一个RNA结构体的指针总是包裹在结构体<code>PointerRNA</code>中。结构体<code>PointerRNA</code>包含实际的数据指针和结构体类型。它也包含了数据指针和数据所属的ID数据块类型。这在某种情况下是有需要的，举个例子，一个顶点自身是提供不了足够的信息去更新依赖关系图，我们需要知道顶点所在的网格（mesh）。</p><p>在运行时中创建指针，使用函数<code>RNA_main_pointer_create</code>、<code>RNA_id_pointer_create</code>和<code>RNA_pointer_create</code>。</p><p>属性的回调函数使用PointerRNA们来代替直接指向数据的指针，因此，它们在需要的时候可以使用ID数据。指针和集合的<code>get/set</code>回调函数返回数据指针，类型和ID则会在回调的外部自动填充。</p><h2 id="ID属性（ID-Properties）"><a href="#ID属性（ID-Properties）" class="headerlink" title="ID属性（ID Properties）"></a>ID属性（ID Properties）</h2><p><img src="https://wiki.blender.org/w/images/2/21/RNAIDProperties.png" alt=""></p><p>RNA同样支持ID属性，有两个方法：</p><ul><li><p>如果一个RNA属性是在运行时中定义，或者有<code>PROP_IDPROPERTY</code>标记，ID属性将会通过RNA API被首次创建。RNA API初始化时返回默认值，直到创建ID属性，然后，返回ID属性值。值得注意的是，如果RNA定义了相同名称但不用类型的ID属性，那它会移除和重写，以匹配上RNA的类型。</p></li><li><p>如果存在一个ID属性但它没有对应的RNA属性，当遍历结构体的属性时，依旧通过RNA暴露。RNA信息会得到默认值：像用户界面名称这类物体将从ID属性名称得到，数值范围则会根据其类型得到默认值。</p></li></ul><p>为了简化没有对应RNA属性的ID属性的API，可使用函数<code>RNA_property_*</code>得到实际的<code>PropertyRNA*</code>，或者使用<code>IDProperty*</code>强制转换得到<code>PropertyRNA*</code>。内置函数会检测出哪个数据结构体被使用。因此，对成员<code>PropertyRNA*</code>的访问必须通过访问器函数，而不是直接访问该成员。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Architecture/RNA</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——ID Datablocks</title>
    <link href="https://www.chaguake.com/2021/05/08/Blender-source-code-study-06/"/>
    <id>https://www.chaguake.com/2021/05/08/Blender-source-code-study-06/</id>
    <published>2021-05-08T09:50:42.000Z</published>
    <updated>2021-05-10T02:21:58.106Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Architecture/ID">这里</a></p><hr><h1 id="ID数据块（ID-Datablocks）"><a href="#ID数据块（ID-Datablocks）" class="headerlink" title="ID数据块（ID Datablocks）"></a>ID数据块（ID Datablocks）</h1><p>对象（objects）、网格（meshes）、材料（materials）、场景（scenes），它们都是ID数据块的例子。它们通常定义在头文件<code>DNA_&#123;some type&#125;_typed.h</code>中。</p><p>ID数据块是以一组公共属性开始的内存块。在C中，它被定义为结构体，并且会嵌入一个ID结构体类型作为第一个字段。如果它有存放动画数据的动画数据结构体，则这个动画数据结构体会是第二个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Mesh &#123;</span><br><span class="line">  ID id;</span><br><span class="line">  struct AnimData *adt;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据块的名称（pointer-&gt;id.name）标识了数据块的类型。举个例子，一个Blender用户界面中显示的网格，它叫“Suzanne”，但在数据块中实际叫“MESuzanne”。可以使用<code>ID *id</code>得到正确的类型。函数<code>GS(id-&gt;name)</code>可以获取名称对应的ID数据类型常量——<code>if (GS(id-&gt;name) == ID_SC) ...</code>，可以用于检测场景中ID数据块。</p><h2 id="ID数据类型的运行时注册（Runtime-Registration-of-ID-Types）"><a href="#ID数据类型的运行时注册（Runtime-Registration-of-ID-Types）" class="headerlink" title="ID数据类型的运行时注册（Runtime Registration of ID Types）"></a>ID数据类型的运行时注册（Runtime Registration of ID Types）</h2><p>2020年以前，ID数据块类型在Blender中是硬编码的。作为“代码清理日” 的一部分，它被转换成运行时的数据结构。本节介绍ID数据块类型新的注册方法。</p><p>运行时类型信息存储在结构体<code>IDTypeInfo</code>中。它包含结构体的元数据，以及一些指向通用函数的指针（创建、拷贝、删除、本地化等等）。下面举个例子，用于实现一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IDTypeInfo IDType_ID_OB &#x3D; &#123;</span><br><span class="line">    .id_code &#x3D; ID_OB,</span><br><span class="line">    .id_filter &#x3D; FILTER_ID_OB,</span><br><span class="line">    .main_listbase_index &#x3D; INDEX_ID_OB,</span><br><span class="line">    .struct_size &#x3D; sizeof(Object),</span><br><span class="line">    .name &#x3D; &quot;Object&quot;,</span><br><span class="line">    .name_plural &#x3D; &quot;objects&quot;,</span><br><span class="line">    .translation_context &#x3D; BLT_I18NCONTEXT_ID_OBJECT,</span><br><span class="line">    .flags &#x3D; 0,</span><br><span class="line"></span><br><span class="line">    .init_data &#x3D; object_init_data,</span><br><span class="line">    .copy_data &#x3D; object_copy_data,</span><br><span class="line">    .free_data &#x3D; object_free_data,</span><br><span class="line">    .make_local &#x3D; object_make_local,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="添加一个新的ID数据块类型（Adding-a-new-ID-Type）"><a href="#添加一个新的ID数据块类型（Adding-a-new-ID-Type）" class="headerlink" title="添加一个新的ID数据块类型（Adding a new ID Type）"></a>添加一个新的ID数据块类型（Adding a new ID Type）</h2><p>要添加一个新的<code>IDTypeInfo</code>，你需要：</p><ul><li><p>在相关BKE的实现文件（比如ID_ME的实现文件是mesh.c）中定义<code>IDTypeInfo</code>。</p><ul><li><p>在该文件的开头添加静态回调函数和<code>IDTypeInfo</code>结构体定义。</p></li><li><p>如果你需要额外的帮手，只添加它们的前置声明，然后在它们的定义下方实现它们。这使得每个ID数据块类型实现文件的公共信息和特定API分离。</p></li><li><p>这个新的<code>IDTypeInfo</code>应该根据它的识别码来命名。</p></li></ul></li><li><p>在文件<code>BKE_idtype.h</code>中为这个新的ID数据块类型添加extern声明。</p></li><li><p>在文件<code>idtype.c</code>中调用函数<code>id_type_init()</code>来注册这个新的<code>IDTypeInfo</code>。</p></li></ul><h2 id="处理ID数据块类型的函数（Functions-for-Handling-ID-Types）"><a href="#处理ID数据块类型的函数（Functions-for-Handling-ID-Types）" class="headerlink" title="处理ID数据块类型的函数（Functions for Handling ID Types）"></a>处理ID数据块类型的函数（Functions for Handling ID Types）</h2><p>这里有有各种各样的函数可用于ID数据块。在这里列出来必然会出现过时的情况，所以只需阅读文件<code>BKE_idtype.h</code>即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Architecture/ID&quot;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——Dependency Graph</title>
    <link href="https://www.chaguake.com/2021/05/08/Blender-source-code-study-05/"/>
    <id>https://www.chaguake.com/2021/05/08/Blender-source-code-study-05/</id>
    <published>2021-05-08T07:18:14.000Z</published>
    <updated>2021-05-08T09:48:34.391Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Depsgraph">这里</a></p><hr><h1 id="Blender-2-8：依赖关系图"><a href="#Blender-2-8：依赖关系图" class="headerlink" title="Blender 2.8：依赖关系图"></a>Blender 2.8：依赖关系图</h1><blockquote><p>本文档涵盖了依赖关系图的所有设计规范，以支持Blender 2.8项目的所有新功能。</p></blockquote><h2 id="简介（Introduction）"><a href="#简介（Introduction）" class="headerlink" title="简介（Introduction）"></a>简介（Introduction）</h2><p>首先，我们得了解依赖关系图是什么，在任何情况下它应该做什么和不应该做什么。依赖关系图的主要目标是确保场景数据在发生任何更改时，以最有效的方式正确地更新。这意味着依赖关系图只更新依赖于修改后的数值，而不会更新那些没有更改的数据。这样子，艺术家（artists）总是以最大帧更新速率让场景处于有意义的状态。依赖关系图通过预处理场景来实现的——创建一个图，其节点是场景的实体（例如，对象），边则是这些对象之间的关系（例如，当对象A拥有一个父对象B，这个图就有一条处于两个对象之间的边）。</p><p>简单来说，依赖关系图负责场景的动态更新（dynamic updates），其中一些数值随着时间而变化。它不负责一次性的改变（one-time changes）。举个例子，依赖关系图负责f曲线的求值，但不负责网格编辑模式下边的细分操作。</p><h2 id="概述（Overview）"><a href="#概述（Overview）" class="headerlink" title="概述（Overview）"></a>概述（Overview）</h2><p>最新的设计概述相当简单，如下图所示：</p><p><img src="https://wiki.blender.org/w/images/thumb/a/a6/Dev-Blender_2.8_Data_Flow.png/900px-Dev-Blender_2.8_Data_Flow.png" alt=""></p><p>与2.7x系列的差别如下：</p><ul><li><p>DNA数据直接从<code>.blend</code>文件中传递，它简单小巧，只需在外部存储中代表场景。</p></li><li><p>DNA数据没有运行时字段。</p></li><li><p>依赖关系图将所有必需的更改（modifiers, constraints, etc）应用到DNA数据的副本上。我们称它们为生成数据（generated data）。</p></li><li><p>依赖关系图存储自身的评估结果。任何的改变都不会应用到源DNA数据（original DNA）。</p></li><li><p>渲染引擎使用依赖关系图提供的生成数据（generated data），并且不会接触源DNA数据（original DNA）。</p></li><li><p>渲染引擎将具有通用且集中的API，用于存储引擎特定的数据。</p></li></ul><p>这些更改都需要支持像在不同窗口不同状态下实现覆盖和场景这样的特性。它看起来简单，但是它会引导一些重大的设计决定，去尽可能地覆盖所有工具和边缘情况（corner cases）。</p><h2 id="依赖关系图的所有权（Dependency-graph-ownership）"><a href="#依赖关系图的所有权（Dependency-graph-ownership）" class="headerlink" title="依赖关系图的所有权（Dependency graph ownership）"></a>依赖关系图的所有权（Dependency graph ownership）</h2><p>在回答是谁拥有依赖关系图的问题之前，让我们简单地讨论下工作区（workspaces）。</p><p>工作区是组织艺术家（artists）工作流程的一种方式。活动工作区指针存储在每一个窗口（window）中，因此，窗口始终有且仅有一个活动工作区。工作区本身定义了渲染引擎（可以说是与场景渲染引擎相同，但又不完全一样）。工作区还定义了活动场景层（active scene layer），即在工作区编辑器中皆可见。</p><p>这些都是非常重要的声明，理由是渲染引擎和活动场景层都定义了如何去计算对象的最终状态。因此，渲染引擎可以设置一些简单的配置，活动场景层可以拥有覆盖（overrides）。</p><p>这里的决定代表着是窗口（window）拥有依赖关系图（对于交互操作和最终呈现，请看下文）。当艺术家（artists）改变了工作区，或者选择了另一个渲染引擎和场景层，窗口就会被要求重新创建它的依赖关系图，对应新的窗口/工作区状态。</p><p>对于最终的F12渲染所有权则更简单些，依赖关系图由渲染结构拥有。</p><p>通过这个方式，我们尽可能快地对可见数据（visible data）进行场景评估，并支持所有需要上下文关联的覆盖。</p><h2 id="生成数据与写入时复制（Generated-data-and-copy-on-write）"><a href="#生成数据与写入时复制（Generated-data-and-copy-on-write）" class="headerlink" title="生成数据与写入时复制（Generated data and copy on write）"></a>生成数据与写入时复制（Generated data and copy on write）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Depsgraph&quot;&gt;这里&lt;/a</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——Context</title>
    <link href="https://www.chaguake.com/2021/05/07/Blender-source-code-study-04/"/>
    <id>https://www.chaguake.com/2021/05/07/Blender-source-code-study-04/</id>
    <published>2021-05-07T09:12:07.000Z</published>
    <updated>2021-05-08T09:33:34.842Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Architecture/Context">这里</a></p><hr><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>在2.5中，bContext结构体被添加进来，作为全局变量的替代品，更明确地去创建上下文（make context）。比如，操作类、Python脚本和绘制代码，它们都能在定义好的上下文（context）中正常使用。</p><p>Blender的上下文（Context）由bContext结构体表示，其API定义在BKE_context.h文件中。获取上下文（context）信息几乎都是使用<code>CTX_data_*</code>或者<code>CTX_wm_*</code>这些类型的函数（它们将bContext结构体对象作为参数），而设置上下文（context）则可以在screens、areas或者regions中懒设置（done lazily）。</p><h1 id="What’s-in-the-context"><a href="#What’s-in-the-context" class="headerlink" title="What’s in the context?"></a>What’s in the context?</h1><p>在以下那张图中，值得注意是，它并不反映谁调用谁，而是反映出有哪些不同类型的数据是在上下文（context）中的。</p><p><img src="https://wiki.blender.org/w/images/5/56/Context_2.5_what.png" alt=""></p><p><code>User Preferences</code>是全局的、且并非是真正意义上的上下文，所有的代码都可以访问它。紧接着是<code>Main</code>，是一个拥有自己数据块的<code>.blend</code>文件，还包括了相关联的<code>.blend</code>文件的数据块。我们应该假设有很多个这样子的文件同时被打开，但现在还未能实现。</p><p>接下来出现了分歧，绘制（drawing）和交互式编辑代码（interactive editing code）可假设是跑在<code>Window Manager</code>下。他们总是工作在某一层级（Screen、Area或者Region）中。随着这些层级有了一定的数据，屏幕（the screen）就会拥有一个活动场景（active Scene），并且区域（areas and regions）可以额外地将其他的数据放进上下文（context），当然，这取决于区域的类型。</p><p>此外，我们有一些代码不能设定是窗口管理（window manager）控制的。但也不意味着它们不能被窗口管理调用，只是表示这些代码不属于窗口管理，也不需要使用窗口管理的方式调用它。这些代码可以不需要窗口选项而直接在后台运行，通常是用于渲染（rendering）、求值（Evalution）。渲染通常是通过一个场景和一些不在bContext结构体中的数据。</p><p>文件读写、内核函数以及窗口管理代码这些并没有显示在图中。但事实上，它们或多或少都存在上下文中，或者根本不包含在上下文指针中。</p><h1 id="Setting-Context"><a href="#Setting-Context" class="headerlink" title="Setting Context"></a>Setting Context</h1><p>首先我们得知道上下文（context）并不是持久化的。如果你想改变一个活动物体（active object），并非是通过上下文（context）设置它来实现。应当在场景（Scene）中设置对应的属性，然后再在上下文（context）中查找使用。上下文是进行操作（operator）或者绘制（drawing）时的临时本地状态。</p><p><strong>Callbacks</strong></p><p>上下文（context）主要由回调（callbacks）组成。屏幕（the Scene）、空间类型（space types）和区域类型（region types）都拥有一个上下文回调函数。这个函数接受一个上下文成员的名称，然后检查这个上下文是否知道这个成员，如果有，则返回一个RNA指针或者一个RNA指针集合。另外，每一个上下文回调都应该提供一个上下文成员列表。</p><p>举个例子，一个图片窗口空间类型的回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int image_context(const bContext *C, const char *member, bContextDataResult *result)</span><br><span class="line">&#123;</span><br><span class="line">    SpaceImage *sima&#x3D; CTX_wm_space_image(C);</span><br><span class="line"></span><br><span class="line">    if(CTX_data_dir(member)) &#123;</span><br><span class="line">        static const char *dir[] &#x3D; &#123;&quot;edit_image&quot;, NULL&#125;;</span><br><span class="line">        CTX_data_dir_set(result, dir);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(CTX_data_equals(member, &quot;edit_image&quot;)) &#123;</span><br><span class="line">        CTX_data_id_pointer_set(result, (ID*)ED_space_image(sima));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UI Layouts</strong></p><p>此外，还可以为UI布局指定更具体的上下文。主要用于修改器（modifiers）或者约束（constraints）。对于每一个修改器UI布局箱（modifier UI layout box），“修改器”设置进上下文，然后所有来自这个UI布局箱按钮的操作都可以从它的上下文中找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.set_context_pointer(&quot;group&quot;, group)</span><br></pre></td></tr></table></figure><p><strong>Lookups</strong></p><p>当一个上下文成员被请求，UI布局的上下文首先会被查找，接下来是区域回调（region callback,area callback）和屏幕回调（screen callback）。如果它被找到，就会返回对应的指针，假如找不到，则会返回一个空指针或者空集合。</p><p><img src="https://wiki.blender.org/w/images/thumb/0/06/Context_2.5_setting.png/640px-Context_2.5_setting.png" alt=""></p><h1 id="Getting-Context"><a href="#Getting-Context" class="headerlink" title="Getting Context"></a>Getting Context</h1><p><strong>Window Manager</strong></p><p>窗口管理上下文是最简单的，它仅仅是一些screen、area、space data、region和region data的指针。主要是你得确保它们应该被包含在上下文中。对于绘制函数，它们是相当清晰的，对于操作函数，在<code>poll</code>函数中进行检查或者在运行时验证是很重要的。如果不这样子做，用于在使用配置密钥映射时会导致崩溃。</p><p><strong>Data</strong></p><p>数据上下文就比较复杂了，重要的一点是要理解它是基于RNA指针集合的。这也可以使得python脚本自动用得了上下文。</p><p>在C中有两种方法去获取上下文的数据。某些访问器早已定义。请注意，在内部依旧是使用“edit_object”字符串来获取值，毕竟这很方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object *obedit&#x3D; CTX_data_edit_object(C);</span><br></pre></td></tr></table></figure><p>其它的那些可能没被定义，需要使用字符串去查找上下文成员。这并不能确保数据类型是正确的，所以需要指定想要的数据类型。下面例子返回一个RNA指针（注意看函数后面的<code>.data</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object *obedit&#x3D; CTX_data_pointer_get_type(C, &quot;edit_object&quot;, &amp;RNA_Object).data;</span><br></pre></td></tr></table></figure><p>在Python中更简单了，上下文的成员相当于它的属性（properties）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obedit &#x3D; context.object_edit</span><br></pre></td></tr></table></figure><p>集合（collections）也可以使用的，使用内部提供的宏会更加便捷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CTX_DATA_BEGIN(C, Base*, base, selected_editable_bases) &#123;</span><br><span class="line">    printf(&quot;object: %s\n&quot;, base-&gt;object-&gt;id.name);</span><br><span class="line">&#125;</span><br><span class="line">CTX_DATA_END;</span><br></pre></td></tr></table></figure><p><strong>Where to look</strong></p><p>并没有一个地方可以看到列表中所有的上下文成员。但可以找到某一个上下文成员，最好的方法是查找其相关的回调。也就是说，如果你正在使用图片窗口（image window），可以在<code>space_image.c</code>文件中查找上下文回调函数。</p><p>在Python中，可以实时地查找上下文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir(context))</span><br></pre></td></tr></table></figure><p><strong>Always Available</strong></p><p>一些上下文成员总是被设置，它们不需要使用<code>poll</code>函数去检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CTX_wm_manager</span><br><span class="line">CTX_wm_window</span><br><span class="line">CTX_wm_screen</span><br><span class="line"></span><br><span class="line">CTX_data_main</span><br><span class="line">CTX_data_scene</span><br><span class="line">CTX_data_tool_settings</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>更多的信息，可以在以下的文件中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source&#x2F;blender&#x2F;blenkernel&#x2F;BKE_context.h</span><br><span class="line">source&#x2F;blender&#x2F;blenkernel&#x2F;intern&#x2F;context.c</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Architecture/Con</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（三）——Blender工具窗口和控件实现的调用过程</title>
    <link href="https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/"/>
    <id>https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/</id>
    <published>2021-04-30T09:27:17.000Z</published>
    <updated>2021-05-08T09:33:59.372Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/">Blender源码学习（一）——blender项目，Blender main()入口</a>一文中讲解了Blender工具的程序入口，以及在文章末尾给出Blender源码层级布局。</p><p>Blender工具涉及的模块很多，可以从“窗口是如何做到跨平台实现”这一点作为切入点，先学习工具的“骨架”，然后再学习其他各个模块的实现。</p><h1 id="涉及模块"><a href="#涉及模块" class="headerlink" title="涉及模块"></a>涉及模块</h1><p><strong>ghost</strong></p><p>ghost位于<code>intern</code>目录下，是blender标准的跨平台操作系统工具（Stands for General Handy Operating System Toolkit）。</p><p>ghost主要负责窗口管理行为（window management actions）、OpenGL上下文和鼠标键盘事件（也包括一些不常见的硬件设备），底层使用继承多态方式实现调用对应操作系统的API。</p><p>值得注意的是，ghost是C++编写的，而blender是C编写的，所以ghost封装了一层，满足C调用C++代码的需求。</p><p><strong>windowmanager</strong></p><p>windowmanager位于<code>source/blender</code>目录下，负责blender窗口管理、事件系统、操作管理、线程管理等，作为窗口和功能的逻辑调度者。</p><p><strong>editors</strong></p><p>editors位于<code>source/blender</code>目录下，负责图形、工具和图形的绘制。</p><h1 id="窗口实现流程"><a href="#窗口实现流程" class="headerlink" title="窗口实现流程"></a>窗口实现流程</h1><p>Blender工具实现主要分两个部分，第一部分是用ghost创建的窗口（window），另一部分是使用OpenGL绘制的屏幕（screen）。</p><p>前者是框架，使用操作系统API创建的空白窗口；后者是内容，使用OpenGL的glew库绘制。</p><p><strong>ghost窗口</strong></p><p>调用路径如下：</p><p>main函数（creator.c） -&gt; WM_init函数（wm_init_exit.c） -&gt; wm_homefile_read函数（wm_files.c） -&gt; WM_check函数（wm.c） -&gt; wm_window_ghostwindows_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_add（wm_window.c） -&gt; GHOST_CreateWindow函数。</p><p><strong>screen</strong></p><p>调用路径如下：</p><p>main函数（creator.c） -&gt; WM_main函数（wm.c） -&gt; wm_window_process_events函数（wm_window.c） -&gt; GHOST_DispatchEvents函数（GHOST_C-api.cpp） -&gt; dispatchEvents函数（GHOST_System.cpp） -&gt; dispatchEvents函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; processEvent函数 -&gt; ghost_event_proc函数（wm_window.c）-&gt; wm_draw_update（wm_window.c） -&gt; wm_draw_window函数（wm_draw.c）···。</p><p>到<code>wm_draw_update</code>这一步的时候，<code>wm_draw_window</code>函数实现窗口绘制，<code>wm_window_swap_buffers</code>函数实现双缓冲，交换前后台数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void wm_draw_update(bContext *C)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  wm_draw_window(C, win);</span><br><span class="line">  wm_draw_update_clear_window(C, win);</span><br><span class="line">  wm_window_swap_buffers(win);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wm_draw_window</code>函数有两个操作，首先将所有的regions绘制出来，然后再把regions绘制在screen中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void wm_draw_window(bContext *C, wmWindow *win)</span><br><span class="line">&#123;</span><br><span class="line">  bScreen *screen &#x3D; WM_window_get_active_screen(win);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;* Draw area regions into their own framebuffer. This way we can redraw</span><br><span class="line">   * the areas that need it, and blit the rest from existing framebuffers. *&#x2F;</span><br><span class="line">  wm_draw_window_offscreen(C, win, stereo);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#x2F;* Now we draw into the window framebuffer, in full window coordinates. *&#x2F;</span><br><span class="line">  wm_draw_window_onscreen(C, win, -1);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="What’s-in-the-context"><a href="#What’s-in-the-context" class="headerlink" title="What’s in the context?"></a>What’s in the context?</h1><p><a href="https://wiki.blender.org/wiki/Source/Architecture/Context">官方文档</a></p><p><img src="https://wiki.blender.org/w/images/5/56/Context_2.5_what.png" alt="What&#39;s in the context"></p><p>上面图片展示了Blender模块之间的层级关系。</p><p>最顶层<code>User Preferences</code>为Main函数中创建的全局的bContext对象。</p><p>第二层<code>Main</code>表示一个<code>.blender</code>文件数据，包含其关联的其他<code>.blender</code>文件。</p><p>接下来分成两大块——<code>Window Manager</code>和<code>Scene</code>，前者负责窗口事件一类，后者负责场景数据块和渲染，这一类的操作数据可以不经过bContext进行数据传递。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/&quot;&gt;Blender源码学习（一）——blender项目，Blender main()入口&lt;/a&gt;一文中讲解了Blender工</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（二）——一些重要的结构体</title>
    <link href="https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/"/>
    <id>https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/</id>
    <published>2021-04-30T02:35:03.000Z</published>
    <updated>2021-05-07T08:28:12.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bContext结构体"><a href="#bContext结构体" class="headerlink" title="bContext结构体"></a>bContext结构体</h1><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context.c</span><br><span class="line">struct bContext &#123;</span><br><span class="line">  int thread;</span><br><span class="line"></span><br><span class="line">  &#x2F;* windowmanager context *&#x2F;</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct wmWindowManager *manager;</span><br><span class="line">    struct wmWindow *window;</span><br><span class="line">    struct WorkSpace *workspace;</span><br><span class="line">    struct bScreen *screen;</span><br><span class="line">    struct ScrArea *area;</span><br><span class="line">    struct ARegion *region;</span><br><span class="line">    struct ARegion *menu;</span><br><span class="line">    struct wmGizmoGroup *gizmo_group;</span><br><span class="line">    struct bContextStore *store;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Operator poll. *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Store the reason the poll function fails (static string, not allocated).</span><br><span class="line">     * For more advanced formatting use &#96;operator_poll_msg_dyn_params&#96;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    const char *operator_poll_msg;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Store values to dynamically to create the string (called when a tool-tip is shown).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    struct bContextPollMsgDyn_Params operator_poll_msg_dyn_params;</span><br><span class="line">  &#125; wm;</span><br><span class="line"></span><br><span class="line">  &#x2F;* data context *&#x2F;</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct Main *main;</span><br><span class="line">    struct Scene *scene;</span><br><span class="line"></span><br><span class="line">    int recursion;</span><br><span class="line">    &#x2F;** True if python is initialized. *&#x2F;</span><br><span class="line">    bool py_init;</span><br><span class="line">    void *py_context;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * If we need to remove members, do so in a copy</span><br><span class="line">     * (keep this to check if the copy needs freeing).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void *py_context_orig;</span><br><span class="line">  &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bContext结构体是Blender程序的上下文（整个程序只有一个），包含窗口管理者上下文（windowmanager context）和数据上下文（data context）。</p><p>bContext结构体中的对象通常使用<code>CTX_data_*</code>和<code>CTX_wm_*</code>函数中获取，并且其参数通常是延迟初始化。</p><p>bContext结构体对象在<code>creator.c</code>文件的<code>main</code>函数中创建，在<code>main</code>函数中使用情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">bContext *C;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">C &#x3D; CTX_create();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">main_args_setup(C, ba);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WM_init(C, argc, (const char **)argv);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CTX_py_init_set(C, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WM_keyconfig_init(C);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">FRS_set_context(C);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">main_args_setup_post(C, ba);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#ifndef WITH_PYTHON_MODULE</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F;</span><br><span class="line">    WM_exit(C);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (!G.file_loaded) &#123;</span><br><span class="line">      WM_init_splash(C);</span><br><span class="line">    &#125;</span><br><span class="line">    WM_main(C);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h1><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BKE_global.h</span><br><span class="line">typedef struct Global &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Active pointers. *&#x2F;</span><br><span class="line">  struct Main *main;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Strings: last saved *&#x2F;</span><br><span class="line">  char ima[1024], lib[1024]; &#x2F;* 1024 &#x3D; FILE_MAX *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;** When set: &#96;G_MAIN-&gt;name&#96; contains valid relative base path. *&#x2F;</span><br><span class="line">  bool relbase_valid;</span><br><span class="line">  bool file_loaded;</span><br><span class="line">  bool save_over;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Strings of recent opened files. *&#x2F;</span><br><span class="line">  struct ListBase recent_files;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Has escape been pressed or Ctrl+C pressed in background mode, used for render quit. *&#x2F;</span><br><span class="line">  bool is_break;</span><br><span class="line"></span><br><span class="line">  bool background;</span><br><span class="line">  bool factory_startup;</span><br><span class="line"></span><br><span class="line">  short moving;</span><br><span class="line"></span><br><span class="line">  &#x2F;** To indicate render is busy, prevent render-window events etc. *&#x2F;</span><br><span class="line">  bool is_rendering;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Debug value, can be set from the UI and python, used for testing nonstandard features.</span><br><span class="line">   * DO NOT abuse it with generic checks like &#96;if (G.debug_value &gt; 0)&#96;. Do not use it as bitflags.</span><br><span class="line">   * Only precise specific values should be checked for, to avoid unpredictable side-effects.</span><br><span class="line">   * Please document here the value(s) you are using (or a range of values reserved to some area).</span><br><span class="line">   *   * -16384 and below: Reserved for python (add-ons) usage.</span><br><span class="line">   *   *     -1: Disable faster motion paths computation (since 08&#x2F;2018).</span><br><span class="line">   *   * 1 - 30: EEVEE debug&#x2F;stats values (01&#x2F;2018).</span><br><span class="line">   *   *    101: Enable UI debug drawing of fullscreen area&#39;s corner widget (10&#x2F;2014).</span><br><span class="line">   *   *    666: Use quicker batch delete for outliners&#39; delete hierarchy (01&#x2F;2019).</span><br><span class="line">   *   *    777: Enable UI node panel&#39;s sockets polling (11&#x2F;2011).</span><br><span class="line">   *   *    799: Enable some mysterious new depsgraph behavior (05&#x2F;2015).</span><br><span class="line">   *   *   1112: Disable new Cloth internal springs handling (09&#x2F;2014).</span><br><span class="line">   *   *   1234: Disable new dyntopo code fixing skinny faces generation (04&#x2F;2015).</span><br><span class="line">   *   *   3001: Enable additional Fluid modifier (Mantaflow) options (02&#x2F;2020).</span><br><span class="line">   *   *   4000: Line Art state output and debugging logs (03&#x2F;2021).</span><br><span class="line">   *   * 16384 and above: Reserved for python (add-ons) usage.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  short debug_value;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Saved to the blend file as #FileGlobal.globalf,</span><br><span class="line">   * however this is now only used for runtime options. *&#x2F;</span><br><span class="line">  int f;</span><br><span class="line"></span><br><span class="line">  struct &#123;</span><br><span class="line">    &#x2F;** Logging vars (different loggers may use). *&#x2F;</span><br><span class="line">    int level;</span><br><span class="line">    &#x2F;** FILE handle or use stderr (we own this so close when done). *&#x2F;</span><br><span class="line">    void *file;</span><br><span class="line">  &#125; log;</span><br><span class="line"></span><br><span class="line">  &#x2F;** debug flag, #G_DEBUG, #G_DEBUG_PYTHON &amp; friends, set python or command line args *&#x2F;</span><br><span class="line">  int debug;</span><br><span class="line"></span><br><span class="line">  &#x2F;** This variable is written to &#x2F; read from #FileGlobal.fileflags *&#x2F;</span><br><span class="line">  int fileflags;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Message to use when auto execution fails. *&#x2F;</span><br><span class="line">  char autoexec_fail[200];</span><br><span class="line">&#125; Global;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;blender.c</span><br><span class="line">Global G;</span><br></pre></td></tr></table></figure><p>Global结构体主要是存放一些全局定义的变量、处于激活状态的节点（Active pointers）对象指针以及已经打开的文件链表（Strings of recent opened files）对象指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bContext结构体&quot;&gt;&lt;a href=&quot;#bContext结构体&quot; class=&quot;headerlink&quot; title=&quot;bContext结构体&quot;&gt;&lt;/a&gt;bContext结构体&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（一）——blender项目，Blender main()入口</title>
    <link href="https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/"/>
    <id>https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/</id>
    <published>2021-04-29T02:52:14.000Z</published>
    <updated>2021-04-30T01:32:20.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blender项目概括"><a href="#blender项目概括" class="headerlink" title="blender项目概括"></a>blender项目概括</h1><p>blender项目是Blender整个工程的入口，该项目输出文件为<code>blender.exe</code>。</p><p>blender项目位于<code>/blender/source/creator</code>目录下，文件只有几个：<code>creator_intern.h</code>、<code>buildinfo.c</code>、<code>creator.c</code>、<code>creator_args.c</code>、<code>creator_signals.c</code>。</p><p>其中，<code>creator.c</code>是关键文件，而其主要是包含一个<code>main</code>函数。</p><p><code>main</code>函数主要工作是：</p><ul><li><p>解析启动参数</p></li><li><p>根据启动参数启动各个子系统</p></li><li><p>检查是否后台运行，如果是，则使用Less-UI后台运行，否则，使用Use-UI运行。</p></li></ul><p>主要的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Blender&#39;s main function responsibilities are:</span><br><span class="line"> * - setup subsystems.</span><br><span class="line"> * - handle arguments.</span><br><span class="line"> * - run #WM_main() event loop,</span><br><span class="line"> *   or exit immediately when running in background-mode.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc,</span><br><span class="line">#ifdef WIN32</span><br><span class="line">         const char **UNUSED(argv_c)</span><br><span class="line">#else</span><br><span class="line">         const char **argv</span><br><span class="line">#endif</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  bContext *C;</span><br><span class="line">    </span><br><span class="line">  &#x2F;* Ensure we free data on early-exit. *&#x2F;</span><br><span class="line">  struct CreatorAtExitData app_init_data &#x3D; &#123;NULL&#125;;</span><br><span class="line">  BKE_blender_atexit_register(callback_main_atexit, &amp;app_init_data);</span><br><span class="line"></span><br><span class="line">  &#x2F;* NOTE: Special exception for guarded allocator type switch:</span><br><span class="line">   *       we need to perform switch from lock-free to fully</span><br><span class="line">   *       guarded allocator before any allocation happened.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; argc; i++) &#123;</span><br><span class="line">      if (STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)) &#123;</span><br><span class="line">        printf(&quot;Switching to fully guarded memory allocator.\n&quot;);</span><br><span class="line">        MEM_use_guarded_allocator();&#x2F;&#x2F;使用守卫式内存分配器</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (STREQ(argv[i], &quot;--&quot;)) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MEM_init_memleak_detection();&#x2F;&#x2F;初始化内存检测模块</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Initialize logging. *&#x2F;</span><br><span class="line">  CLG_init();</span><br><span class="line">  CLG_fatal_fn_set(callback_clg_fatal);</span><br><span class="line"></span><br><span class="line">  C &#x3D; CTX_create();  </span><br><span class="line"></span><br><span class="line">#ifdef WITH_LIBMV &#x2F;&#x2F;libmv为多视图重建库（LMV），是Blender运动跟踪能力的计算机视觉后端。</span><br><span class="line">  libmv_initLogging(argv[0]);</span><br><span class="line">#elif defined(WITH_CYCLES_LOGGING)</span><br><span class="line">  CCL_init_logging(argv[0]);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* Error output from the guarded allocation routines. *&#x2F;</span><br><span class="line">  main_callback_setup();</span><br><span class="line"></span><br><span class="line">  &#x2F;*start initialize subsystem*&#x2F;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;*end initialiize subsystem*&#x2F;</span><br><span class="line"></span><br><span class="line">#if defined(WITH_PYTHON_MODULE) || defined(WITH_HEADLESS)</span><br><span class="line">  &#x2F;* Python module mode ALWAYS runs in background-mode (for now). *&#x2F;</span><br><span class="line">  G.background &#x3D; true;</span><br><span class="line">#else</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    main_signal_setup_background();</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* Background render uses this font too. *&#x2F;</span><br><span class="line">  BKE_vfont_builtin_register(datatoc_bfont_pfb, datatoc_bfont_pfb_size);</span><br><span class="line"></span><br><span class="line">  &#x2F;* Explicitly free data allocated for argument parsing:</span><br><span class="line">   * - &#39;ba&#39;</span><br><span class="line">   * - &#39;argv&#39; on WIN32.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  callback_main_atexit(&amp;app_init_data);</span><br><span class="line">  BKE_blender_atexit_unregister(callback_main_atexit, &amp;app_init_data);</span><br><span class="line"></span><br><span class="line">  &#x2F;* End argument parsing, allow memory leaks to be printed. *&#x2F;</span><br><span class="line">  MEM_use_memleak_detection(true);</span><br><span class="line"></span><br><span class="line">#ifndef WITH_PYTHON_MODULE</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F;</span><br><span class="line">    WM_exit(C);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (!G.file_loaded) &#123;</span><br><span class="line">      WM_init_splash(C);</span><br><span class="line">    &#125;</span><br><span class="line">    WM_main(C);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1、UNUSED宏"><a href="#1、UNUSED宏" class="headerlink" title="1、UNUSED宏"></a>1、UNUSED宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BLI_memory_utils.h</span><br><span class="line">&#x2F;* UNUSED macro, for function argument *&#x2F;</span><br><span class="line">#if defined(__GNUC__) || defined(__clang__)</span><br><span class="line">#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))</span><br><span class="line">#else</span><br><span class="line">#  define UNUSED(x) UNUSED_##x</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(__GNUC__) || defined(__clang__)</span><br><span class="line">#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_##x</span><br><span class="line">#else</span><br><span class="line">#  define UNUSED_FUNCTION(x) UNUSED_##x</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">int main(int argc,</span><br><span class="line">#ifdef WIN32</span><br><span class="line">         const char **UNUSED(argv_c)</span><br><span class="line">#else</span><br><span class="line">         const char **argv</span><br><span class="line">#endif</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在<code>main</code>函数中使用了GNU C 的一个特性——<code>__attribute__((__unused__))</code>，用于编译时忽略未使用的警告。</p><h2 id="2、setvbuf-stdout-NULL-IONBF-0"><a href="#2、setvbuf-stdout-NULL-IONBF-0" class="headerlink" title="2、setvbuf(stdout, NULL, _IONBF, 0)"></a>2、setvbuf(stdout, NULL, _IONBF, 0)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">  &#x2F;* Un-buffered &#96;stdout&#96; makes &#96;stdout&#96; and &#96;stderr&#96; better synchronized, and helps</span><br><span class="line">   * when stepping through code in a debugger (prints are immediately</span><br><span class="line">   * visible). However disabling buffering causes lock contention on windows</span><br><span class="line">   * see T76767 for details, since this is a debugging aid, we do not enable</span><br><span class="line">   * the un-buffered behavior for release builds. *&#x2F;</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">  setvbuf(stdout, NULL, _IONBF, 0);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>使用<code>setvbuf</code>函数将输出缓冲去掉，信息可以更快的同步。</p><h2 id="3、-putenv-s函数"><a href="#3、-putenv-s函数" class="headerlink" title="3、_putenv_s函数"></a>3、_putenv_s函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  if defined(_MSC_VER)</span><br><span class="line">  _putenv_s(&quot;OMP_WAIT_POLICY&quot;, &quot;PASSIVE&quot;);&#x2F;&#x2F;添加程序的环境变量</span><br><span class="line">#  endif</span><br></pre></td></tr></table></figure><p><code>_putenv_s</code>函数可添加程序的环境变量（并非加在电脑全局环境变量中），对应获取程序的环境变量的函数是<code>getenv_s</code>。</p><h2 id="4、宏实现N个参数同时对比"><a href="#4、宏实现N个参数同时对比" class="headerlink" title="4、宏实现N个参数同时对比"></a>4、宏实现N个参数同时对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BLI_utildefines_variadic.h</span><br><span class="line">#define _VA_NARGS_GLUE(x, y) x y</span><br><span class="line">#define _VA_NARGS_RETURN_COUNT(\</span><br><span class="line">  _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _10_, _11_, _12_, _13_, _14_, _15_, _16_, \</span><br><span class="line">  _17_, _18_, _19_, _20_, _21_, _22_, _23_, _24_, _25_, _26_, _27_, _28_, _29_, _30_, _31_, _32_, \</span><br><span class="line">  _33_, _34_, _35_, _36_, _37_, _38_, _39_, _40_, _41_, _42_, _43_, _44_, _45_, _46_, _47_, _48_, \</span><br><span class="line">  _49_, _50_, _51_, _52_, _53_, _54_, _55_, _56_, _57_, _58_, _59_, _60_, _61_, _62_, _63_, _64_, \</span><br><span class="line">  count, ...) count</span><br><span class="line">#define _VA_NARGS_EXPAND(args) _VA_NARGS_RETURN_COUNT args</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO2(name, count) name##count</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO1(name, count) _VA_NARGS_OVERLOAD_MACRO2(name, count)</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO(name,  count) _VA_NARGS_OVERLOAD_MACRO1(name, count)</span><br><span class="line">&#x2F;* --- expose for re-use --- *&#x2F;</span><br><span class="line">&#x2F;* 64 args max *&#x2F;</span><br><span class="line">#define VA_NARGS_COUNT(...) _VA_NARGS_EXPAND((__VA_ARGS__, \</span><br><span class="line">  64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, \</span><br><span class="line">  48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, \</span><br><span class="line">  32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, \</span><br><span class="line">  16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2, 1, 0))</span><br><span class="line">#define VA_NARGS_CALL_OVERLOAD(name, ...) \</span><br><span class="line">  _VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BLI_string.h</span><br><span class="line">&#x2F;* Manual line breaks for readability. *&#x2F;</span><br><span class="line">&#x2F;* clang-format off *&#x2F;</span><br><span class="line">&#x2F;* STR_ELEM#(v, ...): is the first arg equal any others? *&#x2F;</span><br><span class="line">&#x2F;* Internal helpers. *&#x2F;</span><br><span class="line">#define _VA_STR_ELEM2(v, a) (strcmp(v, a) &#x3D;&#x3D; 0)</span><br><span class="line">#define _VA_STR_ELEM3(v, a, b) \</span><br><span class="line">  (_VA_STR_ELEM2(v, a) || (_VA_STR_ELEM2(v, b)))</span><br><span class="line">#define _VA_STR_ELEM4(v, a, b, c) \</span><br><span class="line">  (_VA_STR_ELEM3(v, a, b) || (_VA_STR_ELEM2(v, c)))</span><br><span class="line">#define _VA_STR_ELEM5(v, a, b, c, d) \</span><br><span class="line">  (_VA_STR_ELEM4(v, a, b, c) || (_VA_STR_ELEM2(v, d)))</span><br><span class="line">#define _VA_STR_ELEM6(v, a, b, c, d, e) \</span><br><span class="line">  (_VA_STR_ELEM5(v, a, b, c, d) || (_VA_STR_ELEM2(v, e)))</span><br><span class="line">#define _VA_STR_ELEM7(v, a, b, c, d, e, f) \</span><br><span class="line">  (_VA_STR_ELEM6(v, a, b, c, d, e) || (_VA_STR_ELEM2(v, f)))</span><br><span class="line">#define _VA_STR_ELEM8(v, a, b, c, d, e, f, g) \</span><br><span class="line">  (_VA_STR_ELEM7(v, a, b, c, d, e, f) || (_VA_STR_ELEM2(v, g)))</span><br><span class="line">#define _VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) \</span><br><span class="line">  (_VA_STR_ELEM8(v, a, b, c, d, e, f, g) || (_VA_STR_ELEM2(v, h)))</span><br><span class="line">#define _VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) \</span><br><span class="line">  (_VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) || (_VA_STR_ELEM2(v, i)))</span><br><span class="line">#define _VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) \</span><br><span class="line">  (_VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) || (_VA_STR_ELEM2(v, j)))</span><br><span class="line">#define _VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) \</span><br><span class="line">  (_VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) || (_VA_STR_ELEM2(v, k)))</span><br><span class="line">#define _VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) \</span><br><span class="line">  (_VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) || (_VA_STR_ELEM2(v, l)))</span><br><span class="line">#define _VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) \</span><br><span class="line">  (_VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) || (_VA_STR_ELEM2(v, m)))</span><br><span class="line">#define _VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) \</span><br><span class="line">  (_VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) || (_VA_STR_ELEM2(v, n)))</span><br><span class="line">#define _VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) \</span><br><span class="line">  (_VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) || (_VA_STR_ELEM2(v, o)))</span><br><span class="line">#define _VA_STR_ELEM17(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) \</span><br><span class="line">  (_VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) || (_VA_STR_ELEM2(v, p)))</span><br><span class="line">&#x2F;* clang-format on *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* reusable STR_ELEM macro *&#x2F;</span><br><span class="line">#define STR_ELEM(...) VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)</span><br></pre></td></tr></table></figure><p><code>STR_ELEM</code>宏实现了第一个参数与其他每个参数对比的能力，最后一层宏为<code>_VA_STR_ELEM5(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)</code>，最终展开为<code>(((strcmp(argv[i], &quot;-d&quot;) == 0) || (strcmp(argv[i], &quot;--debug&quot;) == 0)) || (strcmp(argv[i], &quot;--debug-memory&quot;) == 0)))...</code>。</p><p>这个宏有两个限制，其一是<code>_VA_STR_ELEM</code>系列宏的数量，在源码中只能处理16个参数的对比；其二是<code>VA_NARGS_COUNT</code>和<code>_VA_NARGS_RETURN_COUNT</code>宏枚举的数字，源码中最大值是64，超过64个参数的宏调用会报错。</p><p>下面解释下<code>STR_ELEM</code>宏的展开过程：</p><ul><li><p>首先，<code>STR_ELEM(...)</code>展开成<code>VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</code>，<code>_VA_STR_ELEM</code>是字符串，用于拼接<code>_VA_STR_ELEM</code>系列宏的前缀，<code>__VA_ARGS__</code>为可变参数的宏。</p></li><li><p>然后，<code>VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</code>展开成<code>_VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))</code>，<code>_VA_NARGS_GLUE</code>宏接受两个参数，然后将他们并排拼接（就比如<code>f(x)</code>中的<code>f</code>和<code>(x)</code>）。第一个参数是<code>_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))</code>，第二个参数是<code>(__VA_ARGS__)</code>。</p></li><li><p><code>_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))</code>中，<code>_VA_NARGS_OVERLOAD_MACRO</code>和<code>VA_NARGS_COUNT</code>宏的层级是一样的，前者是将参数<code>name</code>和<code>VA_NARGS_COUNT(__VA_ARGS__)</code>拼接，后者返回参数的个数。</p></li></ul><h1 id="Blender-code-layout"><a href="#Blender-code-layout" class="headerlink" title="Blender code layout"></a>Blender code layout</h1><p><img src="https://www.blender.org/bf/codelayout.jpg" alt="Blender code layout"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;blender项目概括&quot;&gt;&lt;a href=&quot;#blender项目概括&quot; class=&quot;headerlink&quot; title=&quot;blender项目概括&quot;&gt;&lt;/a&gt;blender项目概括&lt;/h1&gt;&lt;p&gt;blender项目是Blender整个工程的入口，该项目输出文件为&lt;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>blender快捷键汇总</title>
    <link href="https://www.chaguake.com/2021/04/28/blender-hot-key/"/>
    <id>https://www.chaguake.com/2021/04/28/blender-hot-key/</id>
    <published>2021-04-28T03:09:11.000Z</published>
    <updated>2021-04-28T07:34:26.934Z</updated>
    
    <content type="html"><![CDATA[<p>文章参考：</p><p><a href="https://blog.csdn.net/u012204304/article/details/89030370">Blender2.9入门篇</a></p><hr><h1 id="模拟游戏引擎角色操作（第一人称视角）"><a href="#模拟游戏引擎角色操作（第一人称视角）" class="headerlink" title="模拟游戏引擎角色操作（第一人称视角）"></a>模拟游戏引擎角色操作（第一人称视角）</h1><p>快捷键：<code>Shift</code> + <code>~</code></p><p>在blender下面的状态栏会有操作按键提示。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>1、快捷键：<code>Ctrl</code> + <code>Tab</code></p><p>弹出模式选择导航，鼠标移动选择（也可以左上角点击下拉框选择）。</p><p>2、快捷键：<code>Tab</code></p><p>快速进入编辑模式，再按一次返回物体模式。</p><p>3、快捷键：<code>G</code></p><p>移动选中物体，左键确认，右键取消。</p><p>再点击<code>X</code>或<code>Y</code>或<code>Z</code>键，可沿对应轴水平移动。</p><p>按住鼠标中键，可以在xyz轴上，快速实现物体从一个轴跳到另一个轴，并且带上对原点的偏移量。</p><p>4、快捷键：<code>Alt</code>  + <code>G</code></p><p>物体位置回归原点(0,0,0)。</p><p>5、快捷键：<code>Shift</code> + <code>A</code></p><p>打开Add菜单。</p><p>6、快捷键：<code>Ctrl</code> + <code>N</code></p><p>打开New File菜单。</p><p>7、快捷键：长按<code>Shift</code> + 其他</p><p>微调操作，使得数值增值步长变小。</p><p>8、快捷键：<code>Shift</code> + <code>R</code></p><p>重复上一个命令。</p><p>9、快捷键：<code>Ctrl</code> + <code>Z</code></p><p>撤销操作。</p><p>10、快捷键：<code>F3</code></p><p>弹出操作搜索窗口。</p><p>11、快捷键：<code>F2</code></p><p>选中物体重命名。</p><p>12、快捷键：<code>Ctrl</code> + <code>Space</code></p><p>视图最大化（右侧停靠窗隐藏）。</p><p>13、快捷键：<code>Ctrl</code> + <code>Shift</code> + <code>Space</code></p><p>视图全屏。</p><p>14、快捷键：<code>Z</code></p><p>弹出着色方式选择导航，鼠标移动选择（也可以右上角点击选择）。</p><p>15、快捷键：<code>Shift</code> + <code>Z</code></p><p>线框显示和实体显示切换。</p><p>16、快捷键：<code>Ctrl</code> + <code>~</code></p><p>显示/隐藏Gizmo（视图右上角竖着排列的控件）。</p><p>17、快捷键：<code>鼠标中键</code> + <code>上下移动</code></p><p>自由切换视角。</p><p>18、快捷键：<code>Alt</code> + <code>鼠标中键</code> + <code>上下移动</code></p><p>切换六个正视角（顶、底、前、后、左、右）。</p><p>也可以用数字键盘来切换视角：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">切换到顶视角</td><td style="text-align:center"><code>7</code></td></tr><tr><td style="text-align:center">切换到底视角</td><td style="text-align:center"><code>Ctrl</code> + <code>7</code></td></tr><tr><td style="text-align:center">切换到前视角</td><td style="text-align:center"><code>1</code></td></tr><tr><td style="text-align:center">切换到后视角</td><td style="text-align:center"><code>Ctrl</code> + <code>1</code></td></tr><tr><td style="text-align:center">切换到右视角</td><td style="text-align:center"><code>3</code></td></tr><tr><td style="text-align:center">切换到左视角</td><td style="text-align:center"><code>Ctrl</code> + <code>3</code></td></tr><tr><td style="text-align:center">切换到摄像机视角</td><td style="text-align:center"><code>0</code></td></tr><tr><td style="text-align:center">正交视图和透视图切换</td><td style="text-align:center"><code>5</code></td></tr><tr><td style="text-align:center">四视图和透视图切换</td><td style="text-align:center"><code>Ctrl</code> + <code>Alt</code> + <code>Q</code></td></tr><tr><td style="text-align:center">上下旋转视角</td><td style="text-align:center"><code>8</code>或<code>2</code></td></tr><tr><td style="text-align:center">左右旋转视角</td><td style="text-align:center"><code>6</code>或<code>4</code></td></tr><tr><td style="text-align:center">视角旋转180°</td><td style="text-align:center"><code>9</code></td></tr></tbody></table></div><p>19、快捷键：<code>N</code></p><p>显示/隐藏视图右侧停靠窗口。</p><p>20、快捷键：<code>Shift</code> + <code>鼠标中键</code></p><p>自由移动视图。</p><p>21、快捷键：<code>H</code></p><p>隐藏选中项。</p><p>22、快捷键：<code>Shift</code> + <code>H</code></p><p>隐藏未选中项。</p><p>23、快捷键：<code>Alt</code> + <code>H</code></p><p>显示所有隐藏对象。</p><p>24、快捷键：数字键盘<code>/</code></p><p>居中放大选中对象，再次点击返回原来视角。</p><p>25、快捷键：数字键盘<code>.</code></p><p>居中放大选中对象，不会返回原来视角。</p><p>26、快捷键：<code>Home</code> 或者 <code>Shift</code> + <code>C</code></p><p>完整显示场景所有对象（被隐藏除外）。</p><p>27、快捷键：<code>Ctrl</code> + <code>A</code></p><p>打开Apply菜单。</p><p>28、快捷键：<code>T</code></p><p>显示/隐藏视图左侧工具菜单。</p><p>29、快捷键：<code>Shift</code> + <code>Space</code></p><p>打开工具菜单，跟视图左侧工具菜单一样。</p><p>30、快捷键：<code>Shift</code> + <code>鼠标右键</code></p><p>放置游标在鼠标位置。</p><p>31、快捷键：<code>Shift</code> + <code>C</code></p><p>将游标放在原点(0,0,0)。</p><p>32、快捷键：<code>Shift</code> + <code>S</code></p><p>打开游标菜单导航。</p><p>33、快捷键：<code>&lt;</code></p><p>变换坐标系。同样可在视图上方点击下拉框切换。</p><p>34、快捷键：<code>&gt;</code></p><p>变换轴心点。同样可在视图上方点击下拉框切换。</p><p>35、快捷键：<code>Shift</code> + <code>D</code></p><p>复制。</p><p>36、快捷键：<code>Alt</code> + <code>D</code></p><p>关联复制。</p><p>37、快捷键：<code>Ctrl</code> + <code>J</code></p><p>将选中的所有对象模型合并成一个对象模型。</p><p>38、快捷键：<code>W</code></p><p>框选、套索、圈选工具切换。</p><p>39、快捷键：<code>Ctrl</code> + <code>M</code> </p><p>镜像（反向翻转），需要再输入轴键（<code>X</code>或<code>Y</code>或<code>Z</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012204304/article/details/89030370&quot;&gt;Blender2.9入门篇&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;模拟游戏引擎角色操作（第一人称视角）&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender工具" scheme="https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（四）——着色器</title>
    <link href="https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/"/>
    <id>https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/</id>
    <published>2021-04-22T08:53:15.000Z</published>
    <updated>2021-04-23T02:03:07.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl.com/Getting-started/Shaders">英文原文地址</a>    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">中文翻译地址</a></p><p>着色器（Shader）是运行在GPU上的小程序，用于图形渲染管线的某个特定部分。</p><p>而在OpenGL使用GLSL这一门着色器语言来实现着色器程序。</p><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#version version_number</span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 处理输入并进行一些图形操作</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 输出处理过的结果到输出变量</span><br><span class="line">  out_variable_name &#x3D; weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>GLSL包含C语言大部分默认的基础数据类型。</p><p>向量是GLSL中比较常用的数据类型，常见的类型形式如下（n代表分量的数量）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">vecn</td><td style="text-align:center">包含n个float分量的默认向量</td></tr><tr><td style="text-align:center">bvecn</td><td style="text-align:center">包含n个bool分量的向量</td></tr><tr><td style="text-align:center">ivecn</td><td style="text-align:center">包含n个int分量的向量</td></tr><tr><td style="text-align:center">uvecn</td><td style="text-align:center">包含n个unsigned int分量的向量</td></tr><tr><td style="text-align:center">dvecn</td><td style="text-align:center">包含n个double分量的向量</td></tr></tbody></table></div><p>向量支持重组特性，一个向量的分量可以由其他的向量组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec2 vect &#x3D; vec2(0.1, 0.1)</span><br><span class="line">vec4 result &#x3D; vec4(vect, 0.0, 0.0)</span><br><span class="line">vec4 result2 &#x3D; vec4(result.xyz, 1.0)</span><br></pre></td></tr></table></figure><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>GLSL定义了<code>in</code>和<code>out</code>关键字实现着色器的输入和输出。</p><p>下面举个例子，顶点着色器接收一个3个分量的顶点位置向量，然后输出一个4个分量的顶点颜色向量，它会作为片段着色器的输入。</p><p>顶点着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为0</span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; &#x2F;&#x2F; 为片段着色器指定一个颜色输出</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos, 1.0); &#x2F;&#x2F; 注意我们如何把一个vec3作为vec4的构造器的参数</span><br><span class="line">    vertexColor &#x3D; vec4(0.5, 0.0, 0.0, 1.0); &#x2F;&#x2F; 把输出变量设置为暗红色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; &#x2F;&#x2F; 从顶点着色器传来的输入变量（名称相同、类型相同）</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h2><p>uniform提供了从CPU应用程序向GPU着色器程序发送数据的能力。</p><p>并且，uniform变量是全局的，它必须在每个着色器程序对象中有且只有一个，并且它可以被着色器程序的任意着色器在任意阶段访问。</p><p>使用方法如下：</p><p>在片段着色器中定义uniform变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; &#x2F;&#x2F; 在OpenGL程序代码中设定这个变量</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C/C++代码中，使用<code>glGetUniformLocation</code>函数获取该uniform变量，然后使用<code>glUniform4f</code>函数对其赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float timeValue &#x3D; glfwGetTime();</span><br><span class="line">float greenValue &#x3D; (sin(timeValue) &#x2F; 2.0f) + 0.5f;</span><br><span class="line">int vertexColorLocation &#x3D; glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure><p>值得注意的是，如果<code>glGetUniformLocation</code>返回-1就代表没有找到这个位置值。</p><p>而且，<code>glUniform4f</code>函数是属于设置uniform函数族中的一个，因为OpenGL底层是C库，不支持重载。</p><h2 id="传递多个属性"><a href="#传递多个属性" class="headerlink" title="传递多个属性"></a>传递多个属性</h2><p>在上面的例子中，只是传递了顶点位置的属性到顶点着色器上，那怎样才能传递多个属性呢？</p><p>首先，先给出顶点属性数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 位置              &#x2F;&#x2F; 颜色</span><br><span class="line">     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   &#x2F;&#x2F; 右下</span><br><span class="line">    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   &#x2F;&#x2F; 左下</span><br><span class="line">     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    &#x2F;&#x2F; 顶部</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再顶点着色器代码中接收多个输入，每个输入使用<code>(location = n)</code>来做绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos;   &#x2F;&#x2F; 位置变量的属性位置值为 0 </span><br><span class="line">layout (location &#x3D; 1) in vec3 aColor; &#x2F;&#x2F; 颜色变量的属性位置值为 1</span><br><span class="line"></span><br><span class="line">out vec3 ourColor; &#x2F;&#x2F; 向片段着色器输出一个颜色</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos, 1.0);</span><br><span class="line">    ourColor &#x3D; aColor; &#x2F;&#x2F; 将ourColor设置为我们从顶点数据那里得到的输入颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(location = n)</code>对应C/C++代码中<code>glVertexAttribPointer</code>函数的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 位置属性</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">&#x2F;&#x2F; 颜色属性</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><p>给出顶点数据的存储结构图：</p><p><img src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt=""></p><p>最后输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/01/05/shaders3.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Shaders&quot;&gt;英文原文地址&lt;/a&gt;    &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Go语言基础——函数、方法和接口</title>
    <link href="https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/"/>
    <id>https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/</id>
    <published>2021-04-21T02:59:56.000Z</published>
    <updated>2021-04-21T07:20:07.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-函数、方法和接口"><a href="#1-4-函数、方法和接口" class="headerlink" title="1.4 函数、方法和接口"></a>1.4 函数、方法和接口</h1><p>函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口定义了方法的集合。</p><p>Go语言通过隐式接口机制实现鸭子面向对象模型（所谓鸭子就是走路像鸭子，叫声像鸭子，那么它就可以当作鸭子）。</p><h2 id="1-4-1-函数"><a href="#1-4-1-函数" class="headerlink" title="1.4.1 函数"></a>1.4.1 函数</h2><p>函数是一个操作序列，可以把它赋值给变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;具名函数</span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add &#x3D; Add</span><br><span class="line">add(1, 2)</span><br><span class="line">Add(1, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匿名函数</span><br><span class="line">var Add &#x3D; func(a, b int) &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(1, 2)</span><br></pre></td></tr></table></figure><p>函数的参数和返回值可以有多个，支持可变参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Swap(a, b int) &#123;</span><br><span class="line">    return b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Sum(a int, more ...int) int &#123;</span><br><span class="line">    for _, v :&#x3D; range more &#123;</span><br><span class="line">        a +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum :&#x3D; Sum(1, []int&#123;2, 3&#125;...)</span><br></pre></td></tr></table></figure><p>可以给返回值命名，这样子返回值变量就可以在函数中使用，并且return语句可以不用带返回值（假如return语句带了变量，这是将变量赋值给返回值）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func Sum(a int, more ...int) (sum int) &#123;</span><br><span class="line">    sum +&#x3D; a</span><br><span class="line">    for _, v :&#x3D; range more &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer关键字</strong></p><p>defer语句可以延迟执行一个函数，并且以栈的方式执行多个defer语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class="line">        defer func()&#123;fmt.Println(i)&#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Output:</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p><strong>Go语言中指针不是固定不变的</strong></p><p>Goroutine启动时只会分配很小的栈（4KB或8KB），在运行过程中才会不断扩充自己的栈空间，在增长过程中会拷贝之前的数据到新的内存空间。</p><p>并且，无法得知函数参数或局部变量到底是保存在栈中还是堆中。</p><h2 id="1-4-2-方法"><a href="#1-4-2-方法" class="headerlink" title="1.4.2 方法"></a>1.4.2 方法</h2><p>方法是关联类型的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (v *vType) Funcname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var v vType</span><br><span class="line">v.Funcname()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方法表达式特性</strong></p><p>可以使用方法表达式将方法还原为普通函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;func Funcname(v *vType)()&#123;...&#125;</span><br><span class="line">var Func &#x3D; (*vType).Funcname</span><br><span class="line">Func(v)</span><br></pre></td></tr></table></figure><p><strong>方法的继承</strong></p><p>Go语言不支持传统面向对象中的继承特性，但可通过组合的方式支持方法的继承——通过在结构体内置匿名的成员来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &quot;image&#x2F;color&quot;</span><br><span class="line"></span><br><span class="line">type Point struct &#123; X, Y float64 &#125;</span><br><span class="line"></span><br><span class="line">type ColoredPoint struct &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cp ColoredPoint</span><br><span class="line">cp.X &#x3D; 1</span><br><span class="line">cp.Point.X &#x3D; 2</span><br></pre></td></tr></table></figure><p>看似<code>cp.X</code>中<code>X</code>是属于<code>ColoredPoint</code>类型的，实际上<code>X</code>依旧是属于匿名成员<code>Point</code>的。因为在编译期间，<code>cp.X</code>会被展开成<code>cp.Point.X</code>。</p><h2 id="1-4-3-接口"><a href="#1-4-3-接口" class="headerlink" title="1.4.3 接口"></a>1.4.3 接口</h2><p>Go语言的接口类型是对其他类型行为的抽象和概括。而且，Go语言的借口类型是延迟绑定，可以实现类似虚函数的多态功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type UpperString string</span><br><span class="line"></span><br><span class="line">func (s UpperString) String() string &#123;</span><br><span class="line">    return strings.ToUpper(string(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">接口在fmt包中有定义：</span><br><span class="line">type fmt.Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Fprintln(os.Stdout, UpperString(&quot;hello, world&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言对接口类型的转换很灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a io.ReadCloser &#x3D; (*os.File)(f)&#x2F;&#x2F;隐式转换</span><br><span class="line">    b io.Reader &#x3D; a&#x2F;&#x2F;隐式转换</span><br><span class="line">    c io.Closer &#x3D; a&#x2F;&#x2F;隐式转换</span><br><span class="line">    d io.Reader &#x3D; c.(io.Reader)&#x2F;&#x2F;显式转换</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4-函数、方法和接口&quot;&gt;&lt;a href=&quot;#1-4-函数、方法和接口&quot; class=&quot;headerlink&quot; title=&quot;1.4 函数、方法和接口&quot;&gt;&lt;/a&gt;1.4 函数、方法和接口&lt;/h1&gt;&lt;p&gt;函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口</summary>
      
    
    
    
    <category term="书籍" scheme="https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="《Go语言高级编程》" scheme="https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Go语言基础——数组、字符串和切片</title>
    <link href="https://www.chaguake.com/2021/04/20/Go-base-knowledge-01/"/>
    <id>https://www.chaguake.com/2021/04/20/Go-base-knowledge-01/</id>
    <published>2021-04-20T09:14:25.000Z</published>
    <updated>2021-04-21T02:58:25.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-3-数组、字符串和切片"><a href="#1-3-数组、字符串和切片" class="headerlink" title="1.3 数组、字符串和切片"></a>1.3 数组、字符串和切片</h1><p>这三种数据类型，在底层，原始数据有着相同的内存结构；在上层，因为语法的限制而有着不同的行为表现。</p><ul><li><p>数组是一种值类型，虽然数组的元素可以修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理。</p></li><li><p>字符串底层是对应的字节数组，但是字符串的只读属性禁止了程序中对底层字节数组元素的修改。而且字符串赋值只是复制了数据地址和对应的长度。</p></li><li><p>切片的结构和字符串的结构相似，但是解除了只读限制。底层结构多了<code>cap</code>字段，用于表示切片的容量。</p></li></ul><p><em>Go语言的赋值和函数传参规则很简单，除闭包函数以引用的方式对外部变量访问之外，其他赋值和函数传参都是以传值的方式处理。</em></p><h2 id="1-3-1-数组"><a href="#1-3-1-数组" class="headerlink" title="1.3.1 数组"></a>1.3.1 数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组由零个或多个元素组成。</p><p>数组的长度是数组类型的组成部分，不同长度或不同类型的数据组成的数组都是不同的类型。</p><p>数组定义方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int&#x2F;&#x2F;[0, 0, 0]</span><br><span class="line">var b &#x3D; [...]int&#123;1, 2, 3&#125;&#x2F;&#x2F;[1, 2, 3]</span><br><span class="line">var c &#x3D; [...]int&#123;2:3, 1:2&#125;&#x2F;&#x2F;[0, 2, 3]</span><br><span class="line">var d &#x3D; [...]int&#123;1, 2, 4:5, 6&#125;&#x2F;&#x2F;[1, 2, 0, 0, 5, 6]</span><br></pre></td></tr></table></figure><p>数组是值语义，一个数组变量即整个数组，不能隐式地指向第一个元素的地址。</p><p>可以传递一个指向数组的指针，数组指针在使用上与数组变量差别不大：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [...]int&#123;1, 2, 3&#125;</span><br><span class="line">var b &#x3D; &amp;a</span><br><span class="line"></span><br><span class="line">fmt.Println(a[0])</span><br><span class="line">fmt.Println(b[0])</span><br><span class="line"></span><br><span class="line">for i :&#x3D; range a &#123;</span><br><span class="line">    fmt.Println(i, a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i, v :&#x3D; range b &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;效率性能比for range差</span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">    fmt.Println(i, a[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for range方式迭代，还可以忽略迭代时的下标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var times [5][0]int</span><br><span class="line">for range times &#123;</span><br><span class="line"> fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>times</code>是一个[5][0]int的二维数组，即<code>[[], [], [], [], []]</code>，整个数组的内存大小为0。</p><p>数组的类型可以是任意的，接口、结构体、函数都行。</p><p>长度为0的数组不占空间，可以用于占位或者类型声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1 :&#x3D; make(chan [0]int)</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">&#x2F;&#x2F;c1 :&#x3D; make(chan sttruct&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>fmt.Printf</code>打印数组的类型和详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; [...]int&#123;1, 2, 3&#125;</span><br><span class="line">fmt.Printf(&quot;b: %T\n&quot;, b)&#x2F;&#x2F;b: [3]int</span><br><span class="line">fmt.Printf(&quot;b: %#v\n&quot;, b)&#x2F;&#x2F;b: [3]int&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-2-字符串"><a href="#1-3-2-字符串" class="headerlink" title="1.3.2 字符串"></a>1.3.2 字符串</h2><p>字符串是不可改变的字符序列。</p><p>Go语言字符串的底层结构在<code>reflect.StringHeader</code>中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">    Data uintptr</span><br><span class="line">    Len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符串，与对应的byte数组的底层数据内存结构是一致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; &quot;hello, world&quot;</span><br><span class="line"></span><br><span class="line">var data &#x3D; [...]byte &#123;</span><br><span class="line">    &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串支持切片操作，不同位置的切片底层访问的是同一块内存数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; &quot;hello, world&quot;</span><br><span class="line"></span><br><span class="line">hello :&#x3D; s[:5]</span><br><span class="line">world :&#x3D; s[7:]</span><br><span class="line"></span><br><span class="line">s1 :&#x3D; &quot;hello, world&quot;[:5]&#x2F;&#x2F;&quot;hello, world&quot;[:5]与s[:5]指向的是用一个字符串常量</span><br><span class="line">s2 :&#x3D; &quot;hello, world&quot;[7:]</span><br></pre></td></tr></table></figure><p>除了使用<code>len</code>函数获取字符串长度之外，也可以使用<code>reflect.StringHeader</code>结构访问字符串的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;len(s):&quot;, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len)</span><br></pre></td></tr></table></figure><h2 id="1-3-3-切片"><a href="#1-3-3-切片" class="headerlink" title="1.3.3 切片"></a>1.3.3 切片</h2><p>切片可以说是一种简化版的动态数组。底层数据结构<code>reflect.SliceHeader</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">    Data uintptr</span><br><span class="line">    Len int</span><br><span class="line">    Cap int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cap</code>表示切片指向的内存空间的最大容量，会按照规则实现自动扩充。</p><p>切片的定义方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a []int&#x2F;&#x2F;nil切片，和nil相等</span><br><span class="line">    b &#x3D; []int&#123;&#125;&#x2F;&#x2F;空切片</span><br><span class="line">    c &#x3D; []int&#123;1, 2, 3&#125;&#x2F;&#x2F;有3个元素的切片，len和cap都为3</span><br><span class="line">    d &#x3D; c[:2]&#x2F;&#x2F;有2个元素的切片，len为2，cap为3</span><br><span class="line">    e &#x3D; c[0:2:cap(c)]&#x2F;&#x2F;有2个元素的切片，len为2，cap为3</span><br><span class="line">    f &#x3D; c[:0]&#x2F;&#x2F;有0个元素的切片，len为0，cap为3</span><br><span class="line">    g &#x3D; make([]int, 3)&#x2F;&#x2F;有三个元素的切片，len和cap都为3</span><br><span class="line">    h &#x3D; make([]int, 2, 3)&#x2F;&#x2F;有2个元素的切片，len为2，cap为3</span><br><span class="line">    i &#x3D; make([]int, 0, 3)&#x2F;&#x2F;有0个元素的切片，len为0，cap为3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>添加切片元素</strong></p><p>使用内置的<code>append</code>函数。值得注意的是，<code>append</code>函数有可能导致重新分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切片尾部添加N个元素</span><br><span class="line">a &#x3D; append(a, 1)</span><br><span class="line">a &#x3D; append(a, 2, 3)</span><br><span class="line">a &#x3D; append(a, []int&#123;5, 6&#125;...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切片头部添加N个元素</span><br><span class="line">a &#x3D; append([]int&#123;0&#125;, a...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切片中间添加N个元素</span><br><span class="line">a &#x3D; append(a[:4], append([]int&#123;4&#125;, a[4:]...)...)</span><br></pre></td></tr></table></figure><p>在切片中间添加元素时，<code>append</code>会创建临时切片。可使用<code>copy</code>函数和<code>append</code>函数组合，避免创建临时切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; append(a, 0)&#x2F;&#x2F;扩充空间，需要插入N个就扩充N</span><br><span class="line">copy(a[5:], a[4:])&#x2F;&#x2F;a[4:]后移一个位置</span><br><span class="line">a[4] &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>删除切片元素</strong></p><p>删除头部和尾部的元素，可直接重新赋值范围即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除尾部</span><br><span class="line">a &#x3D; a[:len(a)-1]</span><br><span class="line">a &#x3D; a[:len(a)-N]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除头部</span><br><span class="line">a &#x3D; a[1:]</span><br><span class="line">a &#x3D; a[N:]</span><br></pre></td></tr></table></figure><p>删除头部元素或中间元素也可以用<code>append</code>函数或<code>copy</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头部元素</span><br><span class="line">a &#x3D; append(a[:0], a[1:]...)</span><br><span class="line">a &#x3D; a[:copy(a, a[1:])]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中间元素</span><br><span class="line">a &#x3D; append(a[:i], a[i+1:]...)</span><br><span class="line">a &#x3D; a[:i + copy(a[i], a[i+1:])]</span><br></pre></td></tr></table></figure><p>切片高效操作的要点是降低内存分配的次数，尽量保证<code>append</code>函数操作不会超出<code>cap</code>的容量。</p><p>切片使用中，假如只使用了切片的一部分数据，应当拷贝到一个新的变量，避免切片底层数据的长期引用。</p><p><strong>切片类型强制转换</strong></p><p>通过切片底层结构<code>reflect.SliceHeader</code>来做指针的强制赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; []float64&#123;&#125;</span><br><span class="line">c :&#x3D; []int&#123;&#125;</span><br><span class="line"></span><br><span class="line">aHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">cHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">*cHdr &#x3D; *aHdr</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-3-数组、字符串和切片&quot;&gt;&lt;a href=&quot;#1-3-数组、字符串和切片&quot; class=&quot;headerlink&quot; title=&quot;1.3 数组、字符串和切片&quot;&gt;&lt;/a&gt;1.3 数组、字符串和切片&lt;/h1&gt;&lt;p&gt;这三种数据类型，在底层，原始数据有着相同的内存结构；</summary>
      
    
    
    
    <category term="书籍" scheme="https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="《Go语言高级编程》" scheme="https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用SQL命令集合</title>
    <link href="https://www.chaguake.com/2021/04/15/mysql-common-command/"/>
    <id>https://www.chaguake.com/2021/04/15/mysql-common-command/</id>
    <published>2021-04-15T03:27:46.000Z</published>
    <updated>2021-04-15T06:22:49.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="show-engines命令"><a href="#show-engines命令" class="headerlink" title="show engines命令"></a>show engines命令</h3><p>用于查看当前Mysql使用的数据库存储引擎。</p><p><img src="./show_engines.jpg" alt="show_engines命令结果"></p><h3 id="show-variables命令"><a href="#show-variables命令" class="headerlink" title="show variables命令"></a>show variables命令</h3><p>用于查看当前Mysql的配置情况。</p><p><img src="./show_variables.jpg" alt="show_variables命令输出"></p><h3 id="show-status-like-‘Table-’命令"><a href="#show-status-like-‘Table-’命令" class="headerlink" title="show status like ‘Table%’命令"></a>show status like ‘Table%’命令</h3><p>用于查看当前表使用状态，有两个关键的字段：<code>Table_locks_immediate</code>为表立即释放锁的次数，<code>Table_locks_waited</code>为表等待释放锁的次数。</p><p><img src="./show_status.jpg" alt="show status命令输出"></p><h3 id="show-status-like-‘innodb-row-lock-’命令"><a href="#show-status-like-‘innodb-row-lock-’命令" class="headerlink" title="show status like ‘innodb_row_lock%’命令"></a>show status like ‘innodb_row_lock%’命令</h3><p>用于查看行锁争夺情况。</p><p><img src="./show_status1.jpg" alt="show status命令输出"></p><h3 id="lock-table-unlock-table命令"><a href="#lock-table-unlock-table命令" class="headerlink" title="lock table/unlock table命令"></a>lock table/unlock table命令</h3><p>MyISAM数据库引擎加锁（解锁）操作。</p><h3 id="InnoDB-Monitors"><a href="#InnoDB-Monitors" class="headerlink" title="InnoDB Monitors"></a>InnoDB Monitors</h3><p>可创建InnoDB Monitors来观察发生锁冲突的表、数据行等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE innodb_monitor(a INT) ENGINE&#x3D;INNODB;</span><br><span class="line">Show innodb status \G;</span><br><span class="line">DROP TABLE innodb_monitor;</span><br></pre></td></tr></table></figure><h3 id="SELECT-…-LOCK-IN-SHARE-MODE命令"><a href="#SELECT-…-LOCK-IN-SHARE-MODE命令" class="headerlink" title="SELECT … LOCK IN SHARE MODE命令"></a>SELECT … LOCK IN SHARE MODE命令</h3><p>用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。</p><p>但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁。</p><h3 id="SELECT-…-FOR-UPDATE命令"><a href="#SELECT-…-FOR-UPDATE命令" class="headerlink" title="SELECT … FOR UPDATE命令"></a>SELECT … FOR UPDATE命令</h3><p>对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p><p>其他session可以查询，但是不能加共享锁。</p><h3 id="InnoDB的行锁与表锁"><a href="#InnoDB的行锁与表锁" class="headerlink" title="InnoDB的行锁与表锁"></a>InnoDB的行锁与表锁</h3><p>当使用索引来检索数据时，就会使用到行级锁，否则，将会使用表级锁。</p><p>比如，SELECT …WHERE … FOR UPDATE语句，如果where后面使用的是索引，那么这条语句就是行锁，否则是表锁。</p><p>而且，假如另一个session的SELECT …WHERE … FOR UPDATE语句通过另一个索引找到对应行，那还是会等待锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;show-engines命令&quot;&gt;&lt;a href=&quot;#show-engines命令&quot; class=&quot;headerlink&quot; title=&quot;show engines命令&quot;&gt;&lt;/a&gt;show engines命令&lt;/h3&gt;&lt;p&gt;用于查看当前Mysql使用的数据库存储引擎。</summary>
      
    
    
    
    <category term="数据库" scheme="https://www.chaguake.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://www.chaguake.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sunday字符串匹配算法</title>
    <link href="https://www.chaguake.com/2021/04/15/Sunday-alg/"/>
    <id>https://www.chaguake.com/2021/04/15/Sunday-alg/</id>
    <published>2021-04-15T00:45:40.000Z</published>
    <updated>2021-04-15T01:14:42.265Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><p><a href="https://blog.csdn.net/q547550831/article/details/51860017">字符串匹配——Sunday算法</a></p><p>Sunday算法比BM算法更快，并且方便不少。与KMP算法一样，迭代方向和字符比较方向都是从左到右。但匹配失效时取未参与匹配的第一个字符来做位数移动的判断依据。</p><ul><li><p>如果该字符没有在搜索字符串中出现则直接跳过，即移动位数 = 搜索字符串长度 + 1；</p></li><li><p>否则，其移动位数 = 搜索字符串长度 - 该字符最右出现的位置（以0开始） = 搜索字符串中该字符最右出现的位置到尾部的距离 + 1。（其实就是将搜索字符串最右出现的位置与该字符位置对齐）</p></li></ul><p>下面举例说明：</p><p>1.匹配失效时，判断字符<code>i</code>是否在模式串中出现，没有则移动模式串到字符<code>i</code>后面。</p><p><img src="https://img-blog.csdn.net/20160708122016780" alt=""></p><p>2.匹配失效时，判断字符<code>r</code>是否在模式串中出现，有则将模式串中最右出现字符<code>r</code>的位置与字符<code>r</code>的位置对齐。</p><p><img src="https://img-blog.csdn.net/20160708122307562" alt=""></p><p>3.完成匹配。</p><p><img src="https://img-blog.csdn.net/20160708122414877" alt=""></p><p>可以看出，Sunday算法十分快速地实现了匹配。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int Sunday(const string&amp; T, const string&amp; P) &#123;</span><br><span class="line">int n &#x3D; T.length();</span><br><span class="line">int m &#x3D; P.length();</span><br><span class="line"></span><br><span class="line">int shift[MAXNUM];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认值，移动m+1位</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; MAXNUM; i++)&#123;</span><br><span class="line">shift[i] &#x3D; m + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模式串P中每个字母出现的最后的下标</span><br><span class="line">&#x2F;&#x2F; 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">shift[P[i]] &#x3D; m - i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模式串开始位置在主串的哪里</span><br><span class="line">int s &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; 模式串已经匹配到的位置</span><br><span class="line">int j;</span><br><span class="line">while (s &lt;&#x3D; n - m) &#123;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while (T[s + j] &#x3D;&#x3D; P[j]) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#x2F;&#x2F; 匹配成功</span><br><span class="line">if (j &gt;&#x3D; m) &#123;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 找到主串中当前跟模式串匹配的最末字符的下一个字符</span><br><span class="line">&#x2F;&#x2F; 在模式串中出现最后的位置</span><br><span class="line">&#x2F;&#x2F; 所需要从(模式串末尾+1)移动到该位置的步数</span><br><span class="line">s +&#x3D; shift[T[s + m]];</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/q547550831/article/details/51860017&quot;&gt;字符串匹配——Sunday算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sunday算法比BM算法更快，并且方便不少。与KMP算法</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串算法" scheme="https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BM字符串匹配算法</title>
    <link href="https://www.chaguake.com/2021/04/14/Boyer-Moore-alg/"/>
    <id>https://www.chaguake.com/2021/04/14/Boyer-Moore-alg/</id>
    <published>2021-04-14T05:44:16.000Z</published>
    <updated>2021-04-14T09:19:27.946Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献有:</p><p><a href="https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf">BM字符串匹配算法论文</a></p><p><a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html">Boyer-Moore algorithm</a></p><hr><p>BM（Boyer-Moore）算法比KMP算法高效不少。KMP算法只有一个匹配规则，而BM算法有两个匹配规则，更加优化了迭代索引，减少不必要的比较次数。</p><p>BM算法的主要思想是：源字符串迭代方向依旧是从左到右，源字符串与搜索字符串的比较方向是从左到右。遇到不匹配情况时，根据两个匹配规则，定位下一次源字符串与搜索字符串比较的位置。</p><h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><p>BM算法定义了两个匹配规则，在每一次调整搜索字符串位置时，移动位数由两个匹配规则判断返回值中的最大值决定。</p><h2 id="坏字符规则（bad-character-shift）。"><a href="#坏字符规则（bad-character-shift）。" class="headerlink" title="坏字符规则（bad-character shift）。"></a>坏字符规则（bad-character shift）。</h2><p>当源字符串中的某个字符与搜索字符串中的某个字符不匹配时，则源字符串中的那个字符称之为坏字符。</p><p>这时，搜索字符串向右移动的位数 = 已完成匹配字符集合（从右到左）的最后一个字符索引（从0开始） - 坏字符在搜索字符串中最右边出现的位置索引（从0开始）。</p><p>假如坏字符在搜索字符串中未出现，则移动位数值为-1。</p><p>坏字符规则下的两种判断情况：</p><ul><li>当搜索字符串不包含坏字符时，直接将搜索字符串移动到坏字符索引+1的位置（符合上面的计算公式）。</li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmbc2.gif" alt="The bad-character shift, b does not occur in x."></p><ul><li>当搜索字符串包含坏字符时，将搜索字符串中最右出现的位置与坏字符位置对齐。这就意味着可能出现搜索字符串位置回退的情况，不过没关系，最后计算的移动位数由两个匹配规则决定的。</li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmbc1.gif" alt="The bad-character shift, a occurs in x."></p><h2 id="好后缀规则（good-suffix-shift）。"><a href="#好后缀规则（good-suffix-shift）。" class="headerlink" title="好后缀规则（good-suffix shift）。"></a>好后缀规则（good-suffix shift）。</h2><p>当字符无法继续匹配时，称已完成匹配字符集合为好后缀，</p><p>搜索字符串向右移动的位数 = 搜索字符串最右的好后缀索引 - 搜索字符串倒数第二次出现的好后缀索引。</p><p>假如好后缀在搜索字符串中只出现一次，则移动位数值为-1。</p><p>好后缀规则下的三种判断情况：</p><ul><li><p>搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配且没有其他前缀子字符串与好后缀的后缀子字符串适配时，直接将搜索字符串移动到好后缀后面的字符位置。</p></li><li><p>搜索字符串中除了已经匹配上好后缀的那一个子字符串，还存在其他子字符串与好后缀适配时，则将搜索字符串倒数第二个适配的子字符串与好后缀对齐。</p></li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmgs1.gif" alt="The good-suffix shift, u re-occurs preceded by a character c different from a."></p><ul><li>搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配，但存在其他前缀子字符串与好后缀的后缀子字符串适配时，则将它们对齐。</li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmgs2.gif" alt="The good-suffix shift, only a suffix of u re-occurs in x."></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面以实例来进行详解，如何用代码实现BM算法。</p><p>现在有一个源字符串<code>cbcccacacabccabc</code>，和一个搜索字符串<code>cabcca</code>，想要得到源字符串是否包含搜索字符串，有则输出位置索引。</p><p>根据坏字符规则，需要创建一个字符位置映射表，用于记录坏字符在搜索字符串中最右边的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;char_table大小要大于等于会出现的所有字符种类数</span><br><span class="line">&#x2F;&#x2F;int char_table[MAXNUM + 1];</span><br><span class="line">&#x2F;&#x2F;memset(char_table, -1, sizeof(char) *(MAXNUM + 1));</span><br><span class="line">void InitCharTable(const char *search, unsigned int len, int *char_table) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        char_table[search[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据好后缀规则，需要创建前缀子字符串索引表和后缀子字符串索引表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void InitGoodSuffixTable(const char *search, int len, int *suffix, bool *prefix) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 1; i++) &#123; &#x2F;&#x2F;范围从第一个字符到倒数第二个字符</span><br><span class="line">int j &#x3D; i;</span><br><span class="line">int k &#x3D; 0;</span><br><span class="line">while (j &gt;&#x3D; 0 &amp;&amp; search[j] &#x3D;&#x3D; search[len - 1 - k]) &#123;&#x2F;&#x2F;通过j、k同时往前回朔找相同的字符</span><br><span class="line">    suffix[++k] &#x3D; --j + 1;&#x2F;&#x2F;在后缀子字符串的后一个字符标记偏移量，兼容a[0]的情况</span><br><span class="line">&#125;</span><br><span class="line">if (j &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    prefix[k] &#x3D; true;&#x2F;&#x2F;前缀子字符串最多只有一个，在结束的字符上标记结束符号（设为true）</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">输出结果：</span><br><span class="line">suffix：[-1, 1, 0, -1, -1, -1]。</span><br><span class="line">prefix：[false, false, true, false, false, false]。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>移动位数的函数需要跟前缀子字符串索引表和后缀子字符串索引表的生成方式绑定使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int MoveIndexByGS(int bcindex, int len, int *suffix, bool *prefix) &#123;</span><br><span class="line">    int gslen &#x3D; len - 1 - bcindex;</span><br><span class="line">    if (suffix[gslen] !&#x3D; -1) &#123;</span><br><span class="line">return bcindex - suffix[gslen] + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int r &#x3D; bcindex + 2; r &lt;&#x3D; len - 1; r++) &#123;</span><br><span class="line">if (prefix[len - r])</span><br><span class="line">    return r;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BM算法的实现逻辑函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int BM(const char *str, int len,const char *search, int slen) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;bad char rule tables</span><br><span class="line">    int char_table[MAXNUM + 1];</span><br><span class="line">    memset(char_table, -1, sizeof(char_table));</span><br><span class="line">    InitCharTable(search, slen, char_table);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;good suffix rule tables</span><br><span class="line">    int suffix[MAXNUM + 1];</span><br><span class="line">    bool prefix[MAXNUM + 1];</span><br><span class="line">    memset(suffix, -1, sizeof(suffix));</span><br><span class="line">    memset(prefix, false, sizeof(prefix));</span><br><span class="line">    InitGoodSuffixTable(search, slen, suffix, prefix);</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while (i &lt;&#x3D; len - slen) &#123;</span><br><span class="line">int j;</span><br><span class="line">for (j &#x3D; slen - 1; j &gt;&#x3D; 0; j--) &#123;</span><br><span class="line">    &#x2F;&#x2F;fine bad char</span><br><span class="line">    if (str[i + j] !&#x3D; search[j])</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (j &lt; 0) &#123;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find bad char position</span><br><span class="line">int x &#x3D; j - char_table[(int)str[i + j]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; find good suffix position</span><br><span class="line">int y &#x3D; 0;</span><br><span class="line">if (j &lt; slen - 1) &#123;</span><br><span class="line">    y &#x3D; MoveIndexByGS(j, slen, suffix, prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;get the max offset</span><br><span class="line">i &#x3D; i + max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文献有:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf&quot;&gt;BM字符串匹配算法论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www-igm.uni</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串算法" scheme="https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>KMP字符串匹配算法</title>
    <link href="https://www.chaguake.com/2021/04/12/knuth-morris-pratt-alg/"/>
    <id>https://www.chaguake.com/2021/04/12/knuth-morris-pratt-alg/</id>
    <published>2021-04-12T06:07:04.000Z</published>
    <updated>2021-04-12T07:23:08.137Z</updated>
    
    <content type="html"><![CDATA[<p><em>在日常工作中，我们经常需要在文本中搜寻某些特定的字符串，那作为使用者的你，有没有想过其算法的实现呢？</em></p><p>举个例子，假如有一个源字符串“ablshvaabcadababcskilils”，如何判断其是否包含搜索字符串“abcadaba”？</p><p>一般想到的做法是暴力遍历匹配方法：遍历源字符串，然后取出与搜索字符串相同长度的子字符串做比较，不匹配就将迭代索引+1，再取出与搜索字符串相同长度的子字符串做比较，直到迭代结束。时间复杂度为$O(m*n)$，取决于源字符串和搜索字符串的长度。</p><p><img src="https://img-blog.csdnimg.cn/20200422194813187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F0dHJhY3QxMjA2,size_16,color_FFFFFF,t_70#pic_center" alt="网图，如侵权请联系删除"></p><p>不难发现，在子字符串与搜索字符串做比较时，很大程度上，有部分操作是与上一次比较时重复的，那能否设计一种模式，减少这部分的重复工作呢？</p><h1 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h1><p>KMP算法是通过添加部分匹配表（Partial Match Table）来减少重复搜索工作的算法，它其实是对暴力遍历匹配方法的优化算法，在搜索字符串没有部分匹配字符串的时候，会退化成暴力遍历匹配方法。</p><p><img src="https://img-blog.csdnimg.cn/20200422194829782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F0dHJhY3QxMjA2,size_16,color_FFFFFF,t_70#pic_center" alt="网图，如侵权请联系删除"></p><p>如上图，在匹配失败时，无须回退到上一迭代器+1的位置，而是从下一个部分匹配字符串的位置开始迭代。</p><p><strong>部分匹配字符串和部分匹配表</strong></p><p>首先，先理解“前缀子字符串”和“后缀子字符串”的概念。</p><p>前缀子字符串：把搜索字符串的最后一个字符去掉，所有包含搜索字符串第一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的前缀字符串是<code>a、ab、abc、abca、abcad、abcada、abcadab</code>。</p><p>后缀子字符串：把搜索字符串的第一个字符去掉，所有包含搜索字符串最后一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的后缀字符串是<code>bcadaba、cadaba、adaba、daba、aba、ba、a</code>。</p><p>把同时出现在所有前缀字符串和后缀字符串中的，包含搜索字符串第一个字符且连续的子字符串称为部分匹配字符串，所有部分匹配字符串的集合称为部分匹配表。如上面的搜索字符串“abcadaba”，它的部分匹配表的元素有：<code>a、ab</code>。</p><p><strong>代码实现部分匹配表</strong></p><p>我们需要记录部分匹配字符串第二次出现的位置。</p><p>创建一个与搜索字符串相同长度的整型数组，默认初始化值为0，用于存储在搜索字符串对应位置上，部分匹配字符串的长度。如上面的搜索字符串“abcadaba”，它的部分匹配表最终为：<code>[0, 0, 0, 1, 0, 1, 2, 0]。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void GetPartialMatch(const std::string &amp;strTarget, int *arr)</span><br><span class="line">&#123;</span><br><span class="line">    int max_pre_size &#x3D; strTarget.length() - 1;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; max_pre_size; i++)&#123;</span><br><span class="line"></span><br><span class="line">        std::string strTmp1 &#x3D; strTarget.substr(0, i + 1);</span><br><span class="line">        for (size_t j &#x3D; 1; j &lt; max_pre_size; j++)&#123;</span><br><span class="line">    std::string strTmp2 &#x3D; strTarget.substr(j, i + 1);</span><br><span class="line"></span><br><span class="line">    if (strTmp1 &#x3D;&#x3D; strTmp2) &#123;</span><br><span class="line">        arr[j + i] &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KMP算法实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void KMP(const std::string &amp;strSrc, const std::string &amp;strTarget, const int *arr)</span><br><span class="line">&#123;</span><br><span class="line">    int match_index &#x3D; 0;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; strSrc.length();)&#123;</span><br><span class="line">if (strSrc[i] &#x3D;&#x3D; strTarget[match_index]) &#123;</span><br><span class="line">    if (match_index + 1 &#x3D;&#x3D; strTarget.length()) &#123;</span><br><span class="line">printf(&quot;match success,sub str index[%d].\n&quot;, i - match_index);</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    match_index++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    if (match_index &gt; 0) &#123;</span><br><span class="line">match_index &#x3D; arr[match_index];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;match fail.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;在日常工作中，我们经常需要在文本中搜寻某些特定的字符串，那作为使用者的你，有没有想过其算法的实现呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;举个例子，假如有一个源字符串“ablshvaabcadababcskilils”，如何判断其是否包含搜索字符串“abcadaba”？&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串算法" scheme="https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++如何获取不定数量的输入参数？</title>
    <link href="https://www.chaguake.com/2021/04/09/C-knowledge-cin/"/>
    <id>https://www.chaguake.com/2021/04/09/C-knowledge-cin/</id>
    <published>2021-04-09T09:15:26.000Z</published>
    <updated>2021-04-09T09:22:45.559Z</updated>
    
    <content type="html"><![CDATA[<p>刷题时偶尔会出现输入不定数量的参数，主要是使用<code>std::cin</code>来实现。</p><p>使用<code>Ctrl Z</code>（Windows）或<code>Ctrl D</code>（UNIX）结束输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">int value;</span><br><span class="line">while(std::cin&gt;&gt;value)&#123;</span><br><span class="line">    vec.push_back(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回车结束输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">int value;</span><br><span class="line">while(std::cin&gt;&gt;value)&#123;</span><br><span class="line">    vec.push_back(value);</span><br><span class="line">    if(std::cin.get() &#x3D;&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刷题时偶尔会出现输入不定数量的参数，主要是使用&lt;code&gt;std::cin&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Ctrl Z&lt;/code&gt;（Windows）或&lt;code&gt;Ctrl D&lt;/code&gt;（UNIX）结束输入：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.chaguake.com/categories/C-C/"/>
    
    
    <category term="C/C++知识" scheme="https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP对接异常——Server端宕机</title>
    <link href="https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/"/>
    <id>https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/</id>
    <published>2021-04-08T00:42:22.000Z</published>
    <updated>2021-04-09T08:51:45.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。</p><p>Server端使用boost的asio库，性能应该有保障的。</p><p>首先，查看日志，排查对应代码片段，未发现有出现”死锁“的逻辑，只能从wireshark抓包分析了。</p><p>现场同事把抓包发回一看，好家伙，一堆的”TCP ZeroWindow”和”RST“！</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>1、统计一下http请求情况，</p><p><img src="./http_statistic.jpg" alt="Http统计"></p><p>才三百多次http请求，远远没达到正常水平，排除Server端处理瓶颈问题。</p><p>2、输入筛选条件<code>tcp.flags.syn</code>，看看tcp三次握手情况。</p><p><img src="./syn.jpg" alt="syn统计"></p><p>Client新连接都直接被Server端拒绝了，Server端的连接数已经达到了极限。</p><p>而Server端在处理完http请求之后都会断开当前连接，并非长连接模式。并且，根据Server端的http处理耗时来看，还算正常。</p><p>问题估计在已建立但是未正常关闭的连接上，粗略看下，基本都会出现”TCP ZeroWindow“标记。</p><p>3、随机追踪一条出现”TCP ZeroWindow“的tcp连接，</p><p><img src="./tcp_zerowindow.jpg" alt="tcp zerowindow"></p><p>统计了下，出现这情况的连接大概有两百条，那就有可能出现同时并发的连接数大于<code>CPU数量*2+1</code>的情况。</p><p>而且，100个tcp包就出现滑动窗口占满的情况是不可能的，问题肯定出现在这里了。</p><p>经过排查，终于发现问题所在：</p><p><img src="./problem.jpg" alt="问题所在"></p><p>如上图，Server端最后回复给Client端包中，<code>Win</code>的值为5632，表示Server端还能接收5632个包。</p><p>并且<code>Ack</code>值为126929，希望Client下一个包的<code>Seq</code>序号值从126929开始。果不其然，Client端紧接着的包中<code>Seq</code>序号值为126929。</p><p>看Server端回复“TCP ZeroWindow”包的前一个由Client端发出的包LAST，它的<code>Seq</code>值为131273。</p><p>不难看出，<code>131273 - 126929 = 4344 &lt; 5632</code>，这时还可以正常接收。</p><p>但是展开那个包LAST中的<code>Next Seq</code>值是132609，<code>132609 - 126929 = 5680 &gt; 5632</code>，已经超出<code>Win</code>大小，所以，Server端接收到包LAST之后就返回“TCP ZeroWindow”包。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>1、Client端更改<code>Seq</code>的生成规则，使得<code>Seq</code>自增步长减少。</p><p>抓包中可以看出，Client端<code>Seq</code>的自增步长是1448。</p><p>2、Server端将滑动窗口变大。</p><p>由于Client端会发送<code>PSH</code>包通知Srever端清空缓冲，那么Server端可以将滑动窗口变大，避免出现“TCP ZeroWindow”情况。</p><p>3、优化Srever端“接收请求-&gt;回复请求”的耗时，避免同时出现异常连接并发数大于<code>CPU数量*2+1</code>的情况。</p><p>这种方法依旧是没办法解决问题所在的，只是尽量避免宕机情况出现。</p><p>4、Server端添加tcp连接的timeout处理。</p><p>Server端主动关闭超过timeout时间没有接收到http请求的连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。&lt;/p&gt;
&lt;p&gt;Server端</summary>
      
    
    
    
    <category term="问题排查" scheme="https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="问题排查之TCP" scheme="https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手</title>
    <link href="https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/"/>
    <id>https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/</id>
    <published>2021-04-07T02:13:50.000Z</published>
    <updated>2021-04-07T07:03:49.700Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。</p><p>参考文献有：</p><p><a href="https://segmentfault.com/a/1190000021740112">TCP三次握手、四次挥手出现意外情况时，为保证稳定，是如何处理的？</a></p><p><a href="https://yuanrengu.com/2020/77eef79f.html">面试官，不要再问我三次握手和四次挥手</a></p><h1 id="三次握手正常流程"><a href="#三次握手正常流程" class="headerlink" title="三次握手正常流程"></a>三次握手正常流程</h1><p>三次是TCP建立连接的最小次数，因为在三次握手中，双方都经历了”请求-&gt;应答“的过程。</p><p><img src="https://image-static.segmentfault.com/106/870/1068704971-3084b02c4479b0c7_fix732" alt="三次握手状态流程图"></p><p>三次握手流程步骤：</p><ol><li><p>在初始时，双端处于<code>CLOSE</code>状态，服务端(Server)为了提供服务，会主动监听某个端口，进入<code>LISTEN</code>状态。</p></li><li><p>客户端(Client)主动发送连接的<code>SYN</code>包，之后进入<code>SYN-SENT</code>状态，服务端在收到客户端发来的<code>SYN</code>包后，回复<code>SYN,ACK</code>包，之后进入<code>SYN-RCVD</code>状态。</p></li><li><p>客户端收到服务端发来的<code>SYN,ACK</code>包后，可以确认对方存在，此时回复<code>ACK</code>包，并进入<code>ESTABLISHED</code>状态。</p></li><li><p>服务端收到最后一个<code>ACK</code>包后，也进入<code>ESTABLISHED</code>状态。</p></li></ol><p>三次握手重点是客户端和服务端的状态变化过程，比如：客户端在发送第三个<code>ACK</code>包的时候，状态就会变更成<code>ESTABLISHED</code>，而服务端需要在接收到客户端发出的第三个<code>ACK</code>包的时候，才将状态转换成<code>ESTABLISHED</code>。</p><h1 id="三次握手异常情况"><a href="#三次握手异常情况" class="headerlink" title="三次握手异常情况"></a>三次握手异常情况</h1><p>计算机网络的异常处理有时比正常处理得流程更为重要，毕竟，需要花费更大的消耗去判断是网络故障还是连接异常。</p><p><strong>1. <code>SYN</code>包丢失</strong></p><p>对于服务端，客户端还是”不存在的“。</p><p>对于客户端，无法清楚服务端是否接收到<code>SYN</code>包，所以客户端会进行重传<code>SYN</code>包的操作，一般重传三次，三次加起来大约是76s（采用指数退避算法）。</p><p>在代码层次上，客户端会阻塞在<code>connect</code>函数上，失败会返回异常信息。</p><p>可通过更改系统配置（<a href="https://blog.csdn.net/chenyulancn/article/details/16339427">Linux点击这里</a>、<a href="https://blog.csdn.net/niejiangshuai/article/details/86573338">Windows点击这里</a>）来实现配置重连次数和重连耗时。</p><p>也可以通过”ioctl(1)+select(timeout)“方式来间接实现连接超时控制。<a href="https://blog.csdn.net/czh8706/article/details/84931785">TCP/IP Connect时间自主设定</a></p><p><strong>2. <code>SYN+ACK</code>包丢失</strong></p><p>对于客户端，跟<code>SYN</code>包丢失的处理流程是一样的。</p><p>对于服务端，会触发重传操作，毕竟无法确定客户端是否收到<code>SYN+ACK</code>包，此时服务端的状态是<code>SYN_RCVD</code>。</p><p>当超过重传次数之后，服务端系统会发送<code>RST</code>包。</p><p><strong>3. <code>ACK</code>包丢失</strong></p><p>对于服务端，跟<code>SYN+ACK</code>包丢失的处理流程是一样的，处于<code>SYN-RCVD</code>状态。</p><p>对于客户端，<code>connect</code>函数已经正常返回，客户端已经进入<code>ESTABLISHED</code>状态，可以发送/接收数据了。</p><p>现在，服务端和客户端的状态不对等，那么客户端发给服务端的数据会怎么处理呢？</p><p>结合<a href="https://blog.csdn.net/zerooffdate/article/details/79359726">文章</a>来看，假如客户端发送的第一个数据包的<code>Seq</code>确认序号跟<code>ACK</code>包的<code>Seq</code>确认序号一样，那么，服务端将进入<code>ESTABLISHED</code>状态，正常连接。假如不一样，服务端会发送<code>RST</code>包，结束该连接。而在代码实现中，<code>connect</code>函数是在客户端回复<code>ACK</code>包之后就返回了，这时三次握手还没完成。</p><p>所以，可以在<code>conenct</code>函数返回之后，立即发送一个跟<code>ACK</code>包相同<code>Seq</code>确认序号的数据包（默认第一个数据包的<code>Seq</code>是跟<code>ACK</code>一样），哪怕服务端没有接收到<code>ACK</code>包，也可以正常进入<code>ESTABLISHED</code>状态。并且也可以验证连接是否成功，假如服务端返回<code>RST</code>包，则连接失败。</p><p>应用层上，使用select、poll或者epoll机制判断socket是否可写来确认连接是否已经建立。<a href="https://blog.csdn.net/ruixj/article/details/1756440">非阻塞socket 的连接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。&lt;/p&gt;
&lt;p&gt;参考文献有：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/119000002174</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="https://www.chaguake.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Reservoir Sampling 抽样算法</title>
    <link href="https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/"/>
    <id>https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/</id>
    <published>2021-04-04T16:20:31.000Z</published>
    <updated>2021-04-06T08:23:01.651Z</updated>
    
    <content type="html"><![CDATA[<p>“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。</p><p>但是，当m不是确定值呢？</p><p>可以使用Reservoir Sampling 抽样算法。</p><p>由于m是不确定的，那么使用[0,m]范围内随机产生数的方式就没办法使用。所以，需要设计一种方法，使得每个数被抽取的概率都是$\frac{n}{m}$。</p><h1 id="一、”每次都是-frac-1-i-”问题"><a href="#一、”每次都是-frac-1-i-”问题" class="headerlink" title="一、”每次都是 $\frac{1}{i}$”问题"></a>一、”每次都是 $\frac{1}{i}$”问题</h1><p><em>对于<code>n</code>(n&gt;=1)，如果每次（基数<code>k</code>从0到n递增）以$\frac{1}{i}$的概率决定是否替换选中元素直到<code>n</code>，那么最后每个元素被选中的概率相等，即为$\frac{1}{n}。$ </em></p><p>证明：</p><ul><li><p>假设最后被选中的元素<code>a</code>(a&lt;=n)，它是在第<code>k</code>(k&lt;=n)次被选中。也就是说在第<code>k</code>次之后都不会有元素被选中，这样子才能确保最后选中的元素是<code>a</code>。</p></li><li><p>那么它被选中的概率等于第<code>k</code>次被选中的概率*第<code>k</code>次以后都没有元素选中。</p></li></ul><script type="math/tex; mode=display">\frac{1}{k} × \frac{k}{k+1} × \frac{k+1}{k+2} × ··· × \frac{n-1}{n} = \frac{1}{n}</script><p>可以得到结论：在未知样本空间<code>n</code>中，随机抽取一个数<code>a</code>，它的概率是$\frac{1}{n}$。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Sampling(std::vector&lt;int&gt; &amp;vec, int &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; 1; i &lt; vec.size(); i++)&#123;</span><br><span class="line">int random &#x3D; rand() % i;</span><br><span class="line">num &#x3D; vec[random];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、如何从未知样本空间m随机抽取n个数"><a href="#二、如何从未知样本空间m随机抽取n个数" class="headerlink" title="二、如何从未知样本空间m随机抽取n个数"></a>二、如何从未知样本空间m随机抽取n个数</h1><p>假如按照第一点中的方法，抽取n个数。的确也是能实现$\frac{n}{m}$的概率，但是要遍历n次，时间复杂度就顶不住了。</p><p>换个角度，假设，先取出前n个元素组成一个集合N，把第n+1个元素放进集合N，从集合N中抽取n个元素重新组成集合N，直至最后一个元素。</p><p>也就是说，第n+1个元素随机替换集合N中的一个元素。下面证明最后得出的集合N中，每个元素的概率是$\frac{n}{m}$。</p><p>证明：</p><ul><li><p>假设集合N中的任意一个元素<code>a</code>，它是第<code>k</code>(n&lt;=k&lt;=m)次被放进集合N，它最后留在集合N的概率 = 在它后面的元素都没有被抽中的概率 + 在它后面的元素被抽中的概率 * 没有替换元素<code>a</code>的概率。</p></li><li><p>根据第一点中的方法，第<code>k</code>(k&gt;=n)次某元素被选中并替换到集合N的概率是$\frac{1}{k} × n = \frac{n}{k}$。</p></li></ul><script type="math/tex; mode=display">\frac{n}{k} × (\frac{k+1-n}{k+1} + \frac{n}{k+1} × \frac{n-1}{n}) × (\frac{k+2-n}{k+2} + \frac{n}{k+2} × \frac{n-1}{n}) × ··· × \frac{m-n}{m} + \frac{n}{m} × \frac{n-1}{n}= \frac{n}{k} × \frac{k}{k+1} × \frac{k+1}{k+2} × ··· × \frac{m-1}{m} = \frac{n}{m}</script><p>证明成立，这个实现就是蓄水池抽样算法（Reservoir Sampling）。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ReservoirSampling(std::vector&lt;int&gt; &amp;vec,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; n; i &lt; vec.size(); i++) &#123;</span><br><span class="line">int random &#x3D; rand() % i;</span><br><span class="line">if(random &lt; n)&#123;</span><br><span class="line">    std::swap(vec[random], vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;up-low&gt;n</span><br><span class="line">void ReservoirSampling(std::vector&lt;int&gt; &amp;vec, int n, int low, int up)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; low + n; i &lt; up; i++) &#123;</span><br><span class="line">int random &#x3D; rand() % (up - low) + low;</span><br><span class="line">if (random &lt; low + n) &#123;</span><br><span class="line">    std::swap(vec[random], vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Reservoir Sampling 抽样算法的空间复杂度$O(1)$，时间复杂度$O(n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。&lt;/p&gt;
&lt;p&gt;但是，当m不是确定值呢？&lt;/p&gt;
&lt;p&gt;可以使用Reservoir Sampling 抽样算法。&lt;/p&gt;
&lt;p&gt;由于m是不确定的，那么使用</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="抽样算法" scheme="https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fisher Yates 洗牌算法</title>
    <link href="https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/"/>
    <id>https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/</id>
    <published>2021-04-02T06:29:14.000Z</published>
    <updated>2021-04-06T08:20:16.075Z</updated>
    
    <content type="html"><![CDATA[<p>洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。</p><h1 id="不加权模式"><a href="#不加权模式" class="headerlink" title="不加权模式"></a>不加权模式</h1><p>Fisher Yates洗牌算法凭借着$O(1)$空间、$O(n)$时间复杂度，实现了“在n个不同的数中随机取出m个数”一类的问题。</p><p>实现大致是将从未抽取集合中随机抽中的数x与未抽取集合中的最后一个数交换，未抽取集合个数-1。不断重复，直至未抽取集合个数为0。</p><p>实现细节：</p><ul><li><p>已知原始数组长度为n，将原始数组分为未抽取数组（长度为n）和取出数组（长度为0）。</p></li><li><p>在未抽取数组中，<strong>随机</strong>（算法依赖这个’随机‘是否够随机）选中一个数p，将数p的位置与原始数组最后一位（首位也行）交换。</p></li><li><p>重复上一个步骤，直到未抽取数组的个数为0。</p></li></ul><p><em>有点像选择排序，差异在于每次在’未排序‘区中找的不是最小（或最大）的，而是随机选一个。</em></p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void shuffle(int *arr,int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; nLen - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        int num &#x3D; rand() % i;</span><br><span class="line">        std::swap(arr[i], arr[num]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法脱离数学是不讲武德的，下面就证明：集合set有n个不同的数字，第i次抽取到的数字p的概率是否是都是$\frac{1}{n}$ 。</p><ul><li><p>第i次才抽中数字p，那么前i-1次都是没抽到数字p的。</p></li><li><p>第一次抽取，没抽到数字p的概率是$\frac{n-1}{n}$。</p></li><li><p>第二次抽取，没抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1}$。</p></li></ul><p>……</p><ul><li><p>第i-1次抽取，没抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1} × ··· × \frac{n-i}{n-i+1}$。</p></li><li><p>第i次抽取，抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1} × ··· × \frac{n-i}{n-i+1} × \frac{1}{n-i} = \frac{1}{n}$。</p></li></ul><p>Fisher Yates洗牌算法有两个随机因子，一个是每一次从未抽取集合抽取的元素，另一个是每一次未抽取集合最后一个元素，但最关键是第一个随机因子。</p><p>假如为每个元素加上权重，使得每个元素本身被抽中的优先度不一样，又如何用Fisher Yates洗牌算法来实现呢？</p><h1 id="加权模式"><a href="#加权模式" class="headerlink" title="加权模式"></a>加权模式</h1><p>一个比较笨重的办法,将元素按照其权重展开:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;a:2,b:3,c:1&#125;</span><br><span class="line">&#123;a,a,b,b,b,c&#125;</span><br></pre></td></tr></table></figure><p>（但显然不是好办法。=_=）</p><p>因为有了权重作为附加条件，再按照上面”从未抽取集合中随机抽取一个元素“的方式是不满足条件的，必须将权重参与到运算中（随机抽取）。</p><p>那么，可以将所有权重值加起来，得到一个权重总数sum，然后在0到sum的范围内随机产生一个数num，再将num与未抽取集合中每一个元素作某种比较，最后输出随机数。</p><p>步骤如下：</p><ul><li><p>统计出所有元素的权重和sum。</p></li><li><p>在0到sum之间随机产生一个随机数num，遍历未抽取集合。</p></li><li><p>用随机数num和当前迭代元素n比较。假如num小于n，结束迭代，返回元素n（与最后一位元素交换），sum-=n，重复第二步；假如num大于n，则num-=n，继续迭代。</p></li><li><p>遍历到未抽取集合的最后一个元素时，如果num大于n，则输出最后一个元素，sum-=n。</p></li><li><p>重复第二步。</p></li></ul><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void shuffle2(int *arr, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; nLen; i++)&#123;</span><br><span class="line">sum +&#x3D; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123;</span><br><span class="line">int num &#x3D; rand() % sum;</span><br><span class="line">size_t j &#x3D; 0;</span><br><span class="line">for (; j &lt; i; j++)&#123;</span><br><span class="line">    if (num &gt; arr[j]) &#123;</span><br><span class="line">num -&#x3D; arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -&#x3D; arr[j];</span><br><span class="line">std::swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度还是$O(1)$，但时间复杂度是$O(n+n^2)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。&lt;/p&gt;
&lt;h1 id=&quot;不加权模式&quot;&gt;&lt;a href=&quot;#不加权模式&quot; class=&quot;headerlink&quot; title=&quot;不加权模式&quot;&gt;&lt;/a&gt;不加权模式&lt;/h1&gt;&lt;p&gt;F</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="洗牌算法" scheme="https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
