<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶瓜客</title>
  
  <subtitle>解衣又作茶瓜客，倚槛同看烟雨峰</subtitle>
  <link href="https://www.chaguake.com/atom.xml" rel="self"/>
  
  <link href="https://www.chaguake.com/"/>
  <updated>2021-05-07T05:49:19.289Z</updated>
  <id>https://www.chaguake.com/</id>
  
  <author>
    <name>茶瓜客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Blender源码学习（三）——Blender工具窗口和控件的实现</title>
    <link href="https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/"/>
    <id>https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/</id>
    <published>2021-04-30T09:27:17.000Z</published>
    <updated>2021-05-07T05:49:19.289Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/">Blender源码学习（一）——blender项目，Blender main()入口</a>一文中讲解了Blender工具的程序入口，以及在文章末尾给出Blender源码层级布局。</p><p>Blender工具涉及的模块很多，可以从“窗口是如何做到跨平台实现”这一点作为切入点，先学习工具的“骨架”，然后再学习其他各个模块的实现。</p><h1 id="涉及模块"><a href="#涉及模块" class="headerlink" title="涉及模块"></a>涉及模块</h1><p><strong>ghost</strong></p><p>ghost位于<code>intern</code>目录下，是blender标准的跨平台操作系统工具（Stands for General Handy Operating System Toolkit）。</p><p>ghost主要负责窗口管理行为（window management actions）、OpenGL上下文和鼠标键盘事件（也包括一些不常见的硬件设备），底层使用继承多态方式实现调用对应操作系统的API。</p><p>值得注意的是，ghost是C++编写的，而blender是C编写的，所以ghost封装了一层，满足C调用C++代码的需求。</p><p><strong>windowmanager</strong></p><p>windowmanager位于<code>source/blender</code>目录下，负责blender窗口管理、事件系统、操作管理、线程管理等，作为窗口和功能的逻辑调度者。</p><p><strong>editors</strong></p><p>editors位于<code>source/blender</code>目录下，负责图形、工具和图形的绘制。</p><h1 id="窗口实现流程"><a href="#窗口实现流程" class="headerlink" title="窗口实现流程"></a>窗口实现流程</h1><p>Blender工具实现主要分两个部分，第一部分是用ghost创建的窗口（window），另一部分是使用OpenGL绘制的屏幕（screen）。</p><p>前者是框架，使用操作系统API创建的空白窗口；后者是内容，使用OpenGL的glew库绘制。</p><p><strong>ghost窗口</strong></p><p>调用路径如下：</p><p>main函数（creator.c） -&gt; WM_init函数（wm_init_exit.c） -&gt; wm_homefile_read函数（wm_files.c） -&gt; WM_check函数（wm.c） -&gt; wm_window_ghostwindows_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_add（wm_window.c） -&gt; GHOST_CreateWindow函数。</p><p><strong>screen</strong></p><p>调用路径如下：</p><p>main函数（creator.c） -&gt; WM_main函数（wm.c） -&gt; wm_window_process_events函数（wm_window.c） -&gt; GHOST_DispatchEvents函数（GHOST_C-api.cpp） -&gt; dispatchEvents函数（GHOST_System.cpp） -&gt; dispatchEvents函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; processEvent函数 -&gt; ghost_event_proc函数（wm_window.c）-&gt; wm_draw_update（wm_window.c） -&gt; wm_draw_window函数（wm_draw.c）···。</p><p>到<code>wm_draw_update</code>这一步的时候，<code>wm_draw_window</code>函数实现窗口绘制，<code>wm_window_swap_buffers</code>函数实现双缓冲，交换前后台数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void wm_draw_update(bContext *C)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  wm_draw_window(C, win);</span><br><span class="line">  wm_draw_update_clear_window(C, win);</span><br><span class="line">  wm_window_swap_buffers(win);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wm_draw_window</code>函数有两个操作，首先将所有的regions绘制出来，然后再把regions绘制在screen中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void wm_draw_window(bContext *C, wmWindow *win)</span><br><span class="line">&#123;</span><br><span class="line">  bScreen *screen &#x3D; WM_window_get_active_screen(win);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;* Draw area regions into their own framebuffer. This way we can redraw</span><br><span class="line">   * the areas that need it, and blit the rest from existing framebuffers. *&#x2F;</span><br><span class="line">  wm_draw_window_offscreen(C, win, stereo);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#x2F;* Now we draw into the window framebuffer, in full window coordinates. *&#x2F;</span><br><span class="line">  wm_draw_window_onscreen(C, win, -1);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/&quot;&gt;Blender源码学习（一）——blender项目，Blender main()入口&lt;/a&gt;一文中讲解了Blender工</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（二）——一些重要的结构体</title>
    <link href="https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/"/>
    <id>https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/</id>
    <published>2021-04-30T02:35:03.000Z</published>
    <updated>2021-04-30T03:04:04.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bContext结构体"><a href="#bContext结构体" class="headerlink" title="bContext结构体"></a>bContext结构体</h1><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context.c</span><br><span class="line">struct bContext &#123;</span><br><span class="line">  int thread;</span><br><span class="line"></span><br><span class="line">  &#x2F;* windowmanager context *&#x2F;</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct wmWindowManager *manager;</span><br><span class="line">    struct wmWindow *window;</span><br><span class="line">    struct WorkSpace *workspace;</span><br><span class="line">    struct bScreen *screen;</span><br><span class="line">    struct ScrArea *area;</span><br><span class="line">    struct ARegion *region;</span><br><span class="line">    struct ARegion *menu;</span><br><span class="line">    struct wmGizmoGroup *gizmo_group;</span><br><span class="line">    struct bContextStore *store;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Operator poll. *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Store the reason the poll function fails (static string, not allocated).</span><br><span class="line">     * For more advanced formatting use &#96;operator_poll_msg_dyn_params&#96;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    const char *operator_poll_msg;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Store values to dynamically to create the string (called when a tool-tip is shown).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    struct bContextPollMsgDyn_Params operator_poll_msg_dyn_params;</span><br><span class="line">  &#125; wm;</span><br><span class="line"></span><br><span class="line">  &#x2F;* data context *&#x2F;</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct Main *main;</span><br><span class="line">    struct Scene *scene;</span><br><span class="line"></span><br><span class="line">    int recursion;</span><br><span class="line">    &#x2F;** True if python is initialized. *&#x2F;</span><br><span class="line">    bool py_init;</span><br><span class="line">    void *py_context;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * If we need to remove members, do so in a copy</span><br><span class="line">     * (keep this to check if the copy needs freeing).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void *py_context_orig;</span><br><span class="line">  &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bContext结构体是Blender程序的上下文（整个程序只有一个），包含窗口管理者上下文（windowmanager context）和数据上下文（data context）。</p><p>bContext结构体对象在<code>creator.c</code>文件的<code>main</code>函数中创建，在<code>main</code>函数中使用情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">bContext *C;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">C &#x3D; CTX_create();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">main_args_setup(C, ba);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WM_init(C, argc, (const char **)argv);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CTX_py_init_set(C, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WM_keyconfig_init(C);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">FRS_set_context(C);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">main_args_setup_post(C, ba);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#ifndef WITH_PYTHON_MODULE</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F;</span><br><span class="line">    WM_exit(C);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (!G.file_loaded) &#123;</span><br><span class="line">      WM_init_splash(C);</span><br><span class="line">    &#125;</span><br><span class="line">    WM_main(C);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h1><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BKE_global.h</span><br><span class="line">typedef struct Global &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Active pointers. *&#x2F;</span><br><span class="line">  struct Main *main;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Strings: last saved *&#x2F;</span><br><span class="line">  char ima[1024], lib[1024]; &#x2F;* 1024 &#x3D; FILE_MAX *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;** When set: &#96;G_MAIN-&gt;name&#96; contains valid relative base path. *&#x2F;</span><br><span class="line">  bool relbase_valid;</span><br><span class="line">  bool file_loaded;</span><br><span class="line">  bool save_over;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Strings of recent opened files. *&#x2F;</span><br><span class="line">  struct ListBase recent_files;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Has escape been pressed or Ctrl+C pressed in background mode, used for render quit. *&#x2F;</span><br><span class="line">  bool is_break;</span><br><span class="line"></span><br><span class="line">  bool background;</span><br><span class="line">  bool factory_startup;</span><br><span class="line"></span><br><span class="line">  short moving;</span><br><span class="line"></span><br><span class="line">  &#x2F;** To indicate render is busy, prevent render-window events etc. *&#x2F;</span><br><span class="line">  bool is_rendering;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Debug value, can be set from the UI and python, used for testing nonstandard features.</span><br><span class="line">   * DO NOT abuse it with generic checks like &#96;if (G.debug_value &gt; 0)&#96;. Do not use it as bitflags.</span><br><span class="line">   * Only precise specific values should be checked for, to avoid unpredictable side-effects.</span><br><span class="line">   * Please document here the value(s) you are using (or a range of values reserved to some area).</span><br><span class="line">   *   * -16384 and below: Reserved for python (add-ons) usage.</span><br><span class="line">   *   *     -1: Disable faster motion paths computation (since 08&#x2F;2018).</span><br><span class="line">   *   * 1 - 30: EEVEE debug&#x2F;stats values (01&#x2F;2018).</span><br><span class="line">   *   *    101: Enable UI debug drawing of fullscreen area&#39;s corner widget (10&#x2F;2014).</span><br><span class="line">   *   *    666: Use quicker batch delete for outliners&#39; delete hierarchy (01&#x2F;2019).</span><br><span class="line">   *   *    777: Enable UI node panel&#39;s sockets polling (11&#x2F;2011).</span><br><span class="line">   *   *    799: Enable some mysterious new depsgraph behavior (05&#x2F;2015).</span><br><span class="line">   *   *   1112: Disable new Cloth internal springs handling (09&#x2F;2014).</span><br><span class="line">   *   *   1234: Disable new dyntopo code fixing skinny faces generation (04&#x2F;2015).</span><br><span class="line">   *   *   3001: Enable additional Fluid modifier (Mantaflow) options (02&#x2F;2020).</span><br><span class="line">   *   *   4000: Line Art state output and debugging logs (03&#x2F;2021).</span><br><span class="line">   *   * 16384 and above: Reserved for python (add-ons) usage.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  short debug_value;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Saved to the blend file as #FileGlobal.globalf,</span><br><span class="line">   * however this is now only used for runtime options. *&#x2F;</span><br><span class="line">  int f;</span><br><span class="line"></span><br><span class="line">  struct &#123;</span><br><span class="line">    &#x2F;** Logging vars (different loggers may use). *&#x2F;</span><br><span class="line">    int level;</span><br><span class="line">    &#x2F;** FILE handle or use stderr (we own this so close when done). *&#x2F;</span><br><span class="line">    void *file;</span><br><span class="line">  &#125; log;</span><br><span class="line"></span><br><span class="line">  &#x2F;** debug flag, #G_DEBUG, #G_DEBUG_PYTHON &amp; friends, set python or command line args *&#x2F;</span><br><span class="line">  int debug;</span><br><span class="line"></span><br><span class="line">  &#x2F;** This variable is written to &#x2F; read from #FileGlobal.fileflags *&#x2F;</span><br><span class="line">  int fileflags;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Message to use when auto execution fails. *&#x2F;</span><br><span class="line">  char autoexec_fail[200];</span><br><span class="line">&#125; Global;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;blender.c</span><br><span class="line">Global G;</span><br></pre></td></tr></table></figure><p>Global结构体主要是存放一些全局定义的变量、处于激活状态的节点（Active pointers）对象指针以及已经打开的文件链表（Strings of recent opened files）对象指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bContext结构体&quot;&gt;&lt;a href=&quot;#bContext结构体&quot; class=&quot;headerlink&quot; title=&quot;bContext结构体&quot;&gt;&lt;/a&gt;bContext结构体&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（一）——blender项目，Blender main()入口</title>
    <link href="https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/"/>
    <id>https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/</id>
    <published>2021-04-29T02:52:14.000Z</published>
    <updated>2021-04-30T01:32:20.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blender项目概括"><a href="#blender项目概括" class="headerlink" title="blender项目概括"></a>blender项目概括</h1><p>blender项目是Blender整个工程的入口，该项目输出文件为<code>blender.exe</code>。</p><p>blender项目位于<code>/blender/source/creator</code>目录下，文件只有几个：<code>creator_intern.h</code>、<code>buildinfo.c</code>、<code>creator.c</code>、<code>creator_args.c</code>、<code>creator_signals.c</code>。</p><p>其中，<code>creator.c</code>是关键文件，而其主要是包含一个<code>main</code>函数。</p><p><code>main</code>函数主要工作是：</p><ul><li><p>解析启动参数</p></li><li><p>根据启动参数启动各个子系统</p></li><li><p>检查是否后台运行，如果是，则使用Less-UI后台运行，否则，使用Use-UI运行。</p></li></ul><p>主要的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Blender&#39;s main function responsibilities are:</span><br><span class="line"> * - setup subsystems.</span><br><span class="line"> * - handle arguments.</span><br><span class="line"> * - run #WM_main() event loop,</span><br><span class="line"> *   or exit immediately when running in background-mode.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc,</span><br><span class="line">#ifdef WIN32</span><br><span class="line">         const char **UNUSED(argv_c)</span><br><span class="line">#else</span><br><span class="line">         const char **argv</span><br><span class="line">#endif</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  bContext *C;</span><br><span class="line">    </span><br><span class="line">  &#x2F;* Ensure we free data on early-exit. *&#x2F;</span><br><span class="line">  struct CreatorAtExitData app_init_data &#x3D; &#123;NULL&#125;;</span><br><span class="line">  BKE_blender_atexit_register(callback_main_atexit, &amp;app_init_data);</span><br><span class="line"></span><br><span class="line">  &#x2F;* NOTE: Special exception for guarded allocator type switch:</span><br><span class="line">   *       we need to perform switch from lock-free to fully</span><br><span class="line">   *       guarded allocator before any allocation happened.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; argc; i++) &#123;</span><br><span class="line">      if (STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)) &#123;</span><br><span class="line">        printf(&quot;Switching to fully guarded memory allocator.\n&quot;);</span><br><span class="line">        MEM_use_guarded_allocator();&#x2F;&#x2F;使用守卫式内存分配器</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (STREQ(argv[i], &quot;--&quot;)) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MEM_init_memleak_detection();&#x2F;&#x2F;初始化内存检测模块</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Initialize logging. *&#x2F;</span><br><span class="line">  CLG_init();</span><br><span class="line">  CLG_fatal_fn_set(callback_clg_fatal);</span><br><span class="line"></span><br><span class="line">  C &#x3D; CTX_create();  </span><br><span class="line"></span><br><span class="line">#ifdef WITH_LIBMV &#x2F;&#x2F;libmv为多视图重建库（LMV），是Blender运动跟踪能力的计算机视觉后端。</span><br><span class="line">  libmv_initLogging(argv[0]);</span><br><span class="line">#elif defined(WITH_CYCLES_LOGGING)</span><br><span class="line">  CCL_init_logging(argv[0]);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* Error output from the guarded allocation routines. *&#x2F;</span><br><span class="line">  main_callback_setup();</span><br><span class="line"></span><br><span class="line">  &#x2F;*start initialize subsystem*&#x2F;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;*end initialiize subsystem*&#x2F;</span><br><span class="line"></span><br><span class="line">#if defined(WITH_PYTHON_MODULE) || defined(WITH_HEADLESS)</span><br><span class="line">  &#x2F;* Python module mode ALWAYS runs in background-mode (for now). *&#x2F;</span><br><span class="line">  G.background &#x3D; true;</span><br><span class="line">#else</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    main_signal_setup_background();</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* Background render uses this font too. *&#x2F;</span><br><span class="line">  BKE_vfont_builtin_register(datatoc_bfont_pfb, datatoc_bfont_pfb_size);</span><br><span class="line"></span><br><span class="line">  &#x2F;* Explicitly free data allocated for argument parsing:</span><br><span class="line">   * - &#39;ba&#39;</span><br><span class="line">   * - &#39;argv&#39; on WIN32.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  callback_main_atexit(&amp;app_init_data);</span><br><span class="line">  BKE_blender_atexit_unregister(callback_main_atexit, &amp;app_init_data);</span><br><span class="line"></span><br><span class="line">  &#x2F;* End argument parsing, allow memory leaks to be printed. *&#x2F;</span><br><span class="line">  MEM_use_memleak_detection(true);</span><br><span class="line"></span><br><span class="line">#ifndef WITH_PYTHON_MODULE</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F;</span><br><span class="line">    WM_exit(C);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (!G.file_loaded) &#123;</span><br><span class="line">      WM_init_splash(C);</span><br><span class="line">    &#125;</span><br><span class="line">    WM_main(C);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1、UNUSED宏"><a href="#1、UNUSED宏" class="headerlink" title="1、UNUSED宏"></a>1、UNUSED宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BLI_memory_utils.h</span><br><span class="line">&#x2F;* UNUSED macro, for function argument *&#x2F;</span><br><span class="line">#if defined(__GNUC__) || defined(__clang__)</span><br><span class="line">#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))</span><br><span class="line">#else</span><br><span class="line">#  define UNUSED(x) UNUSED_##x</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(__GNUC__) || defined(__clang__)</span><br><span class="line">#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_##x</span><br><span class="line">#else</span><br><span class="line">#  define UNUSED_FUNCTION(x) UNUSED_##x</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">int main(int argc,</span><br><span class="line">#ifdef WIN32</span><br><span class="line">         const char **UNUSED(argv_c)</span><br><span class="line">#else</span><br><span class="line">         const char **argv</span><br><span class="line">#endif</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在<code>main</code>函数中使用了GNU C 的一个特性——<code>__attribute__((__unused__))</code>，用于编译时忽略未使用的警告。</p><h2 id="2、setvbuf-stdout-NULL-IONBF-0"><a href="#2、setvbuf-stdout-NULL-IONBF-0" class="headerlink" title="2、setvbuf(stdout, NULL, _IONBF, 0)"></a>2、setvbuf(stdout, NULL, _IONBF, 0)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">  &#x2F;* Un-buffered &#96;stdout&#96; makes &#96;stdout&#96; and &#96;stderr&#96; better synchronized, and helps</span><br><span class="line">   * when stepping through code in a debugger (prints are immediately</span><br><span class="line">   * visible). However disabling buffering causes lock contention on windows</span><br><span class="line">   * see T76767 for details, since this is a debugging aid, we do not enable</span><br><span class="line">   * the un-buffered behavior for release builds. *&#x2F;</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">  setvbuf(stdout, NULL, _IONBF, 0);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>使用<code>setvbuf</code>函数将输出缓冲去掉，信息可以更快的同步。</p><h2 id="3、-putenv-s函数"><a href="#3、-putenv-s函数" class="headerlink" title="3、_putenv_s函数"></a>3、_putenv_s函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  if defined(_MSC_VER)</span><br><span class="line">  _putenv_s(&quot;OMP_WAIT_POLICY&quot;, &quot;PASSIVE&quot;);&#x2F;&#x2F;添加程序的环境变量</span><br><span class="line">#  endif</span><br></pre></td></tr></table></figure><p><code>_putenv_s</code>函数可添加程序的环境变量（并非加在电脑全局环境变量中），对应获取程序的环境变量的函数是<code>getenv_s</code>。</p><h2 id="4、宏实现N个参数同时对比"><a href="#4、宏实现N个参数同时对比" class="headerlink" title="4、宏实现N个参数同时对比"></a>4、宏实现N个参数同时对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BLI_utildefines_variadic.h</span><br><span class="line">#define _VA_NARGS_GLUE(x, y) x y</span><br><span class="line">#define _VA_NARGS_RETURN_COUNT(\</span><br><span class="line">  _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _10_, _11_, _12_, _13_, _14_, _15_, _16_, \</span><br><span class="line">  _17_, _18_, _19_, _20_, _21_, _22_, _23_, _24_, _25_, _26_, _27_, _28_, _29_, _30_, _31_, _32_, \</span><br><span class="line">  _33_, _34_, _35_, _36_, _37_, _38_, _39_, _40_, _41_, _42_, _43_, _44_, _45_, _46_, _47_, _48_, \</span><br><span class="line">  _49_, _50_, _51_, _52_, _53_, _54_, _55_, _56_, _57_, _58_, _59_, _60_, _61_, _62_, _63_, _64_, \</span><br><span class="line">  count, ...) count</span><br><span class="line">#define _VA_NARGS_EXPAND(args) _VA_NARGS_RETURN_COUNT args</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO2(name, count) name##count</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO1(name, count) _VA_NARGS_OVERLOAD_MACRO2(name, count)</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO(name,  count) _VA_NARGS_OVERLOAD_MACRO1(name, count)</span><br><span class="line">&#x2F;* --- expose for re-use --- *&#x2F;</span><br><span class="line">&#x2F;* 64 args max *&#x2F;</span><br><span class="line">#define VA_NARGS_COUNT(...) _VA_NARGS_EXPAND((__VA_ARGS__, \</span><br><span class="line">  64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, \</span><br><span class="line">  48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, \</span><br><span class="line">  32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, \</span><br><span class="line">  16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2, 1, 0))</span><br><span class="line">#define VA_NARGS_CALL_OVERLOAD(name, ...) \</span><br><span class="line">  _VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BLI_string.h</span><br><span class="line">&#x2F;* Manual line breaks for readability. *&#x2F;</span><br><span class="line">&#x2F;* clang-format off *&#x2F;</span><br><span class="line">&#x2F;* STR_ELEM#(v, ...): is the first arg equal any others? *&#x2F;</span><br><span class="line">&#x2F;* Internal helpers. *&#x2F;</span><br><span class="line">#define _VA_STR_ELEM2(v, a) (strcmp(v, a) &#x3D;&#x3D; 0)</span><br><span class="line">#define _VA_STR_ELEM3(v, a, b) \</span><br><span class="line">  (_VA_STR_ELEM2(v, a) || (_VA_STR_ELEM2(v, b)))</span><br><span class="line">#define _VA_STR_ELEM4(v, a, b, c) \</span><br><span class="line">  (_VA_STR_ELEM3(v, a, b) || (_VA_STR_ELEM2(v, c)))</span><br><span class="line">#define _VA_STR_ELEM5(v, a, b, c, d) \</span><br><span class="line">  (_VA_STR_ELEM4(v, a, b, c) || (_VA_STR_ELEM2(v, d)))</span><br><span class="line">#define _VA_STR_ELEM6(v, a, b, c, d, e) \</span><br><span class="line">  (_VA_STR_ELEM5(v, a, b, c, d) || (_VA_STR_ELEM2(v, e)))</span><br><span class="line">#define _VA_STR_ELEM7(v, a, b, c, d, e, f) \</span><br><span class="line">  (_VA_STR_ELEM6(v, a, b, c, d, e) || (_VA_STR_ELEM2(v, f)))</span><br><span class="line">#define _VA_STR_ELEM8(v, a, b, c, d, e, f, g) \</span><br><span class="line">  (_VA_STR_ELEM7(v, a, b, c, d, e, f) || (_VA_STR_ELEM2(v, g)))</span><br><span class="line">#define _VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) \</span><br><span class="line">  (_VA_STR_ELEM8(v, a, b, c, d, e, f, g) || (_VA_STR_ELEM2(v, h)))</span><br><span class="line">#define _VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) \</span><br><span class="line">  (_VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) || (_VA_STR_ELEM2(v, i)))</span><br><span class="line">#define _VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) \</span><br><span class="line">  (_VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) || (_VA_STR_ELEM2(v, j)))</span><br><span class="line">#define _VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) \</span><br><span class="line">  (_VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) || (_VA_STR_ELEM2(v, k)))</span><br><span class="line">#define _VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) \</span><br><span class="line">  (_VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) || (_VA_STR_ELEM2(v, l)))</span><br><span class="line">#define _VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) \</span><br><span class="line">  (_VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) || (_VA_STR_ELEM2(v, m)))</span><br><span class="line">#define _VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) \</span><br><span class="line">  (_VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) || (_VA_STR_ELEM2(v, n)))</span><br><span class="line">#define _VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) \</span><br><span class="line">  (_VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) || (_VA_STR_ELEM2(v, o)))</span><br><span class="line">#define _VA_STR_ELEM17(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) \</span><br><span class="line">  (_VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) || (_VA_STR_ELEM2(v, p)))</span><br><span class="line">&#x2F;* clang-format on *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* reusable STR_ELEM macro *&#x2F;</span><br><span class="line">#define STR_ELEM(...) VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)</span><br></pre></td></tr></table></figure><p><code>STR_ELEM</code>宏实现了第一个参数与其他每个参数对比的能力，最后一层宏为<code>_VA_STR_ELEM5(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)</code>，最终展开为<code>(((strcmp(argv[i], &quot;-d&quot;) == 0) || (strcmp(argv[i], &quot;--debug&quot;) == 0)) || (strcmp(argv[i], &quot;--debug-memory&quot;) == 0)))...</code>。</p><p>这个宏有两个限制，其一是<code>_VA_STR_ELEM</code>系列宏的数量，在源码中只能处理16个参数的对比；其二是<code>VA_NARGS_COUNT</code>和<code>_VA_NARGS_RETURN_COUNT</code>宏枚举的数字，源码中最大值是64，超过64个参数的宏调用会报错。</p><p>下面解释下<code>STR_ELEM</code>宏的展开过程：</p><ul><li><p>首先，<code>STR_ELEM(...)</code>展开成<code>VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</code>，<code>_VA_STR_ELEM</code>是字符串，用于拼接<code>_VA_STR_ELEM</code>系列宏的前缀，<code>__VA_ARGS__</code>为可变参数的宏。</p></li><li><p>然后，<code>VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</code>展开成<code>_VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))</code>，<code>_VA_NARGS_GLUE</code>宏接受两个参数，然后将他们并排拼接（就比如<code>f(x)</code>中的<code>f</code>和<code>(x)</code>）。第一个参数是<code>_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))</code>，第二个参数是<code>(__VA_ARGS__)</code>。</p></li><li><p><code>_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))</code>中，<code>_VA_NARGS_OVERLOAD_MACRO</code>和<code>VA_NARGS_COUNT</code>宏的层级是一样的，前者是将参数<code>name</code>和<code>VA_NARGS_COUNT(__VA_ARGS__)</code>拼接，后者返回参数的个数。</p></li></ul><h1 id="Blender-code-layout"><a href="#Blender-code-layout" class="headerlink" title="Blender code layout"></a>Blender code layout</h1><p><img src="https://www.blender.org/bf/codelayout.jpg" alt="Blender code layout"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;blender项目概括&quot;&gt;&lt;a href=&quot;#blender项目概括&quot; class=&quot;headerlink&quot; title=&quot;blender项目概括&quot;&gt;&lt;/a&gt;blender项目概括&lt;/h1&gt;&lt;p&gt;blender项目是Blender整个工程的入口，该项目输出文件为&lt;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>blender快捷键汇总</title>
    <link href="https://www.chaguake.com/2021/04/28/blender-hot-key/"/>
    <id>https://www.chaguake.com/2021/04/28/blender-hot-key/</id>
    <published>2021-04-28T03:09:11.000Z</published>
    <updated>2021-04-28T07:34:26.934Z</updated>
    
    <content type="html"><![CDATA[<p>文章参考：</p><p><a href="https://blog.csdn.net/u012204304/article/details/89030370">Blender2.9入门篇</a></p><hr><h1 id="模拟游戏引擎角色操作（第一人称视角）"><a href="#模拟游戏引擎角色操作（第一人称视角）" class="headerlink" title="模拟游戏引擎角色操作（第一人称视角）"></a>模拟游戏引擎角色操作（第一人称视角）</h1><p>快捷键：<code>Shift</code> + <code>~</code></p><p>在blender下面的状态栏会有操作按键提示。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>1、快捷键：<code>Ctrl</code> + <code>Tab</code></p><p>弹出模式选择导航，鼠标移动选择（也可以左上角点击下拉框选择）。</p><p>2、快捷键：<code>Tab</code></p><p>快速进入编辑模式，再按一次返回物体模式。</p><p>3、快捷键：<code>G</code></p><p>移动选中物体，左键确认，右键取消。</p><p>再点击<code>X</code>或<code>Y</code>或<code>Z</code>键，可沿对应轴水平移动。</p><p>按住鼠标中键，可以在xyz轴上，快速实现物体从一个轴跳到另一个轴，并且带上对原点的偏移量。</p><p>4、快捷键：<code>Alt</code>  + <code>G</code></p><p>物体位置回归原点(0,0,0)。</p><p>5、快捷键：<code>Shift</code> + <code>A</code></p><p>打开Add菜单。</p><p>6、快捷键：<code>Ctrl</code> + <code>N</code></p><p>打开New File菜单。</p><p>7、快捷键：长按<code>Shift</code> + 其他</p><p>微调操作，使得数值增值步长变小。</p><p>8、快捷键：<code>Shift</code> + <code>R</code></p><p>重复上一个命令。</p><p>9、快捷键：<code>Ctrl</code> + <code>Z</code></p><p>撤销操作。</p><p>10、快捷键：<code>F3</code></p><p>弹出操作搜索窗口。</p><p>11、快捷键：<code>F2</code></p><p>选中物体重命名。</p><p>12、快捷键：<code>Ctrl</code> + <code>Space</code></p><p>视图最大化（右侧停靠窗隐藏）。</p><p>13、快捷键：<code>Ctrl</code> + <code>Shift</code> + <code>Space</code></p><p>视图全屏。</p><p>14、快捷键：<code>Z</code></p><p>弹出着色方式选择导航，鼠标移动选择（也可以右上角点击选择）。</p><p>15、快捷键：<code>Shift</code> + <code>Z</code></p><p>线框显示和实体显示切换。</p><p>16、快捷键：<code>Ctrl</code> + <code>~</code></p><p>显示/隐藏Gizmo（视图右上角竖着排列的控件）。</p><p>17、快捷键：<code>鼠标中键</code> + <code>上下移动</code></p><p>自由切换视角。</p><p>18、快捷键：<code>Alt</code> + <code>鼠标中键</code> + <code>上下移动</code></p><p>切换六个正视角（顶、底、前、后、左、右）。</p><p>也可以用数字键盘来切换视角：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">切换到顶视角</td><td style="text-align:center"><code>7</code></td></tr><tr><td style="text-align:center">切换到底视角</td><td style="text-align:center"><code>Ctrl</code> + <code>7</code></td></tr><tr><td style="text-align:center">切换到前视角</td><td style="text-align:center"><code>1</code></td></tr><tr><td style="text-align:center">切换到后视角</td><td style="text-align:center"><code>Ctrl</code> + <code>1</code></td></tr><tr><td style="text-align:center">切换到右视角</td><td style="text-align:center"><code>3</code></td></tr><tr><td style="text-align:center">切换到左视角</td><td style="text-align:center"><code>Ctrl</code> + <code>3</code></td></tr><tr><td style="text-align:center">切换到摄像机视角</td><td style="text-align:center"><code>0</code></td></tr><tr><td style="text-align:center">正交视图和透视图切换</td><td style="text-align:center"><code>5</code></td></tr><tr><td style="text-align:center">四视图和透视图切换</td><td style="text-align:center"><code>Ctrl</code> + <code>Alt</code> + <code>Q</code></td></tr><tr><td style="text-align:center">上下旋转视角</td><td style="text-align:center"><code>8</code>或<code>2</code></td></tr><tr><td style="text-align:center">左右旋转视角</td><td style="text-align:center"><code>6</code>或<code>4</code></td></tr><tr><td style="text-align:center">视角旋转180°</td><td style="text-align:center"><code>9</code></td></tr></tbody></table></div><p>19、快捷键：<code>N</code></p><p>显示/隐藏视图右侧停靠窗口。</p><p>20、快捷键：<code>Shift</code> + <code>鼠标中键</code></p><p>自由移动视图。</p><p>21、快捷键：<code>H</code></p><p>隐藏选中项。</p><p>22、快捷键：<code>Shift</code> + <code>H</code></p><p>隐藏未选中项。</p><p>23、快捷键：<code>Alt</code> + <code>H</code></p><p>显示所有隐藏对象。</p><p>24、快捷键：数字键盘<code>/</code></p><p>居中放大选中对象，再次点击返回原来视角。</p><p>25、快捷键：数字键盘<code>.</code></p><p>居中放大选中对象，不会返回原来视角。</p><p>26、快捷键：<code>Home</code> 或者 <code>Shift</code> + <code>C</code></p><p>完整显示场景所有对象（被隐藏除外）。</p><p>27、快捷键：<code>Ctrl</code> + <code>A</code></p><p>打开Apply菜单。</p><p>28、快捷键：<code>T</code></p><p>显示/隐藏视图左侧工具菜单。</p><p>29、快捷键：<code>Shift</code> + <code>Space</code></p><p>打开工具菜单，跟视图左侧工具菜单一样。</p><p>30、快捷键：<code>Shift</code> + <code>鼠标右键</code></p><p>放置游标在鼠标位置。</p><p>31、快捷键：<code>Shift</code> + <code>C</code></p><p>将游标放在原点(0,0,0)。</p><p>32、快捷键：<code>Shift</code> + <code>S</code></p><p>打开游标菜单导航。</p><p>33、快捷键：<code>&lt;</code></p><p>变换坐标系。同样可在视图上方点击下拉框切换。</p><p>34、快捷键：<code>&gt;</code></p><p>变换轴心点。同样可在视图上方点击下拉框切换。</p><p>35、快捷键：<code>Shift</code> + <code>D</code></p><p>复制。</p><p>36、快捷键：<code>Alt</code> + <code>D</code></p><p>关联复制。</p><p>37、快捷键：<code>Ctrl</code> + <code>J</code></p><p>将选中的所有对象模型合并成一个对象模型。</p><p>38、快捷键：<code>W</code></p><p>框选、套索、圈选工具切换。</p><p>39、快捷键：<code>Ctrl</code> + <code>M</code> </p><p>镜像（反向翻转），需要再输入轴键（<code>X</code>或<code>Y</code>或<code>Z</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012204304/article/details/89030370&quot;&gt;Blender2.9入门篇&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;模拟游戏引擎角色操作（第一人称视角）&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender工具" scheme="https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（四）——着色器</title>
    <link href="https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/"/>
    <id>https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/</id>
    <published>2021-04-22T08:53:15.000Z</published>
    <updated>2021-04-23T02:03:07.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl.com/Getting-started/Shaders">英文原文地址</a>    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">中文翻译地址</a></p><p>着色器（Shader）是运行在GPU上的小程序，用于图形渲染管线的某个特定部分。</p><p>而在OpenGL使用GLSL这一门着色器语言来实现着色器程序。</p><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#version version_number</span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 处理输入并进行一些图形操作</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 输出处理过的结果到输出变量</span><br><span class="line">  out_variable_name &#x3D; weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>GLSL包含C语言大部分默认的基础数据类型。</p><p>向量是GLSL中比较常用的数据类型，常见的类型形式如下（n代表分量的数量）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">vecn</td><td style="text-align:center">包含n个float分量的默认向量</td></tr><tr><td style="text-align:center">bvecn</td><td style="text-align:center">包含n个bool分量的向量</td></tr><tr><td style="text-align:center">ivecn</td><td style="text-align:center">包含n个int分量的向量</td></tr><tr><td style="text-align:center">uvecn</td><td style="text-align:center">包含n个unsigned int分量的向量</td></tr><tr><td style="text-align:center">dvecn</td><td style="text-align:center">包含n个double分量的向量</td></tr></tbody></table></div><p>向量支持重组特性，一个向量的分量可以由其他的向量组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec2 vect &#x3D; vec2(0.1, 0.1)</span><br><span class="line">vec4 result &#x3D; vec4(vect, 0.0, 0.0)</span><br><span class="line">vec4 result2 &#x3D; vec4(result.xyz, 1.0)</span><br></pre></td></tr></table></figure><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>GLSL定义了<code>in</code>和<code>out</code>关键字实现着色器的输入和输出。</p><p>下面举个例子，顶点着色器接收一个3个分量的顶点位置向量，然后输出一个4个分量的顶点颜色向量，它会作为片段着色器的输入。</p><p>顶点着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为0</span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; &#x2F;&#x2F; 为片段着色器指定一个颜色输出</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos, 1.0); &#x2F;&#x2F; 注意我们如何把一个vec3作为vec4的构造器的参数</span><br><span class="line">    vertexColor &#x3D; vec4(0.5, 0.0, 0.0, 1.0); &#x2F;&#x2F; 把输出变量设置为暗红色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; &#x2F;&#x2F; 从顶点着色器传来的输入变量（名称相同、类型相同）</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h2><p>uniform提供了从CPU应用程序向GPU着色器程序发送数据的能力。</p><p>并且，uniform变量是全局的，它必须在每个着色器程序对象中有且只有一个，并且它可以被着色器程序的任意着色器在任意阶段访问。</p><p>使用方法如下：</p><p>在片段着色器中定义uniform变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; &#x2F;&#x2F; 在OpenGL程序代码中设定这个变量</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C/C++代码中，使用<code>glGetUniformLocation</code>函数获取该uniform变量，然后使用<code>glUniform4f</code>函数对其赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float timeValue &#x3D; glfwGetTime();</span><br><span class="line">float greenValue &#x3D; (sin(timeValue) &#x2F; 2.0f) + 0.5f;</span><br><span class="line">int vertexColorLocation &#x3D; glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure><p>值得注意的是，如果<code>glGetUniformLocation</code>返回-1就代表没有找到这个位置值。</p><p>而且，<code>glUniform4f</code>函数是属于设置uniform函数族中的一个，因为OpenGL底层是C库，不支持重载。</p><h2 id="传递多个属性"><a href="#传递多个属性" class="headerlink" title="传递多个属性"></a>传递多个属性</h2><p>在上面的例子中，只是传递了顶点位置的属性到顶点着色器上，那怎样才能传递多个属性呢？</p><p>首先，先给出顶点属性数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 位置              &#x2F;&#x2F; 颜色</span><br><span class="line">     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   &#x2F;&#x2F; 右下</span><br><span class="line">    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   &#x2F;&#x2F; 左下</span><br><span class="line">     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    &#x2F;&#x2F; 顶部</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再顶点着色器代码中接收多个输入，每个输入使用<code>(location = n)</code>来做绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos;   &#x2F;&#x2F; 位置变量的属性位置值为 0 </span><br><span class="line">layout (location &#x3D; 1) in vec3 aColor; &#x2F;&#x2F; 颜色变量的属性位置值为 1</span><br><span class="line"></span><br><span class="line">out vec3 ourColor; &#x2F;&#x2F; 向片段着色器输出一个颜色</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos, 1.0);</span><br><span class="line">    ourColor &#x3D; aColor; &#x2F;&#x2F; 将ourColor设置为我们从顶点数据那里得到的输入颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(location = n)</code>对应C/C++代码中<code>glVertexAttribPointer</code>函数的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 位置属性</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">&#x2F;&#x2F; 颜色属性</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><p>给出顶点数据的存储结构图：</p><p><img src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt=""></p><p>最后输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/01/05/shaders3.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Shaders&quot;&gt;英文原文地址&lt;/a&gt;    &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Go语言基础——函数、方法和接口</title>
    <link href="https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/"/>
    <id>https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/</id>
    <published>2021-04-21T02:59:56.000Z</published>
    <updated>2021-04-21T07:20:07.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-函数、方法和接口"><a href="#1-4-函数、方法和接口" class="headerlink" title="1.4 函数、方法和接口"></a>1.4 函数、方法和接口</h1><p>函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口定义了方法的集合。</p><p>Go语言通过隐式接口机制实现鸭子面向对象模型（所谓鸭子就是走路像鸭子，叫声像鸭子，那么它就可以当作鸭子）。</p><h2 id="1-4-1-函数"><a href="#1-4-1-函数" class="headerlink" title="1.4.1 函数"></a>1.4.1 函数</h2><p>函数是一个操作序列，可以把它赋值给变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;具名函数</span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add &#x3D; Add</span><br><span class="line">add(1, 2)</span><br><span class="line">Add(1, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匿名函数</span><br><span class="line">var Add &#x3D; func(a, b int) &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(1, 2)</span><br></pre></td></tr></table></figure><p>函数的参数和返回值可以有多个，支持可变参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Swap(a, b int) &#123;</span><br><span class="line">    return b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Sum(a int, more ...int) int &#123;</span><br><span class="line">    for _, v :&#x3D; range more &#123;</span><br><span class="line">        a +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum :&#x3D; Sum(1, []int&#123;2, 3&#125;...)</span><br></pre></td></tr></table></figure><p>可以给返回值命名，这样子返回值变量就可以在函数中使用，并且return语句可以不用带返回值（假如return语句带了变量，这是将变量赋值给返回值）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func Sum(a int, more ...int) (sum int) &#123;</span><br><span class="line">    sum +&#x3D; a</span><br><span class="line">    for _, v :&#x3D; range more &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer关键字</strong></p><p>defer语句可以延迟执行一个函数，并且以栈的方式执行多个defer语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class="line">        defer func()&#123;fmt.Println(i)&#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Output:</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p><strong>Go语言中指针不是固定不变的</strong></p><p>Goroutine启动时只会分配很小的栈（4KB或8KB），在运行过程中才会不断扩充自己的栈空间，在增长过程中会拷贝之前的数据到新的内存空间。</p><p>并且，无法得知函数参数或局部变量到底是保存在栈中还是堆中。</p><h2 id="1-4-2-方法"><a href="#1-4-2-方法" class="headerlink" title="1.4.2 方法"></a>1.4.2 方法</h2><p>方法是关联类型的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (v *vType) Funcname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var v vType</span><br><span class="line">v.Funcname()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方法表达式特性</strong></p><p>可以使用方法表达式将方法还原为普通函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;func Funcname(v *vType)()&#123;...&#125;</span><br><span class="line">var Func &#x3D; (*vType).Funcname</span><br><span class="line">Func(v)</span><br></pre></td></tr></table></figure><p><strong>方法的继承</strong></p><p>Go语言不支持传统面向对象中的继承特性，但可通过组合的方式支持方法的继承——通过在结构体内置匿名的成员来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &quot;image&#x2F;color&quot;</span><br><span class="line"></span><br><span class="line">type Point struct &#123; X, Y float64 &#125;</span><br><span class="line"></span><br><span class="line">type ColoredPoint struct &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cp ColoredPoint</span><br><span class="line">cp.X &#x3D; 1</span><br><span class="line">cp.Point.X &#x3D; 2</span><br></pre></td></tr></table></figure><p>看似<code>cp.X</code>中<code>X</code>是属于<code>ColoredPoint</code>类型的，实际上<code>X</code>依旧是属于匿名成员<code>Point</code>的。因为在编译期间，<code>cp.X</code>会被展开成<code>cp.Point.X</code>。</p><h2 id="1-4-3-接口"><a href="#1-4-3-接口" class="headerlink" title="1.4.3 接口"></a>1.4.3 接口</h2><p>Go语言的接口类型是对其他类型行为的抽象和概括。而且，Go语言的借口类型是延迟绑定，可以实现类似虚函数的多态功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type UpperString string</span><br><span class="line"></span><br><span class="line">func (s UpperString) String() string &#123;</span><br><span class="line">    return strings.ToUpper(string(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">接口在fmt包中有定义：</span><br><span class="line">type fmt.Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Fprintln(os.Stdout, UpperString(&quot;hello, world&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言对接口类型的转换很灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a io.ReadCloser &#x3D; (*os.File)(f)&#x2F;&#x2F;隐式转换</span><br><span class="line">    b io.Reader &#x3D; a&#x2F;&#x2F;隐式转换</span><br><span class="line">    c io.Closer &#x3D; a&#x2F;&#x2F;隐式转换</span><br><span class="line">    d io.Reader &#x3D; c.(io.Reader)&#x2F;&#x2F;显式转换</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4-函数、方法和接口&quot;&gt;&lt;a href=&quot;#1-4-函数、方法和接口&quot; class=&quot;headerlink&quot; title=&quot;1.4 函数、方法和接口&quot;&gt;&lt;/a&gt;1.4 函数、方法和接口&lt;/h1&gt;&lt;p&gt;函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口</summary>
      
    
    
    
    <category term="书籍" scheme="https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="《Go语言高级编程》" scheme="https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Go语言基础——数组、字符串和切片</title>
    <link href="https://www.chaguake.com/2021/04/20/Go-base-knowledge-01/"/>
    <id>https://www.chaguake.com/2021/04/20/Go-base-knowledge-01/</id>
    <published>2021-04-20T09:14:25.000Z</published>
    <updated>2021-04-21T02:58:25.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-3-数组、字符串和切片"><a href="#1-3-数组、字符串和切片" class="headerlink" title="1.3 数组、字符串和切片"></a>1.3 数组、字符串和切片</h1><p>这三种数据类型，在底层，原始数据有着相同的内存结构；在上层，因为语法的限制而有着不同的行为表现。</p><ul><li><p>数组是一种值类型，虽然数组的元素可以修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理。</p></li><li><p>字符串底层是对应的字节数组，但是字符串的只读属性禁止了程序中对底层字节数组元素的修改。而且字符串赋值只是复制了数据地址和对应的长度。</p></li><li><p>切片的结构和字符串的结构相似，但是解除了只读限制。底层结构多了<code>cap</code>字段，用于表示切片的容量。</p></li></ul><p><em>Go语言的赋值和函数传参规则很简单，除闭包函数以引用的方式对外部变量访问之外，其他赋值和函数传参都是以传值的方式处理。</em></p><h2 id="1-3-1-数组"><a href="#1-3-1-数组" class="headerlink" title="1.3.1 数组"></a>1.3.1 数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组由零个或多个元素组成。</p><p>数组的长度是数组类型的组成部分，不同长度或不同类型的数据组成的数组都是不同的类型。</p><p>数组定义方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int&#x2F;&#x2F;[0, 0, 0]</span><br><span class="line">var b &#x3D; [...]int&#123;1, 2, 3&#125;&#x2F;&#x2F;[1, 2, 3]</span><br><span class="line">var c &#x3D; [...]int&#123;2:3, 1:2&#125;&#x2F;&#x2F;[0, 2, 3]</span><br><span class="line">var d &#x3D; [...]int&#123;1, 2, 4:5, 6&#125;&#x2F;&#x2F;[1, 2, 0, 0, 5, 6]</span><br></pre></td></tr></table></figure><p>数组是值语义，一个数组变量即整个数组，不能隐式地指向第一个元素的地址。</p><p>可以传递一个指向数组的指针，数组指针在使用上与数组变量差别不大：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [...]int&#123;1, 2, 3&#125;</span><br><span class="line">var b &#x3D; &amp;a</span><br><span class="line"></span><br><span class="line">fmt.Println(a[0])</span><br><span class="line">fmt.Println(b[0])</span><br><span class="line"></span><br><span class="line">for i :&#x3D; range a &#123;</span><br><span class="line">    fmt.Println(i, a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i, v :&#x3D; range b &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;效率性能比for range差</span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">    fmt.Println(i, a[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for range方式迭代，还可以忽略迭代时的下标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var times [5][0]int</span><br><span class="line">for range times &#123;</span><br><span class="line"> fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>times</code>是一个[5][0]int的二维数组，即<code>[[], [], [], [], []]</code>，整个数组的内存大小为0。</p><p>数组的类型可以是任意的，接口、结构体、函数都行。</p><p>长度为0的数组不占空间，可以用于占位或者类型声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1 :&#x3D; make(chan [0]int)</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">&#x2F;&#x2F;c1 :&#x3D; make(chan sttruct&#123;&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>fmt.Printf</code>打印数组的类型和详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; [...]int&#123;1, 2, 3&#125;</span><br><span class="line">fmt.Printf(&quot;b: %T\n&quot;, b)&#x2F;&#x2F;b: [3]int</span><br><span class="line">fmt.Printf(&quot;b: %#v\n&quot;, b)&#x2F;&#x2F;b: [3]int&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-2-字符串"><a href="#1-3-2-字符串" class="headerlink" title="1.3.2 字符串"></a>1.3.2 字符串</h2><p>字符串是不可改变的字符序列。</p><p>Go语言字符串的底层结构在<code>reflect.StringHeader</code>中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">    Data uintptr</span><br><span class="line">    Len int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符串，与对应的byte数组的底层数据内存结构是一致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; &quot;hello, world&quot;</span><br><span class="line"></span><br><span class="line">var data &#x3D; [...]byte &#123;</span><br><span class="line">    &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串支持切片操作，不同位置的切片底层访问的是同一块内存数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; &quot;hello, world&quot;</span><br><span class="line"></span><br><span class="line">hello :&#x3D; s[:5]</span><br><span class="line">world :&#x3D; s[7:]</span><br><span class="line"></span><br><span class="line">s1 :&#x3D; &quot;hello, world&quot;[:5]&#x2F;&#x2F;&quot;hello, world&quot;[:5]与s[:5]指向的是用一个字符串常量</span><br><span class="line">s2 :&#x3D; &quot;hello, world&quot;[7:]</span><br></pre></td></tr></table></figure><p>除了使用<code>len</code>函数获取字符串长度之外，也可以使用<code>reflect.StringHeader</code>结构访问字符串的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;len(s):&quot;, (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len)</span><br></pre></td></tr></table></figure><h2 id="1-3-3-切片"><a href="#1-3-3-切片" class="headerlink" title="1.3.3 切片"></a>1.3.3 切片</h2><p>切片可以说是一种简化版的动态数组。底层数据结构<code>reflect.SliceHeader</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">    Data uintptr</span><br><span class="line">    Len int</span><br><span class="line">    Cap int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cap</code>表示切片指向的内存空间的最大容量，会按照规则实现自动扩充。</p><p>切片的定义方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a []int&#x2F;&#x2F;nil切片，和nil相等</span><br><span class="line">    b &#x3D; []int&#123;&#125;&#x2F;&#x2F;空切片</span><br><span class="line">    c &#x3D; []int&#123;1, 2, 3&#125;&#x2F;&#x2F;有3个元素的切片，len和cap都为3</span><br><span class="line">    d &#x3D; c[:2]&#x2F;&#x2F;有2个元素的切片，len为2，cap为3</span><br><span class="line">    e &#x3D; c[0:2:cap(c)]&#x2F;&#x2F;有2个元素的切片，len为2，cap为3</span><br><span class="line">    f &#x3D; c[:0]&#x2F;&#x2F;有0个元素的切片，len为0，cap为3</span><br><span class="line">    g &#x3D; make([]int, 3)&#x2F;&#x2F;有三个元素的切片，len和cap都为3</span><br><span class="line">    h &#x3D; make([]int, 2, 3)&#x2F;&#x2F;有2个元素的切片，len为2，cap为3</span><br><span class="line">    i &#x3D; make([]int, 0, 3)&#x2F;&#x2F;有0个元素的切片，len为0，cap为3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>添加切片元素</strong></p><p>使用内置的<code>append</code>函数。值得注意的是，<code>append</code>函数有可能导致重新分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切片尾部添加N个元素</span><br><span class="line">a &#x3D; append(a, 1)</span><br><span class="line">a &#x3D; append(a, 2, 3)</span><br><span class="line">a &#x3D; append(a, []int&#123;5, 6&#125;...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切片头部添加N个元素</span><br><span class="line">a &#x3D; append([]int&#123;0&#125;, a...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;切片中间添加N个元素</span><br><span class="line">a &#x3D; append(a[:4], append([]int&#123;4&#125;, a[4:]...)...)</span><br></pre></td></tr></table></figure><p>在切片中间添加元素时，<code>append</code>会创建临时切片。可使用<code>copy</code>函数和<code>append</code>函数组合，避免创建临时切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; append(a, 0)&#x2F;&#x2F;扩充空间，需要插入N个就扩充N</span><br><span class="line">copy(a[5:], a[4:])&#x2F;&#x2F;a[4:]后移一个位置</span><br><span class="line">a[4] &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>删除切片元素</strong></p><p>删除头部和尾部的元素，可直接重新赋值范围即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除尾部</span><br><span class="line">a &#x3D; a[:len(a)-1]</span><br><span class="line">a &#x3D; a[:len(a)-N]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除头部</span><br><span class="line">a &#x3D; a[1:]</span><br><span class="line">a &#x3D; a[N:]</span><br></pre></td></tr></table></figure><p>删除头部元素或中间元素也可以用<code>append</code>函数或<code>copy</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头部元素</span><br><span class="line">a &#x3D; append(a[:0], a[1:]...)</span><br><span class="line">a &#x3D; a[:copy(a, a[1:])]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;中间元素</span><br><span class="line">a &#x3D; append(a[:i], a[i+1:]...)</span><br><span class="line">a &#x3D; a[:i + copy(a[i], a[i+1:])]</span><br></pre></td></tr></table></figure><p>切片高效操作的要点是降低内存分配的次数，尽量保证<code>append</code>函数操作不会超出<code>cap</code>的容量。</p><p>切片使用中，假如只使用了切片的一部分数据，应当拷贝到一个新的变量，避免切片底层数据的长期引用。</p><p><strong>切片类型强制转换</strong></p><p>通过切片底层结构<code>reflect.SliceHeader</code>来做指针的强制赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; []float64&#123;&#125;</span><br><span class="line">c :&#x3D; []int&#123;&#125;</span><br><span class="line"></span><br><span class="line">aHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">cHdr :&#x3D; (*reflect.SliceHeader)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">*cHdr &#x3D; *aHdr</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-3-数组、字符串和切片&quot;&gt;&lt;a href=&quot;#1-3-数组、字符串和切片&quot; class=&quot;headerlink&quot; title=&quot;1.3 数组、字符串和切片&quot;&gt;&lt;/a&gt;1.3 数组、字符串和切片&lt;/h1&gt;&lt;p&gt;这三种数据类型，在底层，原始数据有着相同的内存结构；</summary>
      
    
    
    
    <category term="书籍" scheme="https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="《Go语言高级编程》" scheme="https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用SQL命令集合</title>
    <link href="https://www.chaguake.com/2021/04/15/mysql-common-command/"/>
    <id>https://www.chaguake.com/2021/04/15/mysql-common-command/</id>
    <published>2021-04-15T03:27:46.000Z</published>
    <updated>2021-04-15T06:22:49.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="show-engines命令"><a href="#show-engines命令" class="headerlink" title="show engines命令"></a>show engines命令</h3><p>用于查看当前Mysql使用的数据库存储引擎。</p><p><img src="./show_engines.jpg" alt="show_engines命令结果"></p><h3 id="show-variables命令"><a href="#show-variables命令" class="headerlink" title="show variables命令"></a>show variables命令</h3><p>用于查看当前Mysql的配置情况。</p><p><img src="./show_variables.jpg" alt="show_variables命令输出"></p><h3 id="show-status-like-‘Table-’命令"><a href="#show-status-like-‘Table-’命令" class="headerlink" title="show status like ‘Table%’命令"></a>show status like ‘Table%’命令</h3><p>用于查看当前表使用状态，有两个关键的字段：<code>Table_locks_immediate</code>为表立即释放锁的次数，<code>Table_locks_waited</code>为表等待释放锁的次数。</p><p><img src="./show_status.jpg" alt="show status命令输出"></p><h3 id="show-status-like-‘innodb-row-lock-’命令"><a href="#show-status-like-‘innodb-row-lock-’命令" class="headerlink" title="show status like ‘innodb_row_lock%’命令"></a>show status like ‘innodb_row_lock%’命令</h3><p>用于查看行锁争夺情况。</p><p><img src="./show_status1.jpg" alt="show status命令输出"></p><h3 id="lock-table-unlock-table命令"><a href="#lock-table-unlock-table命令" class="headerlink" title="lock table/unlock table命令"></a>lock table/unlock table命令</h3><p>MyISAM数据库引擎加锁（解锁）操作。</p><h3 id="InnoDB-Monitors"><a href="#InnoDB-Monitors" class="headerlink" title="InnoDB Monitors"></a>InnoDB Monitors</h3><p>可创建InnoDB Monitors来观察发生锁冲突的表、数据行等信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE innodb_monitor(a INT) ENGINE&#x3D;INNODB;</span><br><span class="line">Show innodb status \G;</span><br><span class="line">DROP TABLE innodb_monitor;</span><br></pre></td></tr></table></figure><h3 id="SELECT-…-LOCK-IN-SHARE-MODE命令"><a href="#SELECT-…-LOCK-IN-SHARE-MODE命令" class="headerlink" title="SELECT … LOCK IN SHARE MODE命令"></a>SELECT … LOCK IN SHARE MODE命令</h3><p>用SELECT … IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。</p><p>但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁。</p><h3 id="SELECT-…-FOR-UPDATE命令"><a href="#SELECT-…-FOR-UPDATE命令" class="headerlink" title="SELECT … FOR UPDATE命令"></a>SELECT … FOR UPDATE命令</h3><p>对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p><p>其他session可以查询，但是不能加共享锁。</p><h3 id="InnoDB的行锁与表锁"><a href="#InnoDB的行锁与表锁" class="headerlink" title="InnoDB的行锁与表锁"></a>InnoDB的行锁与表锁</h3><p>当使用索引来检索数据时，就会使用到行级锁，否则，将会使用表级锁。</p><p>比如，SELECT …WHERE … FOR UPDATE语句，如果where后面使用的是索引，那么这条语句就是行锁，否则是表锁。</p><p>而且，假如另一个session的SELECT …WHERE … FOR UPDATE语句通过另一个索引找到对应行，那还是会等待锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;show-engines命令&quot;&gt;&lt;a href=&quot;#show-engines命令&quot; class=&quot;headerlink&quot; title=&quot;show engines命令&quot;&gt;&lt;/a&gt;show engines命令&lt;/h3&gt;&lt;p&gt;用于查看当前Mysql使用的数据库存储引擎。</summary>
      
    
    
    
    <category term="数据库" scheme="https://www.chaguake.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://www.chaguake.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sunday字符串匹配算法</title>
    <link href="https://www.chaguake.com/2021/04/15/Sunday-alg/"/>
    <id>https://www.chaguake.com/2021/04/15/Sunday-alg/</id>
    <published>2021-04-15T00:45:40.000Z</published>
    <updated>2021-04-15T01:14:42.265Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：</p><p><a href="https://blog.csdn.net/q547550831/article/details/51860017">字符串匹配——Sunday算法</a></p><p>Sunday算法比BM算法更快，并且方便不少。与KMP算法一样，迭代方向和字符比较方向都是从左到右。但匹配失效时取未参与匹配的第一个字符来做位数移动的判断依据。</p><ul><li><p>如果该字符没有在搜索字符串中出现则直接跳过，即移动位数 = 搜索字符串长度 + 1；</p></li><li><p>否则，其移动位数 = 搜索字符串长度 - 该字符最右出现的位置（以0开始） = 搜索字符串中该字符最右出现的位置到尾部的距离 + 1。（其实就是将搜索字符串最右出现的位置与该字符位置对齐）</p></li></ul><p>下面举例说明：</p><p>1.匹配失效时，判断字符<code>i</code>是否在模式串中出现，没有则移动模式串到字符<code>i</code>后面。</p><p><img src="https://img-blog.csdn.net/20160708122016780" alt=""></p><p>2.匹配失效时，判断字符<code>r</code>是否在模式串中出现，有则将模式串中最右出现字符<code>r</code>的位置与字符<code>r</code>的位置对齐。</p><p><img src="https://img-blog.csdn.net/20160708122307562" alt=""></p><p>3.完成匹配。</p><p><img src="https://img-blog.csdn.net/20160708122414877" alt=""></p><p>可以看出，Sunday算法十分快速地实现了匹配。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int Sunday(const string&amp; T, const string&amp; P) &#123;</span><br><span class="line">int n &#x3D; T.length();</span><br><span class="line">int m &#x3D; P.length();</span><br><span class="line"></span><br><span class="line">int shift[MAXNUM];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认值，移动m+1位</span><br><span class="line">for (size_t i &#x3D; 0; i &lt; MAXNUM; i++)&#123;</span><br><span class="line">shift[i] &#x3D; m + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模式串P中每个字母出现的最后的下标</span><br><span class="line">&#x2F;&#x2F; 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数</span><br><span class="line">for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">shift[P[i]] &#x3D; m - i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模式串开始位置在主串的哪里</span><br><span class="line">int s &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; 模式串已经匹配到的位置</span><br><span class="line">int j;</span><br><span class="line">while (s &lt;&#x3D; n - m) &#123;</span><br><span class="line">j &#x3D; 0;</span><br><span class="line">while (T[s + j] &#x3D;&#x3D; P[j]) &#123;</span><br><span class="line">j++;</span><br><span class="line">&#x2F;&#x2F; 匹配成功</span><br><span class="line">if (j &gt;&#x3D; m) &#123;</span><br><span class="line">return s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 找到主串中当前跟模式串匹配的最末字符的下一个字符</span><br><span class="line">&#x2F;&#x2F; 在模式串中出现最后的位置</span><br><span class="line">&#x2F;&#x2F; 所需要从(模式串末尾+1)移动到该位置的步数</span><br><span class="line">s +&#x3D; shift[T[s + m]];</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/q547550831/article/details/51860017&quot;&gt;字符串匹配——Sunday算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sunday算法比BM算法更快，并且方便不少。与KMP算法</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串算法" scheme="https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BM字符串匹配算法</title>
    <link href="https://www.chaguake.com/2021/04/14/Boyer-Moore-alg/"/>
    <id>https://www.chaguake.com/2021/04/14/Boyer-Moore-alg/</id>
    <published>2021-04-14T05:44:16.000Z</published>
    <updated>2021-04-14T09:19:27.946Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献有:</p><p><a href="https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf">BM字符串匹配算法论文</a></p><p><a href="http://www-igm.univ-mlv.fr/~lecroq/string/node14.html">Boyer-Moore algorithm</a></p><hr><p>BM（Boyer-Moore）算法比KMP算法高效不少。KMP算法只有一个匹配规则，而BM算法有两个匹配规则，更加优化了迭代索引，减少不必要的比较次数。</p><p>BM算法的主要思想是：源字符串迭代方向依旧是从左到右，源字符串与搜索字符串的比较方向是从左到右。遇到不匹配情况时，根据两个匹配规则，定位下一次源字符串与搜索字符串比较的位置。</p><h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><p>BM算法定义了两个匹配规则，在每一次调整搜索字符串位置时，移动位数由两个匹配规则判断返回值中的最大值决定。</p><h2 id="坏字符规则（bad-character-shift）。"><a href="#坏字符规则（bad-character-shift）。" class="headerlink" title="坏字符规则（bad-character shift）。"></a>坏字符规则（bad-character shift）。</h2><p>当源字符串中的某个字符与搜索字符串中的某个字符不匹配时，则源字符串中的那个字符称之为坏字符。</p><p>这时，搜索字符串向右移动的位数 = 已完成匹配字符集合（从右到左）的最后一个字符索引（从0开始） - 坏字符在搜索字符串中最右边出现的位置索引（从0开始）。</p><p>假如坏字符在搜索字符串中未出现，则移动位数值为-1。</p><p>坏字符规则下的两种判断情况：</p><ul><li>当搜索字符串不包含坏字符时，直接将搜索字符串移动到坏字符索引+1的位置（符合上面的计算公式）。</li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmbc2.gif" alt="The bad-character shift, b does not occur in x."></p><ul><li>当搜索字符串包含坏字符时，将搜索字符串中最右出现的位置与坏字符位置对齐。这就意味着可能出现搜索字符串位置回退的情况，不过没关系，最后计算的移动位数由两个匹配规则决定的。</li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmbc1.gif" alt="The bad-character shift, a occurs in x."></p><h2 id="好后缀规则（good-suffix-shift）。"><a href="#好后缀规则（good-suffix-shift）。" class="headerlink" title="好后缀规则（good-suffix shift）。"></a>好后缀规则（good-suffix shift）。</h2><p>当字符无法继续匹配时，称已完成匹配字符集合为好后缀，</p><p>搜索字符串向右移动的位数 = 搜索字符串最右的好后缀索引 - 搜索字符串倒数第二次出现的好后缀索引。</p><p>假如好后缀在搜索字符串中只出现一次，则移动位数值为-1。</p><p>好后缀规则下的三种判断情况：</p><ul><li><p>搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配且没有其他前缀子字符串与好后缀的后缀子字符串适配时，直接将搜索字符串移动到好后缀后面的字符位置。</p></li><li><p>搜索字符串中除了已经匹配上好后缀的那一个子字符串，还存在其他子字符串与好后缀适配时，则将搜索字符串倒数第二个适配的子字符串与好后缀对齐。</p></li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmgs1.gif" alt="The good-suffix shift, u re-occurs preceded by a character c different from a."></p><ul><li>搜索字符串中除了已经匹配上好后缀的那一个子字符串，没有其他子字符串与好后缀适配，但存在其他前缀子字符串与好后缀的后缀子字符串适配时，则将它们对齐。</li></ul><p><img src="http://www-igm.univ-mlv.fr/~lecroq/string/images/bmgs2.gif" alt="The good-suffix shift, only a suffix of u re-occurs in x."></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>下面以实例来进行详解，如何用代码实现BM算法。</p><p>现在有一个源字符串<code>cbcccacacabccabc</code>，和一个搜索字符串<code>cabcca</code>，想要得到源字符串是否包含搜索字符串，有则输出位置索引。</p><p>根据坏字符规则，需要创建一个字符位置映射表，用于记录坏字符在搜索字符串中最右边的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;char_table大小要大于等于会出现的所有字符种类数</span><br><span class="line">&#x2F;&#x2F;int char_table[MAXNUM + 1];</span><br><span class="line">&#x2F;&#x2F;memset(char_table, -1, sizeof(char) *(MAXNUM + 1));</span><br><span class="line">void InitCharTable(const char *search, unsigned int len, int *char_table) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        char_table[search[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据好后缀规则，需要创建前缀子字符串索引表和后缀子字符串索引表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void InitGoodSuffixTable(const char *search, int len, int *suffix, bool *prefix) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len - 1; i++) &#123; &#x2F;&#x2F;范围从第一个字符到倒数第二个字符</span><br><span class="line">int j &#x3D; i;</span><br><span class="line">int k &#x3D; 0;</span><br><span class="line">while (j &gt;&#x3D; 0 &amp;&amp; search[j] &#x3D;&#x3D; search[len - 1 - k]) &#123;&#x2F;&#x2F;通过j、k同时往前回朔找相同的字符</span><br><span class="line">    suffix[++k] &#x3D; --j + 1;&#x2F;&#x2F;在后缀子字符串的后一个字符标记偏移量，兼容a[0]的情况</span><br><span class="line">&#125;</span><br><span class="line">if (j &#x3D;&#x3D; -1) &#123;</span><br><span class="line">    prefix[k] &#x3D; true;&#x2F;&#x2F;前缀子字符串最多只有一个，在结束的字符上标记结束符号（设为true）</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">输出结果：</span><br><span class="line">suffix：[-1, 1, 0, -1, -1, -1]。</span><br><span class="line">prefix：[false, false, true, false, false, false]。</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>移动位数的函数需要跟前缀子字符串索引表和后缀子字符串索引表的生成方式绑定使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int MoveIndexByGS(int bcindex, int len, int *suffix, bool *prefix) &#123;</span><br><span class="line">    int gslen &#x3D; len - 1 - bcindex;</span><br><span class="line">    if (suffix[gslen] !&#x3D; -1) &#123;</span><br><span class="line">return bcindex - suffix[gslen] + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int r &#x3D; bcindex + 2; r &lt;&#x3D; len - 1; r++) &#123;</span><br><span class="line">if (prefix[len - r])</span><br><span class="line">    return r;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BM算法的实现逻辑函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int BM(const char *str, int len,const char *search, int slen) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;bad char rule tables</span><br><span class="line">    int char_table[MAXNUM + 1];</span><br><span class="line">    memset(char_table, -1, sizeof(char_table));</span><br><span class="line">    InitCharTable(search, slen, char_table);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;good suffix rule tables</span><br><span class="line">    int suffix[MAXNUM + 1];</span><br><span class="line">    bool prefix[MAXNUM + 1];</span><br><span class="line">    memset(suffix, -1, sizeof(suffix));</span><br><span class="line">    memset(prefix, false, sizeof(prefix));</span><br><span class="line">    InitGoodSuffixTable(search, slen, suffix, prefix);</span><br><span class="line"></span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while (i &lt;&#x3D; len - slen) &#123;</span><br><span class="line">int j;</span><br><span class="line">for (j &#x3D; slen - 1; j &gt;&#x3D; 0; j--) &#123;</span><br><span class="line">    &#x2F;&#x2F;fine bad char</span><br><span class="line">    if (str[i + j] !&#x3D; search[j])</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (j &lt; 0) &#123;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; find bad char position</span><br><span class="line">int x &#x3D; j - char_table[(int)str[i + j]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; find good suffix position</span><br><span class="line">int y &#x3D; 0;</span><br><span class="line">if (j &lt; slen - 1) &#123;</span><br><span class="line">    y &#x3D; MoveIndexByGS(j, slen, suffix, prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;get the max offset</span><br><span class="line">i &#x3D; i + max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文献有:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.utexas.edu/users/moore/publications/fstrpos.pdf&quot;&gt;BM字符串匹配算法论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www-igm.uni</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串算法" scheme="https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>KMP字符串匹配算法</title>
    <link href="https://www.chaguake.com/2021/04/12/knuth-morris-pratt-alg/"/>
    <id>https://www.chaguake.com/2021/04/12/knuth-morris-pratt-alg/</id>
    <published>2021-04-12T06:07:04.000Z</published>
    <updated>2021-04-12T07:23:08.137Z</updated>
    
    <content type="html"><![CDATA[<p><em>在日常工作中，我们经常需要在文本中搜寻某些特定的字符串，那作为使用者的你，有没有想过其算法的实现呢？</em></p><p>举个例子，假如有一个源字符串“ablshvaabcadababcskilils”，如何判断其是否包含搜索字符串“abcadaba”？</p><p>一般想到的做法是暴力遍历匹配方法：遍历源字符串，然后取出与搜索字符串相同长度的子字符串做比较，不匹配就将迭代索引+1，再取出与搜索字符串相同长度的子字符串做比较，直到迭代结束。时间复杂度为$O(m*n)$，取决于源字符串和搜索字符串的长度。</p><p><img src="https://img-blog.csdnimg.cn/20200422194813187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F0dHJhY3QxMjA2,size_16,color_FFFFFF,t_70#pic_center" alt="网图，如侵权请联系删除"></p><p>不难发现，在子字符串与搜索字符串做比较时，很大程度上，有部分操作是与上一次比较时重复的，那能否设计一种模式，减少这部分的重复工作呢？</p><h1 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h1><p>KMP算法是通过添加部分匹配表（Partial Match Table）来减少重复搜索工作的算法，它其实是对暴力遍历匹配方法的优化算法，在搜索字符串没有部分匹配字符串的时候，会退化成暴力遍历匹配方法。</p><p><img src="https://img-blog.csdnimg.cn/20200422194829782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F0dHJhY3QxMjA2,size_16,color_FFFFFF,t_70#pic_center" alt="网图，如侵权请联系删除"></p><p>如上图，在匹配失败时，无须回退到上一迭代器+1的位置，而是从下一个部分匹配字符串的位置开始迭代。</p><p><strong>部分匹配字符串和部分匹配表</strong></p><p>首先，先理解“前缀子字符串”和“后缀子字符串”的概念。</p><p>前缀子字符串：把搜索字符串的最后一个字符去掉，所有包含搜索字符串第一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的前缀字符串是<code>a、ab、abc、abca、abcad、abcada、abcadab</code>。</p><p>后缀子字符串：把搜索字符串的第一个字符去掉，所有包含搜索字符串最后一个字符、且连续的字符串。如上面的搜索字符串“abcadaba”，它的后缀字符串是<code>bcadaba、cadaba、adaba、daba、aba、ba、a</code>。</p><p>把同时出现在所有前缀字符串和后缀字符串中的，包含搜索字符串第一个字符且连续的子字符串称为部分匹配字符串，所有部分匹配字符串的集合称为部分匹配表。如上面的搜索字符串“abcadaba”，它的部分匹配表的元素有：<code>a、ab</code>。</p><p><strong>代码实现部分匹配表</strong></p><p>我们需要记录部分匹配字符串第二次出现的位置。</p><p>创建一个与搜索字符串相同长度的整型数组，默认初始化值为0，用于存储在搜索字符串对应位置上，部分匹配字符串的长度。如上面的搜索字符串“abcadaba”，它的部分匹配表最终为：<code>[0, 0, 0, 1, 0, 1, 2, 0]。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void GetPartialMatch(const std::string &amp;strTarget, int *arr)</span><br><span class="line">&#123;</span><br><span class="line">    int max_pre_size &#x3D; strTarget.length() - 1;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; max_pre_size; i++)&#123;</span><br><span class="line"></span><br><span class="line">        std::string strTmp1 &#x3D; strTarget.substr(0, i + 1);</span><br><span class="line">        for (size_t j &#x3D; 1; j &lt; max_pre_size; j++)&#123;</span><br><span class="line">    std::string strTmp2 &#x3D; strTarget.substr(j, i + 1);</span><br><span class="line"></span><br><span class="line">    if (strTmp1 &#x3D;&#x3D; strTmp2) &#123;</span><br><span class="line">        arr[j + i] &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KMP算法实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void KMP(const std::string &amp;strSrc, const std::string &amp;strTarget, const int *arr)</span><br><span class="line">&#123;</span><br><span class="line">    int match_index &#x3D; 0;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; strSrc.length();)&#123;</span><br><span class="line">if (strSrc[i] &#x3D;&#x3D; strTarget[match_index]) &#123;</span><br><span class="line">    if (match_index + 1 &#x3D;&#x3D; strTarget.length()) &#123;</span><br><span class="line">printf(&quot;match success,sub str index[%d].\n&quot;, i - match_index);</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    match_index++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    if (match_index &gt; 0) &#123;</span><br><span class="line">match_index &#x3D; arr[match_index];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;match fail.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;在日常工作中，我们经常需要在文本中搜寻某些特定的字符串，那作为使用者的你，有没有想过其算法的实现呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;举个例子，假如有一个源字符串“ablshvaabcadababcskilils”，如何判断其是否包含搜索字符串“abcadaba”？&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串算法" scheme="https://www.chaguake.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++如何获取不定数量的输入参数？</title>
    <link href="https://www.chaguake.com/2021/04/09/C-knowledge-cin/"/>
    <id>https://www.chaguake.com/2021/04/09/C-knowledge-cin/</id>
    <published>2021-04-09T09:15:26.000Z</published>
    <updated>2021-04-09T09:22:45.559Z</updated>
    
    <content type="html"><![CDATA[<p>刷题时偶尔会出现输入不定数量的参数，主要是使用<code>std::cin</code>来实现。</p><p>使用<code>Ctrl Z</code>（Windows）或<code>Ctrl D</code>（UNIX）结束输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">int value;</span><br><span class="line">while(std::cin&gt;&gt;value)&#123;</span><br><span class="line">    vec.push_back(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回车结束输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">int value;</span><br><span class="line">while(std::cin&gt;&gt;value)&#123;</span><br><span class="line">    vec.push_back(value);</span><br><span class="line">    if(std::cin.get() &#x3D;&#x3D; &#39;\n&#39;)&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刷题时偶尔会出现输入不定数量的参数，主要是使用&lt;code&gt;std::cin&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Ctrl Z&lt;/code&gt;（Windows）或&lt;code&gt;Ctrl D&lt;/code&gt;（UNIX）结束输入：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="C/C++" scheme="https://www.chaguake.com/categories/C-C/"/>
    
    
    <category term="C/C++知识" scheme="https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP对接异常——Server端宕机</title>
    <link href="https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/"/>
    <id>https://www.chaguake.com/2021/04/08/tcp-docking-problem-01/</id>
    <published>2021-04-08T00:42:22.000Z</published>
    <updated>2021-04-09T08:51:45.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。</p><p>Server端使用boost的asio库，性能应该有保障的。</p><p>首先，查看日志，排查对应代码片段，未发现有出现”死锁“的逻辑，只能从wireshark抓包分析了。</p><p>现场同事把抓包发回一看，好家伙，一堆的”TCP ZeroWindow”和”RST“！</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>1、统计一下http请求情况，</p><p><img src="./http_statistic.jpg" alt="Http统计"></p><p>才三百多次http请求，远远没达到正常水平，排除Server端处理瓶颈问题。</p><p>2、输入筛选条件<code>tcp.flags.syn</code>，看看tcp三次握手情况。</p><p><img src="./syn.jpg" alt="syn统计"></p><p>Client新连接都直接被Server端拒绝了，Server端的连接数已经达到了极限。</p><p>而Server端在处理完http请求之后都会断开当前连接，并非长连接模式。并且，根据Server端的http处理耗时来看，还算正常。</p><p>问题估计在已建立但是未正常关闭的连接上，粗略看下，基本都会出现”TCP ZeroWindow“标记。</p><p>3、随机追踪一条出现”TCP ZeroWindow“的tcp连接，</p><p><img src="./tcp_zerowindow.jpg" alt="tcp zerowindow"></p><p>统计了下，出现这情况的连接大概有两百条，那就有可能出现同时并发的连接数大于<code>CPU数量*2+1</code>的情况。</p><p>而且，100个tcp包就出现滑动窗口占满的情况是不可能的，问题肯定出现在这里了。</p><p>经过排查，终于发现问题所在：</p><p><img src="./problem.jpg" alt="问题所在"></p><p>如上图，Server端最后回复给Client端包中，<code>Win</code>的值为5632，表示Server端还能接收5632个包。</p><p>并且<code>Ack</code>值为126929，希望Client下一个包的<code>Seq</code>序号值从126929开始。果不其然，Client端紧接着的包中<code>Seq</code>序号值为126929。</p><p>看Server端回复“TCP ZeroWindow”包的前一个由Client端发出的包LAST，它的<code>Seq</code>值为131273。</p><p>不难看出，<code>131273 - 126929 = 4344 &lt; 5632</code>，这时还可以正常接收。</p><p>但是展开那个包LAST中的<code>Next Seq</code>值是132609，<code>132609 - 126929 = 5680 &gt; 5632</code>，已经超出<code>Win</code>大小，所以，Server端接收到包LAST之后就返回“TCP ZeroWindow”包。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>1、Client端更改<code>Seq</code>的生成规则，使得<code>Seq</code>自增步长减少。</p><p>抓包中可以看出，Client端<code>Seq</code>的自增步长是1448。</p><p>2、Server端将滑动窗口变大。</p><p>由于Client端会发送<code>PSH</code>包通知Srever端清空缓冲，那么Server端可以将滑动窗口变大，避免出现“TCP ZeroWindow”情况。</p><p>3、优化Srever端“接收请求-&gt;回复请求”的耗时，避免同时出现异常连接并发数大于<code>CPU数量*2+1</code>的情况。</p><p>这种方法依旧是没办法解决问题所在的，只是尽量避免宕机情况出现。</p><p>4、Server端添加tcp连接的timeout处理。</p><p>Server端主动关闭超过timeout时间没有接收到http请求的连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;问题出现在某次与第三方HTTP数据对接上，发现Server端在运行大约半个小时后出现宕机现象。&lt;/p&gt;
&lt;p&gt;Server端</summary>
      
    
    
    
    <category term="问题排查" scheme="https://www.chaguake.com/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="问题排查之TCP" scheme="https://www.chaguake.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B9%8BTCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP的三次握手</title>
    <link href="https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/"/>
    <id>https://www.chaguake.com/2021/04/07/tcp-three-way-handshake/</id>
    <published>2021-04-07T02:13:50.000Z</published>
    <updated>2021-04-07T07:03:49.700Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。</p><p>参考文献有：</p><p><a href="https://segmentfault.com/a/1190000021740112">TCP三次握手、四次挥手出现意外情况时，为保证稳定，是如何处理的？</a></p><p><a href="https://yuanrengu.com/2020/77eef79f.html">面试官，不要再问我三次握手和四次挥手</a></p><h1 id="三次握手正常流程"><a href="#三次握手正常流程" class="headerlink" title="三次握手正常流程"></a>三次握手正常流程</h1><p>三次是TCP建立连接的最小次数，因为在三次握手中，双方都经历了”请求-&gt;应答“的过程。</p><p><img src="https://image-static.segmentfault.com/106/870/1068704971-3084b02c4479b0c7_fix732" alt="三次握手状态流程图"></p><p>三次握手流程步骤：</p><ol><li><p>在初始时，双端处于<code>CLOSE</code>状态，服务端(Server)为了提供服务，会主动监听某个端口，进入<code>LISTEN</code>状态。</p></li><li><p>客户端(Client)主动发送连接的<code>SYN</code>包，之后进入<code>SYN-SENT</code>状态，服务端在收到客户端发来的<code>SYN</code>包后，回复<code>SYN,ACK</code>包，之后进入<code>SYN-RCVD</code>状态。</p></li><li><p>客户端收到服务端发来的<code>SYN,ACK</code>包后，可以确认对方存在，此时回复<code>ACK</code>包，并进入<code>ESTABLISHED</code>状态。</p></li><li><p>服务端收到最后一个<code>ACK</code>包后，也进入<code>ESTABLISHED</code>状态。</p></li></ol><p>三次握手重点是客户端和服务端的状态变化过程，比如：客户端在发送第三个<code>ACK</code>包的时候，状态就会变更成<code>ESTABLISHED</code>，而服务端需要在接收到客户端发出的第三个<code>ACK</code>包的时候，才将状态转换成<code>ESTABLISHED</code>。</p><h1 id="三次握手异常情况"><a href="#三次握手异常情况" class="headerlink" title="三次握手异常情况"></a>三次握手异常情况</h1><p>计算机网络的异常处理有时比正常处理得流程更为重要，毕竟，需要花费更大的消耗去判断是网络故障还是连接异常。</p><p><strong>1. <code>SYN</code>包丢失</strong></p><p>对于服务端，客户端还是”不存在的“。</p><p>对于客户端，无法清楚服务端是否接收到<code>SYN</code>包，所以客户端会进行重传<code>SYN</code>包的操作，一般重传三次，三次加起来大约是76s（采用指数退避算法）。</p><p>在代码层次上，客户端会阻塞在<code>connect</code>函数上，失败会返回异常信息。</p><p>可通过更改系统配置（<a href="https://blog.csdn.net/chenyulancn/article/details/16339427">Linux点击这里</a>、<a href="https://blog.csdn.net/niejiangshuai/article/details/86573338">Windows点击这里</a>）来实现配置重连次数和重连耗时。</p><p>也可以通过”ioctl(1)+select(timeout)“方式来间接实现连接超时控制。<a href="https://blog.csdn.net/czh8706/article/details/84931785">TCP/IP Connect时间自主设定</a></p><p><strong>2. <code>SYN+ACK</code>包丢失</strong></p><p>对于客户端，跟<code>SYN</code>包丢失的处理流程是一样的。</p><p>对于服务端，会触发重传操作，毕竟无法确定客户端是否收到<code>SYN+ACK</code>包，此时服务端的状态是<code>SYN_RCVD</code>。</p><p>当超过重传次数之后，服务端系统会发送<code>RST</code>包。</p><p><strong>3. <code>ACK</code>包丢失</strong></p><p>对于服务端，跟<code>SYN+ACK</code>包丢失的处理流程是一样的，处于<code>SYN-RCVD</code>状态。</p><p>对于客户端，<code>connect</code>函数已经正常返回，客户端已经进入<code>ESTABLISHED</code>状态，可以发送/接收数据了。</p><p>现在，服务端和客户端的状态不对等，那么客户端发给服务端的数据会怎么处理呢？</p><p>结合<a href="https://blog.csdn.net/zerooffdate/article/details/79359726">文章</a>来看，假如客户端发送的第一个数据包的<code>Seq</code>确认序号跟<code>ACK</code>包的<code>Seq</code>确认序号一样，那么，服务端将进入<code>ESTABLISHED</code>状态，正常连接。假如不一样，服务端会发送<code>RST</code>包，结束该连接。而在代码实现中，<code>connect</code>函数是在客户端回复<code>ACK</code>包之后就返回了，这时三次握手还没完成。</p><p>所以，可以在<code>conenct</code>函数返回之后，立即发送一个跟<code>ACK</code>包相同<code>Seq</code>确认序号的数据包（默认第一个数据包的<code>Seq</code>是跟<code>ACK</code>一样），哪怕服务端没有接收到<code>ACK</code>包，也可以正常进入<code>ESTABLISHED</code>状态。并且也可以验证连接是否成功，假如服务端返回<code>RST</code>包，则连接失败。</p><p>应用层上，使用select、poll或者epoll机制判断socket是否可写来确认连接是否已经建立。<a href="https://blog.csdn.net/ruixj/article/details/1756440">非阻塞socket 的连接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到了关于TCP三次握手的问题，发现自己对三次握手还只是停留在正常流程的认知上，TCP建立连接异常的情况却了解甚少。嗯，做个记录。&lt;/p&gt;
&lt;p&gt;参考文献有：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/119000002174</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://www.chaguake.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="https://www.chaguake.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Reservoir Sampling 抽样算法</title>
    <link href="https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/"/>
    <id>https://www.chaguake.com/2021/04/05/reservoir-sampling-alg/</id>
    <published>2021-04-04T16:20:31.000Z</published>
    <updated>2021-04-06T08:23:01.651Z</updated>
    
    <content type="html"><![CDATA[<p>“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。</p><p>但是，当m不是确定值呢？</p><p>可以使用Reservoir Sampling 抽样算法。</p><p>由于m是不确定的，那么使用[0,m]范围内随机产生数的方式就没办法使用。所以，需要设计一种方法，使得每个数被抽取的概率都是$\frac{n}{m}$。</p><h1 id="一、”每次都是-frac-1-i-”问题"><a href="#一、”每次都是-frac-1-i-”问题" class="headerlink" title="一、”每次都是 $\frac{1}{i}$”问题"></a>一、”每次都是 $\frac{1}{i}$”问题</h1><p><em>对于<code>n</code>(n&gt;=1)，如果每次（基数<code>k</code>从0到n递增）以$\frac{1}{i}$的概率决定是否替换选中元素直到<code>n</code>，那么最后每个元素被选中的概率相等，即为$\frac{1}{n}。$ </em></p><p>证明：</p><ul><li><p>假设最后被选中的元素<code>a</code>(a&lt;=n)，它是在第<code>k</code>(k&lt;=n)次被选中。也就是说在第<code>k</code>次之后都不会有元素被选中，这样子才能确保最后选中的元素是<code>a</code>。</p></li><li><p>那么它被选中的概率等于第<code>k</code>次被选中的概率*第<code>k</code>次以后都没有元素选中。</p></li></ul><script type="math/tex; mode=display">\frac{1}{k} × \frac{k}{k+1} × \frac{k+1}{k+2} × ··· × \frac{n-1}{n} = \frac{1}{n}</script><p>可以得到结论：在未知样本空间<code>n</code>中，随机抽取一个数<code>a</code>，它的概率是$\frac{1}{n}$。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Sampling(std::vector&lt;int&gt; &amp;vec, int &amp;num)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; 1; i &lt; vec.size(); i++)&#123;</span><br><span class="line">int random &#x3D; rand() % i;</span><br><span class="line">num &#x3D; vec[random];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、如何从未知样本空间m随机抽取n个数"><a href="#二、如何从未知样本空间m随机抽取n个数" class="headerlink" title="二、如何从未知样本空间m随机抽取n个数"></a>二、如何从未知样本空间m随机抽取n个数</h1><p>假如按照第一点中的方法，抽取n个数。的确也是能实现$\frac{n}{m}$的概率，但是要遍历n次，时间复杂度就顶不住了。</p><p>换个角度，假设，先取出前n个元素组成一个集合N，把第n+1个元素放进集合N，从集合N中抽取n个元素重新组成集合N，直至最后一个元素。</p><p>也就是说，第n+1个元素随机替换集合N中的一个元素。下面证明最后得出的集合N中，每个元素的概率是$\frac{n}{m}$。</p><p>证明：</p><ul><li><p>假设集合N中的任意一个元素<code>a</code>，它是第<code>k</code>(n&lt;=k&lt;=m)次被放进集合N，它最后留在集合N的概率 = 在它后面的元素都没有被抽中的概率 + 在它后面的元素被抽中的概率 * 没有替换元素<code>a</code>的概率。</p></li><li><p>根据第一点中的方法，第<code>k</code>(k&gt;=n)次某元素被选中并替换到集合N的概率是$\frac{1}{k} × n = \frac{n}{k}$。</p></li></ul><script type="math/tex; mode=display">\frac{n}{k} × (\frac{k+1-n}{k+1} + \frac{n}{k+1} × \frac{n-1}{n}) × (\frac{k+2-n}{k+2} + \frac{n}{k+2} × \frac{n-1}{n}) × ··· × \frac{m-n}{m} + \frac{n}{m} × \frac{n-1}{n}= \frac{n}{k} × \frac{k}{k+1} × \frac{k+1}{k+2} × ··· × \frac{m-1}{m} = \frac{n}{m}</script><p>证明成立，这个实现就是蓄水池抽样算法（Reservoir Sampling）。</p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ReservoirSampling(std::vector&lt;int&gt; &amp;vec,int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; n; i &lt; vec.size(); i++) &#123;</span><br><span class="line">int random &#x3D; rand() % i;</span><br><span class="line">if(random &lt; n)&#123;</span><br><span class="line">    std::swap(vec[random], vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;up-low&gt;n</span><br><span class="line">void ReservoirSampling(std::vector&lt;int&gt; &amp;vec, int n, int low, int up)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; low + n; i &lt; up; i++) &#123;</span><br><span class="line">int random &#x3D; rand() % (up - low) + low;</span><br><span class="line">if (random &lt; low + n) &#123;</span><br><span class="line">    std::swap(vec[random], vec[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Reservoir Sampling 抽样算法的空间复杂度$O(1)$，时间复杂度$O(n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;“从m个数中随机抽取n个”，在m是确定值的情况下，使用Fisher Yates 洗牌算法可以快速的得到足够随机的n个数。&lt;/p&gt;
&lt;p&gt;但是，当m不是确定值呢？&lt;/p&gt;
&lt;p&gt;可以使用Reservoir Sampling 抽样算法。&lt;/p&gt;
&lt;p&gt;由于m是不确定的，那么使用</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="抽样算法" scheme="https://www.chaguake.com/tags/%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Fisher Yates 洗牌算法</title>
    <link href="https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/"/>
    <id>https://www.chaguake.com/2021/04/02/fisher-yates-shuffle-alg/</id>
    <published>2021-04-02T06:29:14.000Z</published>
    <updated>2021-04-06T08:20:16.075Z</updated>
    
    <content type="html"><![CDATA[<p>洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。</p><h1 id="不加权模式"><a href="#不加权模式" class="headerlink" title="不加权模式"></a>不加权模式</h1><p>Fisher Yates洗牌算法凭借着$O(1)$空间、$O(n)$时间复杂度，实现了“在n个不同的数中随机取出m个数”一类的问题。</p><p>实现大致是将从未抽取集合中随机抽中的数x与未抽取集合中的最后一个数交换，未抽取集合个数-1。不断重复，直至未抽取集合个数为0。</p><p>实现细节：</p><ul><li><p>已知原始数组长度为n，将原始数组分为未抽取数组（长度为n）和取出数组（长度为0）。</p></li><li><p>在未抽取数组中，<strong>随机</strong>（算法依赖这个’随机‘是否够随机）选中一个数p，将数p的位置与原始数组最后一位（首位也行）交换。</p></li><li><p>重复上一个步骤，直到未抽取数组的个数为0。</p></li></ul><p><em>有点像选择排序，差异在于每次在’未排序‘区中找的不是最小（或最大）的，而是随机选一个。</em></p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void shuffle(int *arr,int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i &#x3D; nLen - 1; i &gt; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        int num &#x3D; rand() % i;</span><br><span class="line">        std::swap(arr[i], arr[num]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法脱离数学是不讲武德的，下面就证明：集合set有n个不同的数字，第i次抽取到的数字p的概率是否是都是$\frac{1}{n}$ 。</p><ul><li><p>第i次才抽中数字p，那么前i-1次都是没抽到数字p的。</p></li><li><p>第一次抽取，没抽到数字p的概率是$\frac{n-1}{n}$。</p></li><li><p>第二次抽取，没抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1}$。</p></li></ul><p>……</p><ul><li><p>第i-1次抽取，没抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1} × ··· × \frac{n-i}{n-i+1}$。</p></li><li><p>第i次抽取，抽到数字p的概率是$\frac{n-1}{n} × \frac{n-2}{n-1} × ··· × \frac{n-i}{n-i+1} × \frac{1}{n-i} = \frac{1}{n}$。</p></li></ul><p>Fisher Yates洗牌算法有两个随机因子，一个是每一次从未抽取集合抽取的元素，另一个是每一次未抽取集合最后一个元素，但最关键是第一个随机因子。</p><p>假如为每个元素加上权重，使得每个元素本身被抽中的优先度不一样，又如何用Fisher Yates洗牌算法来实现呢？</p><h1 id="加权模式"><a href="#加权模式" class="headerlink" title="加权模式"></a>加权模式</h1><p>一个比较笨重的办法,将元素按照其权重展开:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;a:2,b:3,c:1&#125;</span><br><span class="line">&#123;a,a,b,b,b,c&#125;</span><br></pre></td></tr></table></figure><p>（但显然不是好办法。=_=）</p><p>因为有了权重作为附加条件，再按照上面”从未抽取集合中随机抽取一个元素“的方式是不满足条件的，必须将权重参与到运算中（随机抽取）。</p><p>那么，可以将所有权重值加起来，得到一个权重总数sum，然后在0到sum的范围内随机产生一个数num，再将num与未抽取集合中每一个元素作某种比较，最后输出随机数。</p><p>步骤如下：</p><ul><li><p>统计出所有元素的权重和sum。</p></li><li><p>在0到sum之间随机产生一个随机数num，遍历未抽取集合。</p></li><li><p>用随机数num和当前迭代元素n比较。假如num小于n，结束迭代，返回元素n（与最后一位元素交换），sum-=n，重复第二步；假如num大于n，则num-=n，继续迭代。</p></li><li><p>遍历到未抽取集合的最后一个元素时，如果num大于n，则输出最后一个元素，sum-=n。</p></li><li><p>重复第二步。</p></li></ul><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void shuffle2(int *arr, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for (size_t i &#x3D; 0; i &lt; nLen; i++)&#123;</span><br><span class="line">sum +&#x3D; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i &#x3D; nLen - 1; i &gt; 0; i--) &#123;</span><br><span class="line">int num &#x3D; rand() % sum;</span><br><span class="line">size_t j &#x3D; 0;</span><br><span class="line">for (; j &lt; i; j++)&#123;</span><br><span class="line">    if (num &gt; arr[j]) &#123;</span><br><span class="line">num -&#x3D; arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -&#x3D; arr[j];</span><br><span class="line">std::swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度还是$O(1)$，但时间复杂度是$O(n+n^2)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;洗牌算法从一个排序组合的数组，得到另一个随机排序组合的数组。下面介绍在原数组上随机打乱顺序的做法。&lt;/p&gt;
&lt;h1 id=&quot;不加权模式&quot;&gt;&lt;a href=&quot;#不加权模式&quot; class=&quot;headerlink&quot; title=&quot;不加权模式&quot;&gt;&lt;/a&gt;不加权模式&lt;/h1&gt;&lt;p&gt;F</summary>
      
    
    
    
    <category term="算法" scheme="https://www.chaguake.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="洗牌算法" scheme="https://www.chaguake.com/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试知识点——C/C++基础知识</title>
    <link href="https://www.chaguake.com/2021/04/02/interview-knowledge-C-base/"/>
    <id>https://www.chaguake.com/2021/04/02/interview-knowledge-C-base/</id>
    <published>2021-04-02T01:52:14.000Z</published>
    <updated>2021-04-06T09:02:17.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、extern关键字的使用"><a href="#一、extern关键字的使用" class="headerlink" title="一、extern关键字的使用"></a>一、extern关键字的使用</h1><p><strong>1、外部变量声明，使得全局变量可跨文件使用。</strong></p><p>不同.cpp文件在编译时是独立的，需要添加<code>extern</code>关键字声明该变量是在外部（其他.cpp文件）定义。</p><p><strong>2、函数声明。</strong></p><p>可以使用<code>extern void fun();</code>来代替引用<code>#include *.h</code>的方式，去声明外部函数。</p><p><em>这里有个问题，网络上说单方面修改extern函数原型时编译器不会报错，但博主在VS2008和VS2017上是会报错的（编译成功，链接失败）。</em></p><p><strong>3、链接规范（extern “C”）。</strong></p><p>链接规范的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; void fun();</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    void fun1();</span><br><span class="line">    void fun2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++由于支持函数重载，在C++编译器工作时，会生成一个用于链接的中间函数名。</p><p>而C不支持函数重载，所以在C编译器工作时，生成的中间函数名只是简单的在函数名前加上一个下划线<code>_</code>。</p><p>在C++使用C函数时，会将C函数生成一个C++规则的中间函数名。这样子，在进行链接时，C编译生成的目标文件和C++编译生成的目标文件中的中间函数名就会不一样，导致链接失败。</p><p>所以，C++调用C的函数时，需要添加extern “C”来声明，按照C的规则编译C的函数。</p><p>而C调用C++的函数，除了使用extern “C”之外，还需要做一层包装函数（添加extern “C”为了生成C风格的中间函数名，添加包装函数为了支持重载）。</p><p><em>值得注意的是，不应该把头文件放在extern “C”的范围里，因为有可能会导致符号嵌套。</em></p><h1 id="二、placement-new"><a href="#二、placement-new" class="headerlink" title="二、placement new"></a>二、placement new</h1><p>当需要在一块已分配的内存上创建对象时，需要使用placement new。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr &#x3D; new(buff) A;</span><br></pre></td></tr></table></figure><p>使用强制转换的办法也可以在已分配的内存上创建对象，但是不会调用对象的构造函数，而且，有可能会有内存溢出的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *ptr &#x3D; (A*)buff;</span><br></pre></td></tr></table></figure><h1 id="三、stdcall、cdecl和-fastcall三种函数调用协议"><a href="#三、stdcall、cdecl和-fastcall三种函数调用协议" class="headerlink" title="三、stdcall、cdecl和__fastcall三种函数调用协议"></a>三、<strong>stdcall、</strong>cdecl和__fastcall三种函数调用协议</h1><p>参见<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-160">参数传递和命名约定</a>和<a href="https://www.cnblogs.com/yejianyong/p/7506465.html">C++知识回顾之<strong>stdcall、</strong>cdcel和__fastcall三者的区别</a></p><p><strong>1、协议常用场合</strong></p><ul><li><p>__stdcall：Windows API默认的函数调用协议。</p></li><li><p>__cdecl：C/C++默认的函数调用协议。</p></li><li><p>__fastcall：适用于对性能要求高的场合（只适用于X86架构，在ARM和X64体系架构的编译器会直接忽略该关键字）。</p></li></ul><p><strong>2、函数入栈方式</strong></p><ul><li><p>__stdcall：函数参数由右向左入栈。</p></li><li><p>__cdecl：函数参数由右向左入栈。</p></li><li><p>__fastcall：从左开始不大于4字节的参数放入CPU的ECX和EDX寄存器，其余参数从右向左入栈。</p></li></ul><p><strong>3、栈内数据清除方式</strong></p><ul><li><p>__stdcall：函数调用结束后由被调用函数清除栈内数据。</p></li><li><p>__cdecl：函数调用结束后由函数调用者清除栈内数据。</p></li><li><p>__fastcall：函数调用结束后由被调用函数清除栈内数据。</p></li></ul><p>注：</p><p>1)不同编译器设定的栈结构不尽相同，跨开发平台时由函数调用者清除栈内数据不可行。</p><p>2)某些函数的参数是可变的，如printf函数，这样的函数只能由函数调用者清除栈内数据。</p><p>3)由调用者清除栈内数据时，每次调用都包含清除栈内数据的代码，故可执行文件较大。</p><p><strong>4、C编译器函数名称修饰规则</strong></p><ul><li><p>__stdcall：编译后，函数名被修饰为“_functionname@number”（number为参数字节数）。</p></li><li><p>__cdecl：编译后，函数名被修饰为“_functionname”。</p></li><li><p>__fastcall：编译后，函数名给修饰为“@functionname@nmuber”（number为参数字节数）。</p></li></ul><p><strong>C++编译器函数名称修饰规则</strong></p><ul><li><p>__stdcall：编译后，函数名被修饰为“?functionname@@YG<strong>**</strong>@Z”。</p></li><li><p>__cdscl：编译后，函数名被修饰为“?functionname@@YA<strong>**</strong>@Z”。</p></li><li><p>__fastcall：编译后，函数名被修饰为“?functionname@@YI<strong>**</strong>@Z”。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、extern关键字的使用&quot;&gt;&lt;a href=&quot;#一、extern关键字的使用&quot; class=&quot;headerlink&quot; title=&quot;一、extern关键字的使用&quot;&gt;&lt;/a&gt;一、extern关键字的使用&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、外部变量声明，使得全局变</summary>
      
    
    
    
    <category term="面试" scheme="https://www.chaguake.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="C/C++知识" scheme="https://www.chaguake.com/tags/C-C-%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（三）——生成三角形小结笔记</title>
    <link href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/"/>
    <id>https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/</id>
    <published>2021-03-31T10:50:43.000Z</published>
    <updated>2021-04-02T01:39:54.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl.com/Getting-started/Hello-Triangle">英文原文地址</a> <a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">中文翻译地址</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>小结主要介绍了各类着色器的使用，特别是可编程的顶点着色器和片段着色器。</p><h4 id="一、图形渲染管线"><a href="#一、图形渲染管线" class="headerlink" title="一、图形渲染管线"></a>一、图形渲染管线</h4><p>图形渲染管线（简称管线）主要作用是将一堆物体的3D坐标转换成2D坐标输出，最后呈现在屏幕上。</p><p>管线接受一组3D坐标，然后通过几个串行的阶段处理（在GPU上并行处理），最终输出屏幕画面。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="管线每个阶段的抽象显示图"></p><p>如上图。每一个阶段称为着色器，其中。标有蓝色的着色器有顶点着色器、几何着色器和片段着色器。它们允许我们自定义编写着色器处理逻辑。</p><h4 id="二、各类着色器介绍"><a href="#二、各类着色器介绍" class="headerlink" title="二、各类着色器介绍"></a>二、各类着色器介绍</h4><p><strong>OpenGL着色器语言</strong></p><p>有些着色器允许自己设计，可以用OpenGL着色器语言（GLSL）编写。</p><p><strong>顶点着色器</strong></p><p>顶点着色器将用户输入的3D坐标转换成GLSL中的3D坐标，并且可以对顶点3D坐标做一些处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos.x, aPos.y, aPos.z, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GLSL中，3D坐标是一个有4个分量的向量，<code>x</code>、<code>y</code>、<code>z</code>、<code>w</code>，最后一个用于透视除法上。</p><p><strong>图元着色器</strong></p><p>图元着色器将顶点着色器的顶点输出作为输入，然后将所有的顶点装配成指定图元的形状。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><p><strong>几何着色器</strong></p><p>几何着色器可以将图元着色器输出的顶点构造出其它的图元形状。</p><p><strong>光栅化</strong></p><p>光栅化将图元映射成屏幕上的像素形状，即片段。</p><p><strong>片段着色器</strong></p><p>片段着色器计算每一个像素的颜色，它需要接收场景的数据（例如：光照、阴影等），综合计算出像素点的颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>片段着色器只有一个颜色输出变量。</p><p><strong>测试和混合</strong></p><p>当每个片段的颜色都确定之后，还需要检查每个片段之间的层级关系和透明度叠加之后的显示颜色。</p><h4 id="三、编译着色器"><a href="#三、编译着色器" class="headerlink" title="三、编译着色器"></a>三、编译着色器</h4><p>着色器代码需要在运行时动态编译，代码以字符串形式传递给OpenGL。</p><p>首先，得创建着色器对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p><code>glCreateShader</code>函数需要输入当前需要创建的着色器类型，GL_FRAGMENT_SHADER是片段着色器，GL_VERTEX_SHADER是顶点着色器。</p><p>下一步，需要将着色器源码附加到着色器对象上，并且编译它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p><code>glShaderSource</code>函数的第一个参数是着色器对象，第二个参数是着色器源码数量，第三个参数是着色器源码字符串数组首地址，第四个参数是着色器源码字符串长度数组首地址。</p><p>可以对着色器源码编译的结果检测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int  success;</span><br><span class="line">char infoLog[512];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、着色器程序对象"><a href="#四、着色器程序对象" class="headerlink" title="四、着色器程序对象"></a>四、着色器程序对象</h4><p>着色器编译出来之后，需要将他们链接到同一个着色器程序对象上。</p><p>同样的，需要创建着色器程序对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int shaderProgram;</span><br><span class="line">shaderProgram &#x3D; glCreateProgram();</span><br></pre></td></tr></table></figure><p>下一步，把各个着色器附加到着色器程序对象上，然后进行链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>同样，也可以捕捉链接失败信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">if(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>着色器对象链接到着色器程序对象之后，着色器对象就可以删除了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>当需要使用着色器程序时，调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>删除着色器程序，调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteProgram(shaderProgram);</span><br></pre></td></tr></table></figure><h4 id="五、顶点缓冲对象（Vertex-Buffer-Object，VBO）"><a href="#五、顶点缓冲对象（Vertex-Buffer-Object，VBO）" class="headerlink" title="五、顶点缓冲对象（Vertex Buffer Object，VBO）"></a>五、顶点缓冲对象（Vertex Buffer Object，VBO）</h4><p>顶点数据从内存发送到GPU是一件耗时费力的事情，所以尽可能一次性发送更多的数据到显卡上。</p><p>定点缓冲对象可包含顶点的多种属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">        &#x2F;&#x2F; positions          &#x2F;&#x2F; colors           &#x2F;&#x2F; texture coords</span><br><span class="line">         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f, &#x2F;&#x2F; top right</span><br><span class="line">         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f, &#x2F;&#x2F; bottom right</span><br><span class="line">        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f, &#x2F;&#x2F; bottom left</span><br><span class="line">        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f  &#x2F;&#x2F; top left </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>创建VBO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VBO;</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br></pre></td></tr></table></figure><p>绑定数据，但在此之前需要声明接下来绑定的数据是哪种类型的，应该把它绑定到哪种缓冲对象上：</p><p>因为要做顶点缓冲类型的数据绑定，所以用<code>GL_ARRAY_BUFFER</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);  </span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><code>glBufferData</code>函数第一个参数是目标缓冲类型，第二个参数是需绑定数据的大小，第三个参数是需绑定数据地址，第四个参数指定显卡如何管理当前绑定的数据。</p><ul><li><p>GL_STATIC_DRAW ：数据不会或几乎不会改变。</p></li><li><p>GL_DYNAMIC_DRAW ：数据会改变很多。</p></li><li><p>GL_STREAM_DRAW ：数据每次绘制时都会改变。</p></li></ul><p>根据值不同，需绑定数据会放在显卡不同的位置。</p><p>摧毁VBO对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteBuffers(1, &amp;VBO);</span><br></pre></td></tr></table></figure><h4 id="六、索引缓冲对象（Element-Buffer-Object，EBO或Index-Buffer-Object，IBO）"><a href="#六、索引缓冲对象（Element-Buffer-Object，EBO或Index-Buffer-Object，IBO）" class="headerlink" title="六、索引缓冲对象（Element Buffer Object，EBO或Index Buffer Object，IBO）"></a>六、索引缓冲对象（Element Buffer Object，EBO或Index Buffer Object，IBO）</h4><p>万物皆三角形。三角形可以说是3D图形最小的组成元素，毕竟三角形的三个顶点肯定在同一个平面上。</p><p>在绘制矩阵图形时，可以将矩阵分成两个三角形来绘制。但这样子，就会出现共同顶点，在VBO上则是重复存储，浪费开销。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f,  &#x2F;&#x2F; 左上角</span><br><span class="line">    &#x2F;&#x2F; 第二个三角形</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引缓冲对象可以使得VBO不用存储每个顶点重复的数据，然后通过固定索引来描绘出每个三角形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    0.5f, 0.5f, 0.0f,   &#x2F;&#x2F; 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  &#x2F;&#x2F; 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, &#x2F;&#x2F; 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   &#x2F;&#x2F; 左上角</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned int indices[] &#x3D; &#123; &#x2F;&#x2F; 注意索引从0开始! </span><br><span class="line">    0, 1, 3, &#x2F;&#x2F; 第一个三角形</span><br><span class="line">    1, 2, 3  &#x2F;&#x2F; 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建索引缓冲对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><p>绑定数据（跟VBO类似）到VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects_ebo.png" alt="EBO使用"></p><p>一般的，在绘制时使用<code>glDrawArrays</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是顶点坐标指针的起始索引，第三个参数是绘制顶点数量</span><br><span class="line">glDrawArrays(GL_TRIANGLES, 0, 3);</span><br></pre></td></tr></table></figure><p>使用索引绘制时需要用到<code>glDrawElements</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个参数是绘制图元的类型，第二个参数是绘制顶点数量，第三个参数是索引的类型，第四个是EBO数组地址的偏移量</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><p>摧毁EBO对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><h4 id="七、顶点数组对象（Vertex-Array-Object，VAO）"><a href="#七、顶点数组对象（Vertex-Array-Object，VAO）" class="headerlink" title="七、顶点数组对象（Vertex Array Object，VAO）"></a>七、顶点数组对象（Vertex Array Object，VAO）</h4><p>顶点数组对象封装了顶点所有属性数据（例如：坐标，颜色，纹理等），记录了顶点缓冲对像（VBO）和索引缓冲对象（EBO）的指针地址。</p><p>在配置顶点属性之后，VAO记录了配置的状态，在需要的时候绑定不同的VAO实现：</p><p><code>glEnableVertexAttribArray</code>函数和<code>glDisableVertexAttribArray</code>函数分别启用/禁用某个顶点属性，默认是禁用。</p><p><code>glVertexAttribPointer</code>函数用于设置顶点属性配置和关联的顶点缓冲对象。一般顶点属性会放在同一个VBO或EBO中，增加复用性。</p><p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png" alt="VAO调用VBO图"></p><p>创建VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VAO;</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时创建多个VAO</span><br></pre></td></tr></table></figure><p>使用VAO，需要先进行绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure><p>设置VBO、EBO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>接下来，就可以设置VAO的顶点属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code>函数参数定义：</p><ul><li><p>第一个参数是配置的顶点属性。在顶点着色器源码中使用<code>layout(location = 0)</code>来设置位置值位0，所以这里要传入对应的值。</p></li><li><p>第二个参数是顶点属性的大小。</p></li><li><p>第三个参数是数据的类型。</p></li><li><p>第四个参数是是否将数据标准化。如果设置为<code>GL_TRUE</code>，那么数据就会被映射在0到1之间。</p></li><li><p>第五个参数是步长。表示顶点属性之间的间隔。</p></li><li><p>第六个参数是当前使用的数据在缓冲数组中的偏移量（Offset）。</p></li></ul><p>解绑VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(NULL);</span><br></pre></td></tr></table></figure><p>摧毁VAO：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDeleteVertexArrays(1, &amp;VAO);&#x2F;&#x2F;可同时删除多个VAO</span><br></pre></td></tr></table></figure><h4 id="八、线框模式与填充模式"><a href="#八、线框模式与填充模式" class="headerlink" title="八、线框模式与填充模式"></a>八、线框模式与填充模式</h4><p><img src="https://learnopengl-cn.github.io/img/01/04/hellotriangle2.png" alt="线框模式与填充模式"></p><p>如果只想获取图元的形状，而不用填充颜色，可以使用线框模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</span><br></pre></td></tr></table></figure><p>填充模式（默认模式）则用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Hello-Triangle&quot;&gt;英文原文地址&lt;/a&gt; &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20star</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（二）——Hello Window小节笔记</title>
    <link href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-02/"/>
    <id>https://www.chaguake.com/2021/03/31/OpenGL-introduction-02/</id>
    <published>2021-03-31T06:59:55.000Z</published>
    <updated>2021-03-31T10:53:13.460Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://learnopengl.com/#!Getting-started/Hello-Window">英文原文地址</a> <a href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/">中文翻译地址</a></p><p>整个小节看这一份完整的源码就可以了。<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window_clear/hello_window_clear.cpp">这里</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初始化GLFW。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwInit();</span><br></pre></td></tr></table></figure><p>调用<code>glfwWindowHint</code>函数配置GLFW。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br></pre></td></tr></table></figure><p>调用<code>glfwCreateWindow</code>函数创建窗口对象，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window &#x3D; glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);</span><br></pre></td></tr></table></figure><p>把窗口的上下文设置为当前线程的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwMakeContextCurrent(window);</span><br></pre></td></tr></table></figure><p>传递OpenGL函数指针给GLAD。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递窗口大小给OpenGL，由于窗口大小会变化，所以通过注册函数来实现动态更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void framebuffer_size_callback(GLFWwindow* window, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(0, 0, width, height);</span><br><span class="line">&#125;</span><br><span class="line">glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure><p>循环渲染，直到窗口退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void processInput(GLFWwindow *window)</span><br><span class="line">&#123;</span><br><span class="line">    if(glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    processInput(window);&#x2F;&#x2F;捕捉用户输入。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;渲染指令</span><br><span class="line">    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glfwSwapBuffers(window);&#x2F;&#x2F;交换颜色缓冲。</span><br><span class="line">    glfwPollEvents();&#x2F;&#x2F;检测事件。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出时释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://learnopengl.com/#!Getting-started/Hello-Window&quot;&gt;英文原文地址&lt;/a&gt; &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20start</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（一）——GLFW库与GLAD库</title>
    <link href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-01/"/>
    <id>https://www.chaguake.com/2021/03/31/OpenGL-introduction-01/</id>
    <published>2021-03-31T06:22:54.000Z</published>
    <updated>2021-03-31T10:53:27.400Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL入门系列是博主学习LearnOpenGL教程的笔录。</p><p>LearnOpenGL中文翻译版教程地址：<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a></p><p>LearnOpenGL英文原作者版地址：<a href="https://learnopengl.com/">https://learnopengl.com/</a></p><h2 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h2><blockquote><p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。</p></blockquote><p>官网：<a href="https://www.glfw.org/">https://www.glfw.org/</a></p><p>GLFW提供了简单的API，方便开发者创建windows、contexts、surfaces、input和events等一系列操作。</p><p>官网一般提供了现成的二进制文件库和头文件，将它引用到项目中使用。</p><h2 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h2><p>由于OpenGL的接口函数地址一般是未知的，需要在运行期间动态获取。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义函数原型</span><br><span class="line">typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);</span><br><span class="line">&#x2F;&#x2F; 找到正确的函数并赋值给函数指针</span><br><span class="line">GL_GENBUFFERS glGenBuffers  &#x3D; (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);</span><br><span class="line">&#x2F;&#x2F; 现在函数可以被正常调用了</span><br><span class="line">GLuint buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Dav1dde/glad">GLAD</a>提供了一个<a href="http://glad.dav1d.de/">在线服务</a>，通过一些自定义配置，生成一个文件库，把它引用到项目中使用。</p><p><strong><em>值得注意的是，在引用GLFW的头文件之前要先引用GLAD的头文件，因为GLAD包含了OpenGL的头文件。</em></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OpenGL入门系列是博主学习LearnOpenGL教程的笔录。&lt;/p&gt;
&lt;p&gt;LearnOpenGL中文翻译版教程地址：&lt;a href=&quot;https://learnopengl-cn.github.io/&quot;&gt;https://learnopengl-cn.github.io</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
