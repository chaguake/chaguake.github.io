<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶瓜客</title>
  
  <subtitle>解衣又作茶瓜客，倚槛同看烟雨峰</subtitle>
  <link href="https://www.chaguake.com/atom.xml" rel="self"/>
  
  <link href="https://www.chaguake.com/"/>
  <updated>2021-09-10T00:45:01.671Z</updated>
  <id>https://www.chaguake.com/</id>
  
  <author>
    <name>茶瓜客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>细分着色器01——OpenGL的细分着色</title>
    <link href="https://www.chaguake.com/2021/09/10/Subdivision01/"/>
    <id>https://www.chaguake.com/2021/09/10/Subdivision01/</id>
    <published>2021-09-10T00:42:32.000Z</published>
    <updated>2021-09-10T00:45:01.671Z</updated>
    
    <content type="html"><![CDATA[<p align="center">    <img src="https://z3.ax1x.com/2021/09/09/hLwZj0.png" width="95%">    <br />    <small> 细分着色器01 </small></p><h2 id="细分着色器"><a href="#细分着色器" class="headerlink" title="细分着色器"></a>细分着色器</h2><p>在 《OpenGL编程指南（第九版）》的第9章中，介绍了细分着色器的两个处理阶段——细分控制和细分计算，这两个分别对应各自的着色器。</p><h3 id="细分控制着色器"><a href="#细分控制着色器" class="headerlink" title="细分控制着色器"></a>细分控制着色器</h3><p>细分控制着色器可以控制输出面片的细分程度，OpenGl支持三种不同的细分域：四边形、三角形以及等值线集合。</p><p>而细分总量是通过两组数据来控制：内侧和外侧细分层级。外侧细分层级控制细分区域的周长，保存在4个元素的数组 gl_TessLevelOuter 中。内侧细分层级设置细分区域内部划分方式，保存在2个元素的数组 gl_TessLevelInner 中。</p><p><strong>四边形细分</strong></p><p>四边形细分使用数组 gl_TessLevelOuter 和 gl_TessLevelInner 所有元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gl_TessLevelInner[0] &#x3D; 3.0;</span><br><span class="line">gl_TessLevelInner[1] &#x3D; 4.0;</span><br><span class="line"></span><br><span class="line">gl_TessLevelOuter[0] &#x3D; 2.0;</span><br><span class="line">gl_TessLevelOuter[1] &#x3D; 3.0;</span><br><span class="line">gl_TessLevelOuter[2] &#x3D; 2.0;</span><br><span class="line">gl_TessLevelOuter[3] &#x3D; 4.0;</span><br></pre></td></tr></table></figure><p align="center">    <img src="https://z3.ax1x.com/2021/09/09/hLInAJ.png" width="95%">    <br />    <small> 四边形细分 </small></p><p><strong>三角形细分</strong></p><p>三角形细分只使用数组 gl_TessLevelOuter 前三个元素，使用数组 gl_TessLevelInner 第一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gl_TessLevelInner[0] &#x3D; 5.0;</span><br><span class="line"></span><br><span class="line">gl_TessLevelOuter[0] &#x3D; 6.0;</span><br><span class="line">gl_TessLevelOuter[1] &#x3D; 5.0;</span><br><span class="line">gl_TessLevelOuter[2] &#x3D; 8.0;</span><br></pre></td></tr></table></figure><p>而且，内侧细分层级数值的奇偶性对细分形式有影响。当内侧细分层级数值为奇数时，会在三角形细分域的中心创建一个小三角形；当内侧细分层级数值为偶数时，则会在其中心创建一个独立的细分坐标。</p><p align="center">    <img src="https://z3.ax1x.com/2021/09/09/hLIl1x.png" width="95%">    <br />    <small> 三角形细分 </small></p><h3 id="细分计算着色器"><a href="#细分计算着色器" class="headerlink" title="细分计算着色器"></a>细分计算着色器</h3><p>细分计算着色器使用 layout 布局限定符来设置图元类型（quads、triangles  以及 isolines，对应细分控制着色器的细分域类型）、图元的面朝向（cw、ccw，顺时针和逆时针）等等。</p><p>在细分计算着色器中的内置变量主要使用 gl_TessCoord 变量来获取细分顶点的局部坐标。</p><p>四边形细分可以使用插值计算或贝塞尔曲面来实现顶点位置的计算。</p><p>贝塞尔曲面计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#version 400 core</span><br><span class="line"></span><br><span class="line">layout (quads, equal_spacing, ccw) in;</span><br><span class="line"></span><br><span class="line">uniform mat4  projection;</span><br><span class="line">uniform mat4  view;</span><br><span class="line">uniform mat4  model;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">float</span><br><span class="line">B( int i, float u )</span><br><span class="line">&#123;</span><br><span class="line">    const vec4 bc &#x3D; vec4( 1, 3, 3, 1 );</span><br><span class="line">    </span><br><span class="line">    return bc[i] * pow( u, i ) * pow( 1.0 - u, 3 - i ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    vec4  pos &#x3D; vec4( 0.0 );</span><br><span class="line"></span><br><span class="line">    float  u &#x3D; gl_TessCoord.x;</span><br><span class="line">    float  v &#x3D; gl_TessCoord.y;</span><br><span class="line">    </span><br><span class="line">    for ( int j &#x3D; 0; j &lt; 4; ++j ) &#123;</span><br><span class="line">        for ( int i &#x3D; 0; i &lt; 4; ++i ) &#123;</span><br><span class="line">            pos +&#x3D; B( i, u ) * B( j, v ) * gl_in[4*j+i].gl_Position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gl_Position &#x3D; projection * view * model * pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三角形细分可以使用三角形的重心坐标公式来计算顶点位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#version 400 core</span><br><span class="line"></span><br><span class="line">layout (triangles, equal_spacing, cw) in;</span><br><span class="line"></span><br><span class="line">uniform mat4  projection;</span><br><span class="line">uniform mat4  view;</span><br><span class="line">uniform mat4  model;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    vec4  pos &#x3D; vec4( 0.0 );</span><br><span class="line"></span><br><span class="line">    float  u &#x3D; gl_TessCoord.x;</span><br><span class="line">    float  v &#x3D; gl_TessCoord.y;</span><br><span class="line"></span><br><span class="line">pos &#x3D; u * gl_in[0].gl_Position + </span><br><span class="line">  v * gl_in[1].gl_Position + </span><br><span class="line">  (1.0 - u - v) * gl_in[2].gl_Position;</span><br><span class="line"></span><br><span class="line">    gl_Position &#x3D; projection * view * model * pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="茶壶实例"><a href="#茶壶实例" class="headerlink" title="茶壶实例"></a>茶壶实例</h2><p>在 《OpenGL编程指南（第九版）》中的茶壶实例只有一半的坐标，它采用四边形细分，4x4个顶点的贝塞尔曲面计算顶点位置。可以看到随着细分层次变大，茶壶的形状也变得圆滑。</p><p align="center">    <img src="https://z3.ax1x.com/2021/09/09/hLIipq.png" width="95%">    <br />    <small> 茶壶实例 </small></p><p>在茶壶实例的细分计算着色器中，B 函数为简单地伯恩斯坦多项式的实现。</p><h2 id="立方体实例"><a href="#立方体实例" class="headerlink" title="立方体实例"></a>立方体实例</h2><p align="center">    <img src="https://z3.ax1x.com/2021/09/09/hLIpkj.png" width="95%">    <br />    <small> 立方体实例 </small></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://z3.ax1x.com/2021/09/09/hLwZj0.png&quot; width=&quot;95%&quot;&gt;
    &lt;br /&gt;    &lt;small&gt; 细分着色器01 &lt;/small&gt;
&lt;/p&gt;


&lt;h2 i</summary>
      
    
    
    
    <category term="图形学" scheme="https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>LearnRayTracing01——并行处理像素点计算</title>
    <link href="https://www.chaguake.com/2021/09/08/LearnRayTracing01/"/>
    <id>https://www.chaguake.com/2021/09/08/LearnRayTracing01/</id>
    <published>2021-09-08T05:42:48.000Z</published>
    <updated>2021-09-08T05:45:35.859Z</updated>
    
    <content type="html"><![CDATA[<p align="center">    <img src="https://z3.ax1x.com/2021/09/08/h7mUOO.png" width="95%">    <br />    <small> LearnRayTracing01 </small></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习 <a href="https://github.com/RayTracing/raytracing.github.io">Ray Tracing in One Weekend Book Series</a> 中第一章 <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a> 的时候，感觉在原代码中输出结果上并不能实时预览，而且也没有多线程并发渲染。</p><p>结合之前学习 <a href="https://learnopengl-cn.github.io/">LearnOpenGL</a> 的教程，可以将原来的颜色数据当作纹理渲染到窗口上。参考代码在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp">这里</a>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，在 <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a> 中可以看到，像素是从上往下、从左到右来处理的。所以在 <code>while (!glfwWindowShouldClose(window))</code> 这个渲染循环中，需要实时更新texture的数据。那么，使用到 <code>glTexSubImage2D</code> 这个API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, SCR_WIDTH, SCR_HEIGHT, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure><p>现在，就只用关心 <code>data</code> 变量的值计算填充了。</p><p>原来渲染代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (int j &#x3D; image_height-1; j &gt;&#x3D; 0; --j) &#123;</span><br><span class="line">std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; std::flush;</span><br><span class="line">for (int i &#x3D; 0; i &lt; image_width; ++i) &#123;</span><br><span class="line">color pixel_color(0,0,0);</span><br><span class="line">for (int s &#x3D; 0; s &lt; samples_per_pixel; ++s) &#123;</span><br><span class="line">auto u &#x3D; (i + random_double()) &#x2F; (image_width-1);</span><br><span class="line">auto v &#x3D; (j + random_double()) &#x2F; (image_height-1);</span><br><span class="line">ray r &#x3D; cam.get_ray(u, v);</span><br><span class="line">pixel_color +&#x3D; ray_color(r, world, max_depth);</span><br><span class="line">&#125;</span><br><span class="line">write_color(std::cout, pixel_color, samples_per_pixel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，从原来 <code>write_color</code> 中将数据输出到 <code>std::cout</code> 变成输出到 <code>data</code> 变量。代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int j &#x3D; SCR_HEIGHT - 1; j &gt;&#x3D; 0; --j) &#123;</span><br><span class="line">std::cerr &lt;&lt; &quot;\rScanlines remaining: &quot; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; std::flush;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;std::future&lt;void&gt;&gt;&gt; list;</span><br><span class="line">for (int i &#x3D; 0; i &lt; SCR_WIDTH; ++i) &#123;</span><br><span class="line">std::shared_ptr&lt;std::future&lt;void&gt;&gt; ptr &#x3D; std::make_shared&lt;std::future&lt;void&gt;&gt;(std::async(render_color, world, cam, samples_per_pixel, max_depth, i, j));</span><br><span class="line">list.push_back(ptr);</span><br><span class="line">&#x2F;&#x2F;render_color(world, cam, samples_per_pixel, max_depth, i, j);</span><br><span class="line">&#125;</span><br><span class="line">deal_future(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将对每个像素的操作封装到 <code>render_color</code> 函数中。然后使用C++关键字 <code>std::future</code> 来封存每个像素处理得状态，将一行像素的操作先推进容器 <code>std::vector</code> 中，然后再一起处理（其实就是 <code>std::future::wait</code> 函数的调用）。</p><p>当然，在对每个future对象遍历调用 <code>wait</code> 函数时，还可以使用 <a href="https://www.cnblogs.com/lfri/p/10111315.html">OpenMP</a> 的特性。使得每个for子循环并行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void deal_future(std::vector&lt;std::shared_ptr&lt;std::future&lt;void&gt;&gt;&gt; &amp;list)</span><br><span class="line">&#123;</span><br><span class="line">#pragma omp parallel for schedule(dynamic, 1)</span><br><span class="line">for (int i &#x3D; 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">list[i]-&gt;wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，渲染一张1600x900的照片只需392s（GTX 1050），而原来需要2075s。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://z3.ax1x.com/2021/09/08/h7mUOO.png&quot; width=&quot;95%&quot;&gt;
    &lt;br /&gt;    &lt;small&gt; LearnRayTracing01 &lt;/small&gt;
&lt;/</summary>
      
    
    
    
    <category term="图形学" scheme="https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Ray Tracing" scheme="https://www.chaguake.com/tags/Ray-Tracing/"/>
    
  </entry>
  
  <entry>
    <title>译文：Ray Marching and Signed Distance Functions</title>
    <link href="https://www.chaguake.com/2021/09/07/RayMarchingAndSDF/"/>
    <id>https://www.chaguake.com/2021/09/07/RayMarchingAndSDF/</id>
    <published>2021-09-07T08:00:39.000Z</published>
    <updated>2021-09-08T05:50:12.903Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/">原文</a></p><hr><h2 id="Signed-Distance-Functions"><a href="#Signed-Distance-Functions" class="headerlink" title="Signed Distance Functions"></a>Signed Distance Functions</h2><p>SDF，符号距离函数，用于计算点和平面的位置关系，根据返回值的符号，来判断点是在平面内部还是外部。</p><p>（原文这里使用了一个圆心在原点、半径为1的球体做示例。）</p><p>对一些常见的3D物体的SDF函数，参见<a href="https://iquilezles.org/www/articles/distfunctions/distfunctions.htm">Modeling with Distance Functions</a>。</p><h2 id="The-Raymarching-Algorithm"><a href="#The-Raymarching-Algorithm" class="headerlink" title="The Raymarching Algorithm"></a>The Raymarching Algorithm</h2><p>与光线跟踪一样，我们为相机选择一个位置，在其前面放置一个网格，通过网格中的每个点从相机发送光线，每个网格点对应于输出图像中的一个像素。</p><p align="center">    <img src="http://jamie-wong.com/images/16-07-11/raytrace.png" width="95%">    <br />    <small> From "Ray tracing" on Wikipedia </small></p><p>在光线跟踪中，整个场景是根据有符号距离函数定义的。使用SDF可以快速而安全地让光线前进最大步伐（maximum step），直至物体表面（surface）。</p><p>如图，$p_0$ 是摄像机。蓝色线段是从摄像机穿过视图平面的光线。</p><p align="center">    <img src="http://jamie-wong.com/images/16-07-11/spheretrace.jpg" width="95%">    <br />    <small> From [GPU Gems 2: Chapter 8.](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-8-pixel-displacement-mapping-distance-functions) </small></p><p>在GLSL的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">float depth &#x3D; start;</span><br><span class="line">for (int i &#x3D; 0; i &lt; MAX_MARCHING_STEPS; i++) &#123;</span><br><span class="line">    float dist &#x3D; sceneSDF(eye + depth * viewRayDirection);</span><br><span class="line">    if (dist &lt; EPSILON) &#123;</span><br><span class="line">        &#x2F;&#x2F; We&#39;re inside the scene surface!</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Move along the view ray</span><br><span class="line">    depth +&#x3D; dist;</span><br><span class="line"></span><br><span class="line">    if (depth &gt;&#x3D; end) &#123;</span><br><span class="line">        &#x2F;&#x2F; Gone too far; give up</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return end;</span><br></pre></td></tr></table></figure><p>其实就是每次前进当前光点与球表面的距离，知道值小于0.001。</p><p>shadertoy：<a href="https://www.shadertoy.com/view/llt3R4">Ray Marching: Part 1</a>。</p><h2 id="Surface-Normals-and-Lighting"><a href="#Surface-Normals-and-Lighting" class="headerlink" title="Surface Normals and Lighting"></a>Surface Normals and Lighting</h2><p>计算机图形学中的大多数照明模型都使用曲面法线的一些概念来计算曲面上给定点处材质的颜色。当曲面由显式几何体（如多边形）定义时，通常会为每个顶点指定法线，并且可以通过插值周围顶点法线找到面上任何给定点的法线。</p><p>在使用SDF时，用梯度（gradient）来定义曲面法线。在点 $(x,y,z)$ 上的梯度函数 $f$ ，表示的是沿着某个方向，使得移动点 $(x,y,z)$ 变化最快的值。</p><p>$f(x,y,z)$ 的梯度写作 $\nabla f$ 。</p><script type="math/tex; mode=display">\nabla f =\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y},\frac{\partial f}{\partial z}\right)</script><p>但是没有必要在这里进行微积分运算。我们将通过采样曲面上点周围的点来进行近似，而不是取函数的实导数，这很像在学习如何进行导数之前，如何计算函数中的斜率。</p><script type="math/tex; mode=display">\overset{\to}{n}  = \begin{bmatrix}f(x + \varepsilon,y,z) - f(x - \varepsilon,y,z) \\f(x ,y+ \varepsilon,z) - f(x,y - \varepsilon,z) \\f(x ,y,z+ \varepsilon) - f(x ,y,z- \varepsilon) \end{bmatrix}</script><p>GLSL的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Using the gradient of the SDF, estimate the normal on the surface at point p.</span><br><span class="line"> *&#x2F;</span><br><span class="line">vec3 estimateNormal(vec3 p) &#123;</span><br><span class="line">    return normalize(vec3(</span><br><span class="line">        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),</span><br><span class="line">        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),</span><br><span class="line">        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shadertoy：<a href="https://www.shadertoy.com/view/lt33z7">Ray Marching: Part 2</a>。</p><h2 id="Moving-the-Camera"><a href="#Moving-the-Camera" class="headerlink" title="Moving the Camera"></a>Moving the Camera</h2><p>在GLSL中，实现类似gluLookAt函数的功能，提供一个变换矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Return a transformation matrix that will transform a ray from view space</span><br><span class="line"> * to world coordinates, given the eye point, the camera target, and an up vector.</span><br><span class="line"> *</span><br><span class="line"> * This assumes that the center of the camera is aligned with the negative z axis in</span><br><span class="line"> * view space when calculating the ray marching direction.</span><br><span class="line"> *&#x2F;</span><br><span class="line">mat4 viewMatrix(vec3 eye, vec3 center, vec3 up) &#123;</span><br><span class="line">vec3 f &#x3D; normalize(center - eye);</span><br><span class="line">vec3 s &#x3D; normalize(cross(f, up));</span><br><span class="line">vec3 u &#x3D; cross(s, f);</span><br><span class="line">return mat4(</span><br><span class="line">vec4(s, 0.0),</span><br><span class="line">vec4(u, 0.0),</span><br><span class="line">vec4(-f, 0.0),</span><br><span class="line">vec4(0.0, 0.0, 0.0, 1)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shadertoy：<a href="https://www.shadertoy.com/view/Xtd3z7">Ray Marching: Part 3</a>。</p><h2 id="Constructive-Solid-Geometry"><a href="#Constructive-Solid-Geometry" class="headerlink" title="Constructive Solid Geometry"></a>Constructive Solid Geometry</h2><p>CSG，构建实体几何，使用简单几何体通过集合运算得到的复杂几何体。集合运算有交集（intersection）、并集（union）以及差集（difference）。</p><p align="center">    <img src="http://jamie-wong.com/images/16-07-11/csg.png" width="95%">    <br />    <small> From "Constructive solid geometry" on Wikipedia </small></p><p>当组合表示为SDF的两个曲面时，这些操作都可以简洁地表达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float intersectSDF(float distA, float distB) &#123;</span><br><span class="line">    return max(distA, distB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float unionSDF(float distA, float distB) &#123;</span><br><span class="line">    return min(distA, distB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float differenceSDF(float distA, float distB) &#123;</span><br><span class="line">    return max(distA, -distB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几何体组合函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line">    float cubeDist &#x3D; cubeSDF(samplePoint) * 1.2;</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shadertoy：<a href="https://www.shadertoy.com/view/MttGz7">Ray Marching: Part 4</a>。</p><h2 id="Model-Transformations"><a href="#Model-Transformations" class="headerlink" title="Model Transformations"></a>Model Transformations</h2><p><strong>Rotation and Translation</strong></p><p>对一个SDF表面进行平移或变换，可以在计算SDF之前对这个点进行逆变换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line">    float cubeDist &#x3D; cubeSDF(samplePoint + vec3(0.0, sin(iGlobalTime), 0.0));</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shadertoy：<a href="https://www.shadertoy.com/view/XtcGWn">Ray Marching: Part 5</a>。</p><p>进一步来说，添加一个旋转矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mat4 rotateY(float theta) &#123;</span><br><span class="line">    float c &#x3D; cos(theta);</span><br><span class="line">    float s &#x3D; sin(theta);</span><br><span class="line"></span><br><span class="line">    return mat4(</span><br><span class="line">        vec4(c, 0, s, 0),</span><br><span class="line">        vec4(0, 1, 0, 0),</span><br><span class="line">        vec4(-s, 0, c, 0),</span><br><span class="line">        vec4(0, 0, 0, 1)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line"></span><br><span class="line">    vec3 cubePoint &#x3D; (invert(rotateY(iGlobalTime)) * vec4(samplePoint, 1.0)).xyz;</span><br><span class="line"></span><br><span class="line">    float cubeDist &#x3D; cubeSDF(cubePoint);</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用到sceneSDF函数就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float sceneSDF(vec3 samplePoint) &#123;</span><br><span class="line">    float sphereDist &#x3D; sphereSDF(samplePoint &#x2F; 1.2) * 1.2;</span><br><span class="line"></span><br><span class="line">    vec3 cubePoint &#x3D; (rotateY(-iGlobalTime) * vec4(samplePoint, 1.0)).xyz;</span><br><span class="line"></span><br><span class="line">    float cubeDist &#x3D; cubeSDF(cubePoint);</span><br><span class="line">    return intersectSDF(cubeDist, sphereDist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Uniform Scaling</strong></p><p>缩放会改变两点之间的距离，引起距离场失真。</p><p>所以在缩放之后的点，经过SDF判断之后，需要对结果进行校准。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float dist &#x3D; someSDF(samplePoint &#x2F; scalingFactor) * scalingFactor;</span><br></pre></td></tr></table></figure><p><strong>Non-uniform scaling and beyond</strong></p><p>首先计算下不均匀变换时导致的失真值：</p><script type="math/tex; mode=display">sphereSDF(x,y,z) = \sqrt{(2x)^2 + y ^2 +z^2} - 1</script><p>经过变换之后，可以乘以他们之间最小值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float dist &#x3D; someSDF(samplePoint &#x2F; vec3(s_x, s_y, s_z)) * min(s_x, min(s_y, s_z));</span><br></pre></td></tr></table></figure><p>shadertoy：<a href="https://www.shadertoy.com/view/4tcGDr">Ray Marching: Part 6</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Signed-Distance-Functions&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="图形学" scheme="https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="SDF" scheme="https://www.chaguake.com/tags/SDF/"/>
    
  </entry>
  
  <entry>
    <title>smallpt：经典光线追踪实现（C++）</title>
    <link href="https://www.chaguake.com/2021/09/03/smallpt-classic-ray-tracing-for-c-plus/"/>
    <id>https://www.chaguake.com/2021/09/03/smallpt-classic-ray-tracing-for-c-plus/</id>
    <published>2021-09-03T07:09:07.000Z</published>
    <updated>2021-09-07T08:07:36.114Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="http://www.kevinbeason.com/smallpt/">http://www.kevinbeason.com/smallpt/</a></p><p>翻译：<a href="https://samuel92.blog.csdn.net/article/details/108189198">https://samuel92.blog.csdn.net/article/details/108189198</a></p><p>文章：<a href="https://zhuanlan.zhihu.com/p/148759248">https://zhuanlan.zhihu.com/p/148759248</a></p><p align="center">    <img src="http://www.kevinbeason.com/smallpt/result_25k.png" width="95%">    <br />    <small> global illumination renderer </small></p><p>smallpt 是一个全局光照渲染器，基于无偏蒙特卡洛路径追踪算法。</p><blockquote><p>首先，蒙特卡洛路径追踪算法知识可看GAMES101教程的第16节。然后，无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。</p></blockquote><h2 id="一、特征"><a href="#一、特征" class="headerlink" title="一、特征"></a>一、特征</h2><ul><li>基于无偏蒙特卡罗路径跟踪的全局照明。</li><li>多线程使用OpenMP。</li><li>漫反射的软阴影。</li><li>镜面反射、漫反射和玻璃BRDF。</li><li>通过重要性采样的超采样（2x2子像素）来抗锯齿。</li><li>射线球交点。</li><li>场景使用改进的Cornell box。</li><li>半球漫反射的余弦重要性采样。</li><li>俄罗斯轮盘赌实现路径终止。</li><li>俄罗斯轮盘赌和分割，用于选择玻璃BRDF的反射和（或）折射。</li><li>显式灯光采样和非分支光线树。</li><li>CUDA和BSGP的端口具有交互式显示和场景编辑功能。</li></ul><h2 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;   &#x2F;&#x2F; smallpt, a Path Tracer by Kevin Beason, 2008</span><br><span class="line">#include &lt;stdlib.h&gt; &#x2F;&#x2F; Make : g++ -O3 -fopenmp smallpt.cpp -o smallpt</span><br><span class="line">#include &lt;stdio.h&gt;  &#x2F;&#x2F;        Remove &quot;-fopenmp&quot; for g++ version &lt; 4.2</span><br><span class="line">struct Vec &#123;        &#x2F;&#x2F; Usage: time .&#x2F;smallpt 5000 &amp;&amp; xv image.ppm</span><br><span class="line">  double x, y, z;                  &#x2F;&#x2F; position, also color (r,g,b)</span><br><span class="line">  Vec(double x_&#x3D;0, double y_&#x3D;0, double z_&#x3D;0)&#123; x&#x3D;x_; y&#x3D;y_; z&#x3D;z_; &#125;</span><br><span class="line">  Vec operator+(const Vec &amp;b) const &#123; return Vec(x+b.x,y+b.y,z+b.z); &#125;</span><br><span class="line">  Vec operator-(const Vec &amp;b) const &#123; return Vec(x-b.x,y-b.y,z-b.z); &#125;</span><br><span class="line">  Vec operator*(double b) const &#123; return Vec(x*b,y*b,z*b); &#125;</span><br><span class="line">  Vec mult(const Vec &amp;b) const &#123; return Vec(x*b.x,y*b.y,z*b.z); &#125;</span><br><span class="line">  Vec&amp; norm()&#123; return *this &#x3D; *this * (1&#x2F;sqrt(x*x+y*y+z*z)); &#125;</span><br><span class="line">  double dot(const Vec &amp;b) const &#123; return x*b.x+y*b.y+z*b.z; &#125; &#x2F;&#x2F; cross:</span><br><span class="line">  Vec operator%(Vec&amp;b)&#123;return Vec(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Ray &#123; Vec o, d; Ray(Vec o_, Vec d_) : o(o_), d(d_) &#123;&#125; &#125;;</span><br><span class="line">enum Refl_t &#123; DIFF, SPEC, REFR &#125;;  &#x2F;&#x2F; material types, used in radiance()</span><br><span class="line">struct Sphere &#123;</span><br><span class="line">  double rad;       &#x2F;&#x2F; radius</span><br><span class="line">  Vec p, e, c;      &#x2F;&#x2F; position, emission, color</span><br><span class="line">  Refl_t refl;      &#x2F;&#x2F; reflection type (DIFFuse, SPECular, REFRactive)</span><br><span class="line">  Sphere(double rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_):</span><br><span class="line">    rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125;</span><br><span class="line">  double intersect(const Ray &amp;r) const &#123; &#x2F;&#x2F; returns distance, 0 if nohit</span><br><span class="line">    Vec op &#x3D; p-r.o; &#x2F;&#x2F; Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 &#x3D; 0</span><br><span class="line">    double t, eps&#x3D;1e-4, b&#x3D;op.dot(r.d), det&#x3D;b*b-op.dot(op)+rad*rad;</span><br><span class="line">    if (det&lt;0) return 0; else det&#x3D;sqrt(det);</span><br><span class="line">    return (t&#x3D;b-det)&gt;eps ? t : ((t&#x3D;b+det)&gt;eps ? t : 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Sphere spheres[] &#x3D; &#123;&#x2F;&#x2F;Scene: radius, position, emission, color, material</span><br><span class="line">  Sphere(1e5, Vec( 1e5+1,40.8,81.6), Vec(),Vec(.75,.25,.25),DIFF),&#x2F;&#x2F;Left</span><br><span class="line">  Sphere(1e5, Vec(-1e5+99,40.8,81.6),Vec(),Vec(.25,.25,.75),DIFF),&#x2F;&#x2F;Rght</span><br><span class="line">  Sphere(1e5, Vec(50,40.8, 1e5),     Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Back</span><br><span class="line">  Sphere(1e5, Vec(50,40.8,-1e5+170), Vec(),Vec(),           DIFF),&#x2F;&#x2F;Frnt</span><br><span class="line">  Sphere(1e5, Vec(50, 1e5, 81.6),    Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Botm</span><br><span class="line">  Sphere(1e5, Vec(50,-1e5+81.6,81.6),Vec(),Vec(.75,.75,.75),DIFF),&#x2F;&#x2F;Top</span><br><span class="line">  Sphere(16.5,Vec(27,16.5,47),       Vec(),Vec(1,1,1)*.999, SPEC),&#x2F;&#x2F;Mirr</span><br><span class="line">  Sphere(16.5,Vec(73,16.5,78),       Vec(),Vec(1,1,1)*.999, REFR),&#x2F;&#x2F;Glas</span><br><span class="line">  Sphere(600, Vec(50,681.6-.27,81.6),Vec(12,12,12),  Vec(), DIFF) &#x2F;&#x2F;Lite</span><br><span class="line">&#125;;</span><br><span class="line">inline double clamp(double x)&#123; return x&lt;0 ? 0 : x&gt;1 ? 1 : x; &#125;</span><br><span class="line">inline int toInt(double x)&#123; return int(pow(clamp(x),1&#x2F;2.2)*255+.5); &#125;</span><br><span class="line">inline bool intersect(const Ray &amp;r, double &amp;t, int &amp;id)&#123;</span><br><span class="line">  double n&#x3D;sizeof(spheres)&#x2F;sizeof(Sphere), d, inf&#x3D;t&#x3D;1e20;</span><br><span class="line">  for(int i&#x3D;int(n);i--;) if((d&#x3D;spheres[i].intersect(r))&amp;&amp;d&lt;t)&#123;t&#x3D;d;id&#x3D;i;&#125;</span><br><span class="line">  return t&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line">Vec radiance(const Ray &amp;r, int depth, unsigned short *Xi)&#123;</span><br><span class="line">  double t;                               &#x2F;&#x2F; distance to intersection</span><br><span class="line">  int id&#x3D;0;                               &#x2F;&#x2F; id of intersected object</span><br><span class="line">  if (!intersect(r, t, id)) return Vec(); &#x2F;&#x2F; if miss, return black</span><br><span class="line">  const Sphere &amp;obj &#x3D; spheres[id];        &#x2F;&#x2F; the hit object</span><br><span class="line">  Vec x&#x3D;r.o+r.d*t, n&#x3D;(x-obj.p).norm(), nl&#x3D;n.dot(r.d)&lt;0?n:n*-1, f&#x3D;obj.c;</span><br><span class="line">  double p &#x3D; f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; &#x2F;&#x2F; max refl</span><br><span class="line">  if (++depth&gt;5) if (erand48(Xi)&lt;p) f&#x3D;f*(1&#x2F;p); else return obj.e; &#x2F;&#x2F;R.R.</span><br><span class="line">  if (obj.refl &#x3D;&#x3D; DIFF)&#123;                  &#x2F;&#x2F; Ideal DIFFUSE reflection</span><br><span class="line">    double r1&#x3D;2*M_PI*erand48(Xi), r2&#x3D;erand48(Xi), r2s&#x3D;sqrt(r2);</span><br><span class="line">    Vec w&#x3D;nl, u&#x3D;((fabs(w.x)&gt;.1?Vec(0,1):Vec(1))%w).norm(), v&#x3D;w%u;</span><br><span class="line">    Vec d &#x3D; (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1-r2)).norm();</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,d),depth,Xi));</span><br><span class="line">  &#125; else if (obj.refl &#x3D;&#x3D; SPEC)            &#x2F;&#x2F; Ideal SPECULAR reflection</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,r.d-n*2*n.dot(r.d)),depth,Xi));</span><br><span class="line">  Ray reflRay(x, r.d-n*2*n.dot(r.d));     &#x2F;&#x2F; Ideal dielectric REFRACTION</span><br><span class="line">  bool into &#x3D; n.dot(nl)&gt;0;                &#x2F;&#x2F; Ray from outside going in?</span><br><span class="line">  double nc&#x3D;1, nt&#x3D;1.5, nnt&#x3D;into?nc&#x2F;nt:nt&#x2F;nc, ddn&#x3D;r.d.dot(nl), cos2t;</span><br><span class="line">  if ((cos2t&#x3D;1-nnt*nnt*(1-ddn*ddn))&lt;0)    &#x2F;&#x2F; Total internal reflection</span><br><span class="line">    return obj.e + f.mult(radiance(reflRay,depth,Xi));</span><br><span class="line">  Vec tdir &#x3D; (r.d*nnt - n*((into?1:-1)*(ddn*nnt+sqrt(cos2t)))).norm();</span><br><span class="line">  double a&#x3D;nt-nc, b&#x3D;nt+nc, R0&#x3D;a*a&#x2F;(b*b), c &#x3D; 1-(into?-ddn:tdir.dot(n));</span><br><span class="line">  double Re&#x3D;R0+(1-R0)*c*c*c*c*c,Tr&#x3D;1-Re,P&#x3D;.25+.5*Re,RP&#x3D;Re&#x2F;P,TP&#x3D;Tr&#x2F;(1-P);</span><br><span class="line">  return obj.e + f.mult(depth&gt;2 ? (erand48(Xi)&lt;P ?   &#x2F;&#x2F; Russian roulette</span><br><span class="line">    radiance(reflRay,depth,Xi)*RP:radiance(Ray(x,tdir),depth,Xi)*TP) :</span><br><span class="line">    radiance(reflRay,depth,Xi)*Re+radiance(Ray(x,tdir),depth,Xi)*Tr);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">  int w&#x3D;1024, h&#x3D;768, samps &#x3D; argc&#x3D;&#x3D;2 ? atoi(argv[1])&#x2F;4 : 1; &#x2F;&#x2F; # samples</span><br><span class="line">  Ray cam(Vec(50,52,295.6), Vec(0,-0.042612,-1).norm()); &#x2F;&#x2F; cam pos, dir</span><br><span class="line">  Vec cx&#x3D;Vec(w*.5135&#x2F;h), cy&#x3D;(cx%cam.d).norm()*.5135, r, *c&#x3D;new Vec[w*h];</span><br><span class="line">#pragma omp parallel for schedule(dynamic, 1) private(r)       &#x2F;&#x2F; OpenMP</span><br><span class="line">  for (int y&#x3D;0; y&lt;h; y++)&#123;                       &#x2F;&#x2F; Loop over image rows</span><br><span class="line">    fprintf(stderr,&quot;\rRendering (%d spp) %5.2f%%&quot;,samps*4,100.*y&#x2F;(h-1));</span><br><span class="line">    for (unsigned short x&#x3D;0, Xi[3]&#x3D;&#123;0,0,y*y*y&#125;; x&lt;w; x++)   &#x2F;&#x2F; Loop cols</span><br><span class="line">      for (int sy&#x3D;0, i&#x3D;(h-y-1)*w+x; sy&lt;2; sy++)     &#x2F;&#x2F; 2x2 subpixel rows</span><br><span class="line">        for (int sx&#x3D;0; sx&lt;2; sx++, r&#x3D;Vec())&#123;        &#x2F;&#x2F; 2x2 subpixel cols</span><br><span class="line">          for (int s&#x3D;0; s&lt;samps; s++)&#123;</span><br><span class="line">            double r1&#x3D;2*erand48(Xi), dx&#x3D;r1&lt;1 ? sqrt(r1)-1: 1-sqrt(2-r1);</span><br><span class="line">            double r2&#x3D;2*erand48(Xi), dy&#x3D;r2&lt;1 ? sqrt(r2)-1: 1-sqrt(2-r2);</span><br><span class="line">            Vec d &#x3D; cx*( ( (sx+.5 + dx)&#x2F;2 + x)&#x2F;w - .5) +</span><br><span class="line">                    cy*( ( (sy+.5 + dy)&#x2F;2 + y)&#x2F;h - .5) + cam.d;</span><br><span class="line">            r &#x3D; r + radiance(Ray(cam.o+d*140,d.norm()),0,Xi)*(1.&#x2F;samps);</span><br><span class="line">          &#125; &#x2F;&#x2F; Camera rays are pushed ^^^^^ forward to start in interior</span><br><span class="line">          c[i] &#x3D; c[i] + Vec(clamp(r.x),clamp(r.y),clamp(r.z))*.25;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  FILE *f &#x3D; fopen(&quot;image.ppm&quot;, &quot;w&quot;);         &#x2F;&#x2F; Write image to PPM file.</span><br><span class="line">  fprintf(f, &quot;P3\n%d %d\n%d\n&quot;, w, h, 255);</span><br><span class="line">  for (int i&#x3D;0; i&lt;w*h; i++)</span><br><span class="line">    fprintf(f,&quot;%d %d %d &quot;, toInt(c[i].x), toInt(c[i].y), toInt(c[i].z));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、用法"><a href="#三、用法" class="headerlink" title="三、用法"></a>三、用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -O3 -fopenmp smallpt.cpp -o smallpt </span><br><span class="line">time .&#x2F;smallpt 5000</span><br><span class="line">display image.ppm</span><br></pre></td></tr></table></figure><h2 id="四、细节"><a href="#四、细节" class="headerlink" title="四、细节"></a>四、细节</h2><p align="center">    <img src="https://z3.ax1x.com/2021/08/06/fnD54K.png" width="95%">    <br />    <small> 2.4 GHz 两核四线程，每个像素的不同采样数（spp）的计时和结果图像  </small></p><p>通过使用数值积分求解渲染方程来计算图像。具体的算法是蒙特卡罗路径跟踪与俄罗斯轮盘赌路径终止。由于尺寸限制和简单性，不使用显式灯光采样，也不使用任何光线相交加速数据结构。</p><p><code>#pragma omp parallel for schedule(dynamic, 1) private(r)</code> 语句，使用OpenMP动态地将映像行分配给不同的线程，每个处理器或内核有一个线程。</p><p>变量 <code>Xi</code> 用于存储随机数生成器  <code>erand48</code> 的状态，使用行数来做随机值种子，这样子序列就是跟行数有关，与并行计算的先后顺序等无关。</p><p>抗锯齿是使用超级采样完成的，超级采样将删除除灯光周围以外的所有锯齿。通过使用2x2子像素进行处理，这些子像素先被clamp操作，然后求平均。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="一、Vec-类"><a href="#一、Vec-类" class="headerlink" title="一、Vec 类"></a>一、Vec 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义</span><br><span class="line">struct Vec &#123;        &#x2F;&#x2F; Usage: time .&#x2F;smallpt 5000 &amp;&amp; xv image.ppm</span><br><span class="line">  double x, y, z;                  &#x2F;&#x2F; position, also color (r,g,b)</span><br><span class="line">  Vec(double x_&#x3D;0, double y_&#x3D;0, double z_&#x3D;0)&#123; x&#x3D;x_; y&#x3D;y_; z&#x3D;z_; &#125;</span><br><span class="line">  Vec operator+(const Vec &amp;b) const &#123; return Vec(x+b.x,y+b.y,z+b.z); &#125;</span><br><span class="line">  Vec operator-(const Vec &amp;b) const &#123; return Vec(x-b.x,y-b.y,z-b.z); &#125;</span><br><span class="line">  Vec operator*(double b) const &#123; return Vec(x*b,y*b,z*b); &#125;</span><br><span class="line">  Vec mult(const Vec &amp;b) const &#123; return Vec(x*b.x,y*b.y,z*b.z); &#125;</span><br><span class="line">  Vec&amp; norm()&#123; return *this &#x3D; *this * (1&#x2F;sqrt(x*x+y*y+z*z)); &#125;</span><br><span class="line">  double dot(const Vec &amp;b) const &#123; return x*b.x+y*b.y+z*b.z; &#125; &#x2F;&#x2F; cross:</span><br><span class="line">  Vec operator%(Vec&amp;b)&#123;return Vec(y*b.z-z*b.y,z*b.x-x*b.z,x*b.y-y*b.x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应用</span><br><span class="line">Vec cx&#x3D;Vec(w*.5135&#x2F;h), cy&#x3D;(cx%cam.d).norm()*.5135, r, *c&#x3D;new Vec[w*h];</span><br></pre></td></tr></table></figure><p>Vec 类实现了向量的运算。</p><p>成员 norm 函数的计算公式其实是将三个分量分别乘以比例系数，从而达到归一化操作。</p><p>成员 dot 函数对应的是向量的点乘运算：</p><script type="math/tex; mode=display">\vec{a} \cdot \vec{b} = \begin{pmatrix}x_{a} \\ y_{a} \\ z_{a}\end{pmatrix}\cdot\begin{pmatrix}x_{b} \\ y_{b} \\ z_{b}\end{pmatrix}=x_{a}x_{b} + y_{a}y_{b} + z_{a}z_{b}</script><p>% 操作运算符对应的是向量的叉乘运算：</p><script type="math/tex; mode=display">\vec{a} \times \vec{b} = \begin{pmatrix}x_{a} \\y_{a} \\z_{a} \end{pmatrix}\times\begin{pmatrix}x_{b} \\y_{b} \\z_{b} \end{pmatrix}=\begin{pmatrix}y_{a}z_{b} - y_{b}z_{a} \\z_{a}x_{b} - x_{a}z_{b} \\x_{a}y_{b} - y_{a}x_{b}\end{pmatrix}</script><script type="math/tex; mode=display">\vec{a} \times \vec{b} = A^{*}b = \underset{\text{dual matrix of vector a}}{\begin{pmatrix}0 & -z_{a} & y_{a} \\z_{a} & 0 & -x_{a} \\-y_{a} & x_{a} & 0\end{pmatrix} }\begin{pmatrix}x_{b} \\y_{b} \\z_{b} \end{pmatrix}</script><p>应用上，变量 cx 为摄像机在 x 轴上的方向分量（右轴），同理变量 cy 是摄像机在 y 轴上的方向分量（上轴）。0.5135是视场系数，控制摄像机看到的范围，变量 cx 通过对输出图像的分辨率比例求得，而变量 cy 是通过摄像机方向和变量 cx 叉乘得到（见：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">LearnOpenGL-摄像机</a>）。</p><p>变量 r 是当前像素点的光照辐射值，通过对子像素点计算累加求得。</p><p>变量 c 是输出图像的数据数组，记录每个像素点的颜色值。</p><h2 id="二、main-函数的5个-for-循环"><a href="#二、main-函数的5个-for-循环" class="headerlink" title="二、main 函数的5个 for 循环"></a>二、main 函数的5个 for 循环</h2><ol><li>第一个 for 循环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int y&#x3D;0; y&lt;h; y++)</span><br></pre></td></tr></table></figure><p>遍历输出像素分辨率的每一行。</p><ol><li>第二个 for 循环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (unsigned short x&#x3D;0, Xi[3]&#x3D;&#123;0,0,y*y*y&#125;; x&lt;w; x++)</span><br></pre></td></tr></table></figure><p>遍历每一行分辨率的每一个像素（每一列）。</p><ol><li>第三个 for 循环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int sy&#x3D;0, i&#x3D;(h-y-1)*w+x; sy&lt;2; sy++)</span><br></pre></td></tr></table></figure><p>从右下角开始，由于采用的是2x2超级采样，所以每个像素分为四个子像素。这一层对应每个像素。</p><ol><li>第四个 for 循环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int sx&#x3D;0; sx&lt;2; sx++, r&#x3D;Vec())</span><br></pre></td></tr></table></figure><p>由于采用的是2x2超级采样，所以每个像素分为四个子像素。这一层对应每个子像素。</p><p>这一层主要做两件事情，多次采样以及将每一个子像素计算结果累加到该像素点的数值上。</p><ol><li>第五个 for 循环</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int s&#x3D;0; s&lt;samps; s++)</span><br></pre></td></tr></table></figure><p>每个子像素采样 samps 次。</p><p>在该循环中，首先采用 Tent Filter 实现抗锯齿，然后计算该子像素点的光线方向 d，最后求得该子像素点的辐射值，并累加到像素点的辐射值变量 r 上。</p><h2 id="三、Tent-Filter"><a href="#三、Tent-Filter" class="headerlink" title="三、Tent Filter"></a>三、Tent Filter</h2><p>先看 Tent Filter 的函数定义：</p><script type="math/tex; mode=display">f_{tent}(x) = \begin{cases}1- \vert x \vert , &  \vert x \vert < 1 \\[2ex]0,  & \text{otherwise}\end{cases}</script><p>低通滤波，只输出 x 的绝对值小于时的结果，再看代码的实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double r1&#x3D;2*erand48(Xi), dx&#x3D;r1&lt;1 ? sqrt(r1)-1: 1-sqrt(2-r1);</span><br><span class="line">double r2&#x3D;2*erand48(Xi), dy&#x3D;r2&lt;1 ? sqrt(r2)-1: 1-sqrt(2-r2);</span><br></pre></td></tr></table></figure><p>变量 r1 和 r2 的取值在 $[0,2)$，然后变量 dx 和 dy 的取值根据 变量 r1 和 r2 的取值不同有着不同的取值，但总体范围在 $[-1,1]$：</p><script type="math/tex; mode=display">d(r) =  \begin{cases}\sqrt{r} - 1, &  0 \leq r < 1 \\[2ex]1- \sqrt{2 - r},  &  1 \leq r < 2\end{cases}</script><p>可以看到与原生 Tent Filter 的取值范围不同，先看下怎么使用结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vec d &#x3D; cx*( ( (sx+.5 + dx )&#x2F;2 + x)&#x2F;w - .5) +</span><br><span class="line">                    cy*( ( (sy+.5 + dy )&#x2F;2 + y)&#x2F;h - .5) + cam.d;</span><br></pre></td></tr></table></figure><p>子像素的光线方向 d 与摄像机在 xy 轴上的方向分量、当前子像素序号以及摄像机的方向有关。<code>sx+.5</code> 或 <code>sy+.5</code> 是将采样点移动到子像素的中心点，然后再加上 Tent Filter 值。</p><p>最终，<code>cx*( ( (sx+.5 + dx )/2 + x)/w - .5)</code> 或 <code>cy*( ( (sy+.5 + dy )/2 + y)/h - .5)</code> 对应分量的取值范围在 $[-0.5,0.5)$。也就是在当前像素点的面积内做偏移。</p><p><strong>上面解释的有问题，得看下面截图：</strong></p><p align="center">    <img src="https://z3.ax1x.com/2021/08/09/f81oMd.png" width="95%">    <br />    <small>  </small></p><h2 id="四、OpenMP"><a href="#四、OpenMP" class="headerlink" title="四、OpenMP"></a>四、OpenMP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel for schedule(dynamic, 1) private(r)</span><br></pre></td></tr></table></figure><p>实现并行计算。</p><h2 id="五、Sphere-类"><a href="#五、Sphere-类" class="headerlink" title="五、Sphere 类"></a>五、Sphere 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Sphere &#123;</span><br><span class="line">  double rad;       &#x2F;&#x2F; radius</span><br><span class="line">  Vec p, e, c;      &#x2F;&#x2F; position, emission, color</span><br><span class="line">  Refl_t refl;      &#x2F;&#x2F; reflection type (DIFFuse, SPECular, REFRactive)</span><br><span class="line">  Sphere(double rad_, Vec p_, Vec e_, Vec c_, Refl_t refl_):</span><br><span class="line">    rad(rad_), p(p_), e(e_), c(c_), refl(refl_) &#123;&#125;</span><br><span class="line">  double intersect(const Ray &amp;r) const &#123; &#x2F;&#x2F; returns distance, 0 if nohit</span><br><span class="line">    Vec op &#x3D; p-r.o; &#x2F;&#x2F; Solve t^2*d.d + 2*t*(o-p).d + (o-p).(o-p)-R^2 &#x3D; 0</span><br><span class="line">    double t, eps&#x3D;1e-4, b&#x3D;op.dot(r.d), det&#x3D;b*b-op.dot(op)+rad*rad;</span><br><span class="line">    if (det&lt;0) return 0; else det&#x3D;sqrt(det);</span><br><span class="line">    return (t&#x3D;b-det)&gt;eps ? t : ((t&#x3D;b+det)&gt;eps ? t : 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义场景各种物体的球体类。</p><p>成员变量 rad 定义球体半径，变量 p 定义球心位置，变量 e 定义物体自发光属性，变量 c 定义物体颜色，结构体变量 refl 定义物体散射性质（漫反射、镜面反射、折射）。</p><p>成员 intersect 函数判断物体与光线是否相交，相交则返回交点与光线原点的距离。而其判断方法为<a href="https://zhuanlan.zhihu.com/p/136763389">参数方程法</a>。</p><h2 id="五、radiance-函数"><a href="#五、radiance-函数" class="headerlink" title="五、radiance 函数"></a>五、radiance 函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec radiance(const Ray &amp;r, int depth, unsigned short *Xi)</span><br></pre></td></tr></table></figure><p>radiance 函数接受三个参数，第一个是光线，第二个是光线追踪的深度，第三个是随机值种子。</p><p>在 main 函数中调用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radiance(Ray(cam.o+d*140,d.norm()),0,Xi)</span><br></pre></td></tr></table></figure><p>因为重新计算了光线的方向，所以传入初始的光线位置和方向也需要对应改变。</p><ol><li>判断是否与物体相交，否则直接返回</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double t;                               &#x2F;&#x2F; distance to intersection</span><br><span class="line">int id&#x3D;0;                               &#x2F;&#x2F; id of intersected object</span><br><span class="line">if (!intersect(r, t, id)) return Vec(); &#x2F;&#x2F; if miss, return black</span><br></pre></td></tr></table></figure><p>全局 intersect 函数遍历每一个球体物体，然后判断光线是否与它们相交，并且返回最近的一个物体的交点距离。</p><ol><li>计算/定义一些相交之后的信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Sphere &amp;obj &#x3D; spheres[id];        &#x2F;&#x2F; the hit object</span><br><span class="line">Vec x&#x3D;r.o+r.d*t, n&#x3D;(x-obj.p).norm(), nl&#x3D;n.dot(r.d)&lt;0?n:n*-1, f&#x3D;obj.c;</span><br></pre></td></tr></table></figure><p>变量 obj 为本次光线路径追踪相交的物体。</p><p>变量 x 是通过光线函数表达式计算得到的交点坐标。</p><p>变量 n 是物体在交点上的表面法线。</p><p>变量 nl 是朝向法线（oriented normal），通过计算光线方向与物体交点表面法线之间的夹角余弦值，判断其正负来决定光线是打在物体表面还是从物体内部穿出来。</p><p>变量 f 为物体颜色。</p><ol><li>俄罗斯轮盘赌，决定光线追踪是否结束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double p &#x3D; f.x&gt;f.y &amp;&amp; f.x&gt;f.z ? f.x : f.y&gt;f.z ? f.y : f.z; &#x2F;&#x2F; max refl</span><br><span class="line">if (++depth&gt;5) if (erand48(Xi)&lt;p) f&#x3D;f*(1&#x2F;p); else return obj.e; &#x2F;&#x2F;R.R.</span><br></pre></td></tr></table></figure><p>变量 p 是取当前物体颜色三个分量中的最大值。</p><p>只有在深度大于5之后，才进行俄罗斯轮盘赌。</p><ol><li>计算漫反射</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (obj.refl &#x3D;&#x3D; DIFF)&#123;                  &#x2F;&#x2F; Ideal DIFFUSE reflection</span><br><span class="line">    double r1&#x3D;2*M_PI*erand48(Xi), r2&#x3D;erand48(Xi), r2s&#x3D;sqrt(r2);</span><br><span class="line">    Vec w&#x3D;nl, u&#x3D;((fabs(w.x)&gt;.1?Vec(0,1):Vec(1))%w).norm(), v&#x3D;w%u;</span><br><span class="line">    Vec d &#x3D; (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1-r2)).norm();</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,d),depth,Xi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 r1 是随机抽样半球散射光线中一条的角度，变量 r2 和 r2s 是一个距离中心点的随机长度。</p><p>变量 w 和 u 和 v 则分别是局部坐标系的三个轴。变量 w 取朝向法线的方向。变量 u 根据变量 w 的 x 轴分量来决定是以哪个垂直轴来做叉乘变量 w ，这样子使得叉乘结果更好（感觉没啥用）。变量 v 则是另外两个轴叉乘得到。</p><p>变量 d 是求出随机抽样半球散射光线中一条光线的方向。由于局部坐标系是通过世界坐标系的朝向法线建立起来的，那么分别求出光线在各个方向的分量之后，合起来的结果便是该光线在世界坐标系上的坐标。</p><p><code>w*sqrt(1-r2)</code> 中的 <code>1-r2</code> 这个随机值是因为 z 轴跟 xy 轴不同，随着角度增大， z 轴的值是减少的。</p><p>这篇<a href="https://zhuanlan.zhihu.com/p/148759248">文章</a>解释了变量 r2s 的定义。</p><p>使用了概率密度函数的概念。</p><p>返回结果则是继续递归。</p><ol><li>计算镜面反射</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (obj.refl &#x3D;&#x3D; SPEC)            &#x2F;&#x2F; Ideal SPECULAR reflection</span><br><span class="line">    return obj.e + f.mult(radiance(Ray(x,r.d-n*2*n.dot(r.d)),depth,Xi));</span><br></pre></td></tr></table></figure><p>镜面反射就一句代码。</p><p>与漫反射不同之处在于镜面反射之后的光线方向由 <code>r.d-n*2*n.dot(r.d)</code> 求得。</p><p align="center">    <img src="https://z3.ax1x.com/2021/08/09/f85BfP.png" width="95%">    <br />    <small>  </small></p><ol><li>计算折射（同样包含反射）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ray reflRay(x, r.d-n*2*n.dot(r.d));     &#x2F;&#x2F; Ideal dielectric REFRACTION</span><br><span class="line">bool into &#x3D; n.dot(nl)&gt;0;                &#x2F;&#x2F; Ray from outside going in?</span><br><span class="line">double nc&#x3D;1, nt&#x3D;1.5, nnt&#x3D;into?nc&#x2F;nt:nt&#x2F;nc, ddn&#x3D;r.d.dot(nl), cos2t;</span><br><span class="line">if ((cos2t&#x3D;1-nnt*nnt*(1-ddn*ddn))&lt;0)    &#x2F;&#x2F; Total internal reflection</span><br><span class="line">    return obj.e + f.mult(radiance(reflRay,depth,Xi));</span><br><span class="line">Vec tdir &#x3D; (r.d*nnt - n*((into?1:-1)*(ddn*nnt+sqrt(cos2t)))).norm();</span><br><span class="line">double a&#x3D;nt-nc, b&#x3D;nt+nc, R0&#x3D;a*a&#x2F;(b*b), c &#x3D; 1-(into?-ddn:tdir.dot(n));</span><br><span class="line">double Re&#x3D;R0+(1-R0)*c*c*c*c*c,Tr&#x3D;1-Re,P&#x3D;.25+.5*Re,RP&#x3D;Re&#x2F;P,TP&#x3D;Tr&#x2F;(1-P);</span><br><span class="line">return obj.e + f.mult(depth&gt;2 ? (erand48(Xi)&lt;P ?   &#x2F;&#x2F; Russian roulette</span><br><span class="line">    radiance(reflRay,depth,Xi)*RP:radiance(Ray(x,tdir),depth,Xi)*TP) :</span><br><span class="line">    radiance(reflRay,depth,Xi)*Re+radiance(Ray(x,tdir),depth,Xi)*Tr);</span><br></pre></td></tr></table></figure><p>玻璃材质的物体既有折射也有反射，根据全反射原理，有可能会出现完全反射的情况。所以，先进行反射计算，然后再进行折射计算。</p><p>变量 reflRay 为反射方向光线。</p><p>变量 into 判定光线是从外部进入物体，还是从物体内部照射出来。</p><p>变量 nc 为空气介质密度，变量 nt 为物体介质密度。变量 nnt 则为折射率，变量 ddn 为光线方向与朝向法线角度的余弦值。</p><p>表达式 <code>(cos2t=1-nnt*nnt*(1-ddn*ddn))&lt;0</code> 判断是否全反射。如果满足全反射，则不用计算折射，直接返回反射递归调用。</p><p>接下来计算折射部分。</p><p>变量 tdir 为 折射光方向。</p><p align="center">    <img src="https://img-blog.csdnimg.cn/20200824003230970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2cxMWQxMTE=,size_16,color_FFFFFF,t_70#pic_center" width="95%">    <br />    <small>  </small></p><p>接下来使用菲涅尔项来计算校准之后的折射光的反射比。</p><p>变量 Re 为折射光的菲涅尔项。</p><p>最后，再进行一次俄罗斯轮盘赌，变量 RP 是产生菲涅尔项效果的概率，变量 TP 是不产生菲涅尔项效果的概率。当深度大于2时，启动俄罗斯轮盘赌，判断为真则启用反射计算（叠加菲涅尔项），判断为假则进行折射计算（叠加对立比例）。当深度小于2时，则是反射和折射两者的叠加效果计算（当然没有俄罗斯轮盘赌）。</p><ol><li>其他</li></ol><p>可以看到，在每个 return 语句上，都是当前相交点的物体的辐射值加上物体颜色乘以下一次光线追踪返回结果的值。这样子一直递归到最后一层，这样子反递归的时候，就会将源头的结果叠加回来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;http://www.kevinbeason.com/smallpt/&quot;&gt;http://www.kevinbeason.com/smallpt/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译：&lt;a href=&quot;https://samuel92.blog.csdn.ne</summary>
      
    
    
    
    <category term="图形学" scheme="https://www.chaguake.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Ray Tracing" scheme="https://www.chaguake.com/tags/Ray-Tracing/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（十）——深度测试</title>
    <link href="https://www.chaguake.com/2021/05/20/OpenGL-introduction-10/"/>
    <id>https://www.chaguake.com/2021/05/20/OpenGL-introduction-10/</id>
    <published>2021-05-20T03:27:17.000Z</published>
    <updated>2021-05-20T07:26:21.599Z</updated>
    
    <content type="html"><![CDATA[<p>渲染管线的过程在<a href="https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/">文章</a>中有提过，顶点数据通过<code>glBufferData</code>等一系列函数传递进CPU，然后经过顶点着色器、图元装配、几何着色器、光栅化、片段着色器和最后的测试与混合，最后输出到屏幕。</p><p>本节所讲的深度测试位于片段着色器后面的测试与混合阶段，具体可看下图：</p><p><img src="https://chenanbao.github.io/img/pip.001.jpg" alt=""></p><h1 id="深度测试（Depth-Testing）"><a href="#深度测试（Depth-Testing）" class="headerlink" title="深度测试（Depth Testing）"></a>深度测试（Depth Testing）</h1><p>深度缓冲用于防止被阻挡的面渲染到其他面的前面，它在每个片段中存储了信息，由窗口系统自动创建，以16、24或32位float的类型存储它的深度值（默认是24位）。</p><p>深度测试默认是禁用的，开启使用函数<code>glEnable</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glClear(GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><p>在某些情况下，可能不需要更新深度缓冲，这意味着要禁用深度缓冲的写入，那么，可以设置深度缓冲的深度掩码（Depth Mask）为FALSE实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDepthMask(GL_FALSE);</span><br></pre></td></tr></table></figure><p>OpenGL使用深度函数<code>glDepthFunc</code>，修改深度测试的比较运算符，来控制片段的丢弃方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDepthFunc(GL_LESS);</span><br></pre></td></tr></table></figure><p>比较运算符有以下这些：</p><div class="table-container"><table><thead><tr><th style="text-align:center">比较运算符号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">GL_ALWAYS</td><td style="text-align:center">永远通过深度测试</td></tr><tr><td style="text-align:center">GL_NEVER</td><td style="text-align:center">永远不通过深度测试</td></tr><tr><td style="text-align:center">GL_LESS</td><td style="text-align:center">在片段深度值小于缓冲的深度值时通过测试</td></tr><tr><td style="text-align:center">GL_EQUAL</td><td style="text-align:center">在片段深度值等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:center">GL_LEQUAL</td><td style="text-align:center">在片段深度值小于等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:center">GL_GREATER</td><td style="text-align:center">在片段深度值大于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:center">GL_NOTEQUAL</td><td style="text-align:center">在片段深度值不等于缓冲区的深度值时通过测试</td></tr><tr><td style="text-align:center">GL_GEQUAL</td><td style="text-align:center">在片段深度值大于等于缓冲区的深度值时通过测试</td></tr></tbody></table></div><p>默认情况下使用的深度比较符号是<code>GL_LESS</code>，输出效果如下：</p><p><img src="https://learnopengl-cn.github.io/img/04/01/depth_testing_func_less.png" alt=""></p><p>使用<code>GL_ALWAYS</code>的输出效果如下：</p><p><img src="https://learnopengl-cn.github.io/img/04/01/depth_testing_func_always.png" alt=""></p><p>可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/4.advanced_opengl/1.1.depth_testing/depth_testing.cpp">这里</a>找到例子源码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;渲染管线的过程在&lt;a href=&quot;https://www.chaguake.com/2021/03/31/OpenGL-introduction-03/&quot;&gt;文章&lt;/a&gt;中有提过，顶点数据通过&lt;code&gt;glBufferData&lt;/code&gt;等一系列函数传递进CPU，然后经过</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（九）——模型加载</title>
    <link href="https://www.chaguake.com/2021/05/20/OpenGL-introduction-09/"/>
    <id>https://www.chaguake.com/2021/05/20/OpenGL-introduction-09/</id>
    <published>2021-05-20T03:22:19.000Z</published>
    <updated>2021-05-31T02:18:44.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型加载库Assimp"><a href="#模型加载库Assimp" class="headerlink" title="模型加载库Assimp"></a>模型加载库Assimp</h1><p><a href="http://assimp.org/">Assimp</a>是一个非常流行的模型导入库，它是以场景为主导的模型：</p><p><img src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt=""></p><h1 id="网格（Mesh）"><a href="#网格（Mesh）" class="headerlink" title="网格（Mesh）"></a>网格（Mesh）</h1><p>网格是组成模型的基本单位，是我们在OpenGL中绘制物体所需要的最小单位，通常包含顶点数据、索引和材质属性。</p><p>顶点至少包含一个位置向量、一个法向量和一个纹理坐标向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Vertex &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Normal;</span><br><span class="line">    glm::vec2 TexCoords;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>纹理则包含一个纹理ID和纹理类型（漫反射贴图或镜面光贴图）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Texture &#123;</span><br><span class="line">    unsigned int id;</span><br><span class="line">    string type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么，最简单的Mesh类结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Mesh &#123;</span><br><span class="line">    public:</span><br><span class="line">        &#x2F;*  网格数据  *&#x2F;</span><br><span class="line">        vector&lt;Vertex&gt; vertices;</span><br><span class="line">        vector&lt;unsigned int&gt; indices;</span><br><span class="line">        vector&lt;Texture&gt; textures;</span><br><span class="line">        &#x2F;*  函数  *&#x2F;</span><br><span class="line">        Mesh(vector&lt;Vertex&gt; vertices, vector&lt;unsigned int&gt; indices, vector&lt;Texture&gt; textures);</span><br><span class="line">        void Draw(Shader shader);</span><br><span class="line">    private:</span><br><span class="line">        &#x2F;*  渲染数据  *&#x2F;</span><br><span class="line">        unsigned int VAO, VBO, EBO;</span><br><span class="line">        &#x2F;*  函数  *&#x2F;</span><br><span class="line">        void setupMesh();</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>最终的Mesh类代码在<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/mesh.h">这里</a>。</p><h1 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h1><p>原文翻译文章看<a href="https://learnopengl-cn.github.io/03%20Model%20Loading/03%20Model/">这里</a>。</p><p>Model类的源码在<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/model.h">这里</a>。</p><p>最终，<a href="https://learnopengl.com/code_viewer_gh.php?code=src/3.model_loading/1.model_loading/model_loading.cpp">例子</a>实现了加载模型文件的操作，输出如下：</p><p><img src="https://learnopengl-cn.github.io/img/03/03/model_diffuse.png" alt=""></p><p>根据<a href="https://www.chaguake.com/2021/05/18/OpenGL-introduction-08/">光照教程</a>，添加光线之后的效果如下：</p><p><img src="https://learnopengl-cn.github.io/img/03/03/model_lighting.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模型加载库Assimp&quot;&gt;&lt;a href=&quot;#模型加载库Assimp&quot; class=&quot;headerlink&quot; title=&quot;模型加载库Assimp&quot;&gt;&lt;/a&gt;模型加载库Assimp&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://assimp.org/&quot;&gt;Assim</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（八）——光照贴图和多光源</title>
    <link href="https://www.chaguake.com/2021/05/18/OpenGL-introduction-08/"/>
    <id>https://www.chaguake.com/2021/05/18/OpenGL-introduction-08/</id>
    <published>2021-05-18T07:40:22.000Z</published>
    <updated>2021-05-18T08:51:57.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h1><p>我们可以为物体的材质添加贴图，在贴图上实现光照效果（主要应用在冯氏光照模型中的漫反射光照和镜面光照上）。</p><p>贴图的方式与纹理的使用相似，首先，加载和绑定纹理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bind diffuse map</span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, diffuseMap);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bind specular map</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, specularMap);</span><br></pre></td></tr></table></figure><p>然后，片段着色器中，修改材质属性的结构体，使用<code>sampler2D</code>封装贴图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Material &#123;</span><br><span class="line">    sampler2D diffuse;</span><br><span class="line">    sampler2D specular;</span><br><span class="line">    float     shininess;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，应用到漫反射光照和镜面光照计算中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec3 ambient  &#x3D; light.ambient  * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">vec3 diffuse  &#x3D; light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));  </span><br><span class="line">vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br><span class="line">FragColor &#x3D; vec4(ambient + diffuse + specular, 1.0);</span><br></pre></td></tr></table></figure><p>输出的结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/04/materials_specular_map.png" alt=""></p><h1 id="投光物"><a href="#投光物" class="headerlink" title="投光物"></a>投光物</h1><p><strong>平行光</strong></p><p>平行光的每一条光线互相平行，例如太阳光。</p><p>1<a href="https://learnopengl-cn.github.io/img/02/05/light_casters_directional.png"></a></p><p>平行光中，物体与光源的位置不重要了，只关心光的方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    &#x2F;&#x2F; vec3 position; &#x2F;&#x2F; 使用定向光就不再需要了</span><br><span class="line">    vec3 direction;</span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  vec3 lightDir &#x3D; normalize(-light.direction);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_directional_light.png" alt=""></p><p><strong>点光</strong></p><p>点光的光源是某一个点，然后光线从这个点向四周散发，并且随着距离组件衰减，例如灯泡和火把。</p><p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_point.png" alt=""></p><p>衰减的计算公式如下：</p><script type="math/tex; mode=display">\begin{equation} F_{att} = \frac{1.0}{K_c + K_l * d + K_q * d^2} \end{equation}</script><p>用图表显示如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/05/attenuation.png" alt=""></p><p>实现衰减需要添加三个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    vec3 position;  </span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line"></span><br><span class="line">    float constant;</span><br><span class="line">    float linear;</span><br><span class="line">    float quadratic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后通过公式计算出衰减因子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float distance    &#x3D; length(light.position - FragPos);</span><br><span class="line">float attenuation &#x3D; 1.0 &#x2F; (light.constant + light.linear * distance + </span><br><span class="line">                light.quadratic * (distance * distance));</span><br></pre></td></tr></table></figure><p>最终，将这个衰减因子计算到每一个光照计算中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ambient  *&#x3D; attenuation; </span><br><span class="line">diffuse  *&#x3D; attenuation;</span><br><span class="line">specular *&#x3D; attenuation;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_point_light.png" alt=""></p><p><strong>聚光</strong></p><p>聚光是具有方向和角度的光，它由某一个点发射光线，光线范围在一个圆锥体中，例如手电筒。</p><p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight_angles.png" alt=""></p><p>在片段着舍弃的光结构体中，需要聚光的位置向量、聚光的方向向量和聚光的切光角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    vec3  position;</span><br><span class="line">    vec3  direction;</span><br><span class="line">    float cutOff;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后计算片段与聚光的角度，来决定是否在聚光的内部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float theta &#x3D; dot(lightDir, normalize(-light.direction));</span><br><span class="line"></span><br><span class="line">if(theta &gt; light.cutOff) </span><br><span class="line">&#123;       </span><br><span class="line">  &#x2F;&#x2F; 执行光照计算</span><br><span class="line">&#125;</span><br><span class="line">else  &#x2F;&#x2F; 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span><br><span class="line">  color &#x3D; vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0);</span><br></pre></td></tr></table></figure><p>最终输出的结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight_hard.png" alt=""></p><p>可以看到，聚光的边界十分的清晰，这不符合现实，我们需要将聚光的边缘平滑下，实现衰减效果。</p><p>我们可以定义内圆锥和外圆锥，在内圆锥，光线强度恒为1，外光锥则随着偏移越大，光线强度而逐渐减少为0，计算公式如下。</p><script type="math/tex; mode=display">\begin{equation} I = \frac{\theta - \gamma}{\epsilon} \end{equation}</script><p>在片段着色器不需要<code>if-else</code>的判断了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float theta     &#x3D; dot(lightDir, normalize(-light.direction));</span><br><span class="line">float epsilon   &#x3D; light.cutOff - light.outerCutOff;</span><br><span class="line">float intensity &#x3D; clamp((theta - light.outerCutOff) &#x2F; epsilon, 0.0, 1.0);    </span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 将不对环境光做出影响，让它总是能有一点光</span><br><span class="line">diffuse  *&#x3D; intensity;</span><br><span class="line">specular *&#x3D; intensity;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最终，输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight.png" alt=""></p><h1 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h1><p>多光源其实是在片段着色器中对每个光照的叠加，具体实现代码在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/6.multiple_lights/multiple_lights.cpp">这里</a>可以找到。</p><p>实现的效果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/06/multiple_lights_combined.png" alt=""></p><p><strong>顶点着色器</strong></p><p>我们来看下这个多光源场景中物体的顶点着色器源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos;</span><br><span class="line">layout (location &#x3D; 1) in vec3 aNormal;</span><br><span class="line">layout (location &#x3D; 2) in vec2 aTexCoords;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 Normal;</span><br><span class="line">out vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragPos &#x3D; vec3(model * vec4(aPos, 1.0));</span><br><span class="line">    Normal &#x3D; mat3(transpose(inverse(model))) * aNormal;  </span><br><span class="line">    TexCoords &#x3D; aTexCoords;</span><br><span class="line">    </span><br><span class="line">    gl_Position &#x3D; projection * view * vec4(FragPos, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定了三个数据源，顶点位置、法向量和纹理位置。</p><p><strong>片段着色器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">struct Material &#123;</span><br><span class="line">    sampler2D diffuse;</span><br><span class="line">    sampler2D specular;</span><br><span class="line">    float shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct DirLight &#123;</span><br><span class="line">    vec3 direction;</span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct PointLight &#123;</span><br><span class="line">    vec3 position;</span><br><span class="line">    </span><br><span class="line">    float constant;</span><br><span class="line">    float linear;</span><br><span class="line">    float quadratic;</span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct SpotLight &#123;</span><br><span class="line">    vec3 position;</span><br><span class="line">    vec3 direction;</span><br><span class="line">    float cutOff;</span><br><span class="line">    float outerCutOff;</span><br><span class="line">  </span><br><span class="line">    float constant;</span><br><span class="line">    float linear;</span><br><span class="line">    float quadratic;</span><br><span class="line">  </span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;       </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define NR_POINT_LIGHTS 4</span><br><span class="line"></span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 Normal;</span><br><span class="line">in vec2 TexCoords;</span><br><span class="line"></span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line">uniform DirLight dirLight;</span><br><span class="line">uniform PointLight pointLights[NR_POINT_LIGHTS];</span><br><span class="line">uniform SpotLight spotLight;</span><br><span class="line">uniform Material material;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; function prototypes</span><br><span class="line">vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);</span><br><span class="line">vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);</span><br><span class="line">vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;    </span><br><span class="line">    &#x2F;&#x2F; properties</span><br><span class="line">    vec3 norm &#x3D; normalize(Normal);</span><br><span class="line">    vec3 viewDir &#x3D; normalize(viewPos - FragPos);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    &#x2F;&#x2F; Our lighting is set up in 3 phases: directional, point lights and an optional flashlight</span><br><span class="line">    &#x2F;&#x2F; For each phase, a calculate function is defined that calculates the corresponding color</span><br><span class="line">    &#x2F;&#x2F; per lamp. In the main() function we take all the calculated colors and sum them up for</span><br><span class="line">    &#x2F;&#x2F; this fragment&#39;s final color.</span><br><span class="line">    &#x2F;&#x2F; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    &#x2F;&#x2F; phase 1: directional lighting</span><br><span class="line">    vec3 result &#x3D; CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line">    &#x2F;&#x2F; phase 2: point lights</span><br><span class="line">    for(int i &#x3D; 0; i &lt; NR_POINT_LIGHTS; i++)</span><br><span class="line">        result +&#x3D; CalcPointLight(pointLights[i], norm, FragPos, viewDir);    </span><br><span class="line">    &#x2F;&#x2F; phase 3: spot light</span><br><span class="line">    result +&#x3D; CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span><br><span class="line">    </span><br><span class="line">    FragColor &#x3D; vec4(result, 1.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; calculates the color when using a directional light.</span><br><span class="line">vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    vec3 lightDir &#x3D; normalize(-light.direction);</span><br><span class="line">    &#x2F;&#x2F; diffuse shading</span><br><span class="line">    float diff &#x3D; max(dot(normal, lightDir), 0.0);</span><br><span class="line">    &#x2F;&#x2F; specular shading</span><br><span class="line">    vec3 reflectDir &#x3D; reflect(-lightDir, normal);</span><br><span class="line">    float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);</span><br><span class="line">    &#x2F;&#x2F; combine results</span><br><span class="line">    vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br><span class="line">    return (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; calculates the color when using a point light.</span><br><span class="line">vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    vec3 lightDir &#x3D; normalize(light.position - fragPos);</span><br><span class="line">    &#x2F;&#x2F; diffuse shading</span><br><span class="line">    float diff &#x3D; max(dot(normal, lightDir), 0.0);</span><br><span class="line">    &#x2F;&#x2F; specular shading</span><br><span class="line">    vec3 reflectDir &#x3D; reflect(-lightDir, normal);</span><br><span class="line">    float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);</span><br><span class="line">    &#x2F;&#x2F; attenuation</span><br><span class="line">    float distance &#x3D; length(light.position - fragPos);</span><br><span class="line">    float attenuation &#x3D; 1.0 &#x2F; (light.constant + light.linear * distance + light.quadratic * (distance * distance));    </span><br><span class="line">    &#x2F;&#x2F; combine results</span><br><span class="line">    vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br><span class="line">    ambient *&#x3D; attenuation;</span><br><span class="line">    diffuse *&#x3D; attenuation;</span><br><span class="line">    specular *&#x3D; attenuation;</span><br><span class="line">    return (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; calculates the color when using a spot light.</span><br><span class="line">vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)</span><br><span class="line">&#123;</span><br><span class="line">    vec3 lightDir &#x3D; normalize(light.position - fragPos);</span><br><span class="line">    &#x2F;&#x2F; diffuse shading</span><br><span class="line">    float diff &#x3D; max(dot(normal, lightDir), 0.0);</span><br><span class="line">    &#x2F;&#x2F; specular shading</span><br><span class="line">    vec3 reflectDir &#x3D; reflect(-lightDir, normal);</span><br><span class="line">    float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);</span><br><span class="line">    &#x2F;&#x2F; attenuation</span><br><span class="line">    float distance &#x3D; length(light.position - fragPos);</span><br><span class="line">    float attenuation &#x3D; 1.0 &#x2F; (light.constant + light.linear * distance + light.quadratic * (distance * distance));    </span><br><span class="line">    &#x2F;&#x2F; spotlight intensity</span><br><span class="line">    float theta &#x3D; dot(lightDir, normalize(-light.direction)); </span><br><span class="line">    float epsilon &#x3D; light.cutOff - light.outerCutOff;</span><br><span class="line">    float intensity &#x3D; clamp((theta - light.outerCutOff) &#x2F; epsilon, 0.0, 1.0);</span><br><span class="line">    &#x2F;&#x2F; combine results</span><br><span class="line">    vec3 ambient &#x3D; light.ambient * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 diffuse &#x3D; light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));</span><br><span class="line">    vec3 specular &#x3D; light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br><span class="line">    ambient *&#x3D; attenuation * intensity;</span><br><span class="line">    diffuse *&#x3D; attenuation * intensity;</span><br><span class="line">    specular *&#x3D; attenuation * intensity;</span><br><span class="line">    return (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器中可以看到，其GLSL的语法与C差不多。</p><p>在main函数中，首先是对平行定向光线的计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; phase 1: directional lighting</span><br><span class="line">vec3 result &#x3D; CalcDirLight(dirLight, norm, viewDir);</span><br></pre></td></tr></table></figure><p>然后，遍历计算每一个点光：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; phase 2: point lights</span><br><span class="line">for(int i &#x3D; 0; i &lt; NR_POINT_LIGHTS; i++)</span><br><span class="line">    result +&#x3D; CalcPointLight(pointLights[i], norm, FragPos, viewDir);</span><br></pre></td></tr></table></figure><p>最后，计算聚光：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; phase 3: spot light</span><br><span class="line">result +&#x3D; CalcSpotLight(spotLight, norm, FragPos, viewDir);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;光照贴图&quot;&gt;&lt;a href=&quot;#光照贴图&quot; class=&quot;headerlink&quot; title=&quot;光照贴图&quot;&gt;&lt;/a&gt;光照贴图&lt;/h1&gt;&lt;p&gt;我们可以为物体的材质添加贴图，在贴图上实现光照效果（主要应用在冯氏光照模型中的漫反射光照和镜面光照上）。&lt;/p&gt;
&lt;p&gt;贴图</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（七）——材质</title>
    <link href="https://www.chaguake.com/2021/05/14/OpenGL-introduction-07/"/>
    <id>https://www.chaguake.com/2021/05/14/OpenGL-introduction-07/</id>
    <published>2021-05-14T08:50:12.000Z</published>
    <updated>2021-05-14T09:25:57.346Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://learnopengl.com/#!Lighting/Materials">英文原文地址</a>    <a href="https://learnopengl-cn.github.io/02%20Lighting/03%20Materials/">中文翻译地址</a></p><h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><p>由于每个物体对光的反应是不一样的，所以我们需要为每个物体分别定义一个材质（Material）属性。</p><p>可以使用环境光照（Ambient Lighting）、漫反射光照（Diffuse Lighting）、镜面光照（Specular Lighting）和反光度（Shininess）来定义物体的材质属性。</p><p>在片段着色器上，使用结构体封装物体的材质属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">struct Material &#123;</span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">    float shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">uniform Material material;</span><br></pre></td></tr></table></figure><p>向量<code>ambient</code>定义了在环境光照下这个物体反射的颜色，通常来说是物体的固有色。向量<code>diffuse</code>定义了在漫反射光照下物体的颜色。向量<code>specular</code>设置了镜面光照对物体颜色的影响（有可能物体反射的是光的颜色，有可能物体反射的是自身特定的高光颜色）。变量<code>shininess</code>影响镜面高光的散射/半径。</p><p><img src="https://learnopengl-cn.github.io/img/02/03/materials_real_world.png" alt=""></p><h1 id="光照光的属性"><a href="#光照光的属性" class="headerlink" title="光照光的属性"></a>光照光的属性</h1><p>我们还需要对每一种光照添加强度属性，毕竟每一种关照对物体的影响是不一样的。并且关照的位置也会影响物体的最终颜色。</p><p>可以定义一个光照的光的属性的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    vec3 position;</span><br><span class="line"></span><br><span class="line">    vec3 ambient;</span><br><span class="line">    vec3 diffuse;</span><br><span class="line">    vec3 specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uniform Light light;</span><br></pre></td></tr></table></figure><p>我们可以改变光源的环境光颜色和漫反射光照颜色，使得物体随光源的颜色变换而变换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 lightColor;</span><br><span class="line">lightColor.x &#x3D; sin(glfwGetTime() * 2.0f);</span><br><span class="line">lightColor.y &#x3D; sin(glfwGetTime() * 0.7f);</span><br><span class="line">lightColor.z &#x3D; sin(glfwGetTime() * 1.3f);</span><br><span class="line"></span><br><span class="line">glm::vec3 diffuseColor &#x3D; lightColor   * glm::vec3(0.5f); &#x2F;&#x2F; 降低影响</span><br><span class="line">glm::vec3 ambientColor &#x3D; diffuseColor * glm::vec3(0.2f); &#x2F;&#x2F; 很低的影响</span><br><span class="line"></span><br><span class="line">lightingShader.setVec3(&quot;light.ambient&quot;, ambientColor);</span><br><span class="line">lightingShader.setVec3(&quot;light.diffuse&quot;, diffuseColor);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><div style="position: relative; padding: 30% 45%;">  <iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://learnopengl-cn.github.io/img/02/03/materials.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://learnopengl.com/#!Lighting/Materials&quot;&gt;英文原文地址&lt;/a&gt;    &lt;a href=&quot;https://learnopengl-cn.github.io/02%20Lighting/03%20Material</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（六）——基本光照</title>
    <link href="https://www.chaguake.com/2021/05/13/OpenGL-introduction-06/"/>
    <id>https://www.chaguake.com/2021/05/13/OpenGL-introduction-06/</id>
    <published>2021-05-13T07:28:38.000Z</published>
    <updated>2021-05-14T07:13:48.023Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://learnopengl.com/#!Lighting/Basic-Lighting">英文原文地址</a> <a href="https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/">中文翻译地址</a></p><h1 id="物体颜色"><a href="#物体颜色" class="headerlink" title="物体颜色"></a>物体颜色</h1><p>物体所呈现的颜色是因为物体吸收了光照的其他子颜色，反射了不被吸收的子颜色，所以物体看起来就是这个不被吸收的颜色。</p><p>在OpenGL中，我们将光照颜色和物体颜色作分量相乘，得到的就是物体在某种光照下最终的颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 lightColor(0.33f, 0.42f, 0.18f);</span><br><span class="line">glm::vec3 toyColor(1.0f, 0.5f, 0.31f);</span><br><span class="line">glm::vec3 result &#x3D; lightColor * toyColor; &#x2F;&#x2F; &#x3D; (0.33f, 0.21f, 0.06f);</span><br></pre></td></tr></table></figure><h1 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h1><p>下面基于冯氏光照模型（Phong Lighting Model）来学习基础光照的知识。</p><p>冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p><p><img src="https://learnopengl-cn.github.io/img/02/02/basic_lighting_phong.png" alt=""></p><ul><li><p>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</p></li><li><p>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</p></li><li><p>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</p></li></ul><h2 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h2><p>全局照明（Global Illumination）算法非常复杂，现在使用简化的方式来实现环境光照——用一个简单的颜色，添加到物体片段的最终颜色中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    float ambientStrength &#x3D; 0.1;</span><br><span class="line">    vec3 ambient &#x3D; ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line">    vec3 result &#x3D; ambient * objectColor;</span><br><span class="line">    FragColor &#x3D; vec4(result, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h2><p>漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。</p><p><img src="https://learnopengl-cn.github.io/img/02/02/diffuse_light.png" alt=""></p><p>如上图所示，垂直于片段表面的叫法向量（Normal Vector），根据光线与法向量的夹角决定光线对物体颜色的影响。夹角采用两个向量对应的单位向量的点乘结果作为与夹角对应的影响标量。</p><p><strong>法向量</strong></p><p>法向量是一个垂直有顶点表面的单位向量，是通过该顶点与周围的顶点叉乘计算得到的向量。</p><p>具体代码可以看<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.1.basic_lighting_diffuse/basic_lighting_diffuse.cpp">这里</a>，输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/02/basic_lighting_diffuse.png" alt=""></p><p><strong>法线矩阵</strong></p><p>物体的不等比缩放会破坏法向量，所以需要在顶点着色器上，使用函数<code>inverse</code>和<code>transpose</code>生成法线矩阵来处理法向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal &#x3D; mat3(transpose(inverse(model))) * aNormal;</span><br></pre></td></tr></table></figure><h2 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h2><p>在漫反射光照中，没涉及到物体的反射，如下图，反射向量与视线的夹角决定了镜面光照的影响。</p><p><img src="https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular_theory.png" alt=""></p><p><strong>反光度</strong></p><p>平常我们可以注意到，有些物体反光很厉害。这个在OpenGL中使用反光度来反映，通过对视线方向与反射方向的点乘结果取幂次数来决定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float spec &#x3D; pow(max(dot(viewDir, reflectDir), 0.0), 32);</span><br><span class="line">vec3 specular &#x3D; specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure><p>上面代码就是取32次幂，下面展示不同次幂的视觉效果：</p><p><img src="https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular_shininess.png" alt=""></p><p>最终源码在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.2.basic_lighting_specular/basic_lighting_specular.cpp">这里</a>，输出如下：</p><p><img src="https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://learnopengl.com/#!Lighting/Basic-Lighting&quot;&gt;英文原文地址&lt;/a&gt; &lt;a href=&quot;https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（五）——坐标系统与摄像机</title>
    <link href="https://www.chaguake.com/2021/05/12/OpenGL-introduction-05/"/>
    <id>https://www.chaguake.com/2021/05/12/OpenGL-introduction-05/</id>
    <published>2021-05-12T02:00:11.000Z</published>
    <updated>2021-05-14T07:12:42.994Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl.com/Getting-started/Camera">英文原文地址</a> <a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">中文翻译地址</a></p><h1 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h1><p>将物体的坐标最后转换成屏幕最后输出的结果，需要经过几次坐标系统的叠加转换，如下图：</p><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt=""></p><p>1、局部坐标（Local Space）是物体相对于局部原点的坐标，也是物体其实的坐标。</p><p>2、下一步是将局部坐标变换成世界控件坐标（World Space），世界控件坐标是处于一个更大的空间范畴。物体相对于物体原点的坐标变换成相对于世界原点的坐标。</p><p>3、接下来将世界坐标变换成观察空间坐标（View Space），使得每一个物体的坐标都是从摄像机的角度进行观察。</p><p>4、然后需要将其投影到裁剪坐标（Clip Space）。坐标会被处理在-1.0到1.0之间的范围，由此判断哪些顶点将会出现在屏幕上。</p><p>5、最后，将裁剪坐标变换成屏幕坐标（Screen Space），这是一个视口变换（Viewport transform）的过程。视口变换将位于-1.0到1.0范围内的坐标变换到由函数<code>glViewport</code>所定义的坐标范围内。最后变换出来的坐标会被送到光栅器，将其转化为片段。</p><p>公式如下：</p><script type="math/tex; mode=display">V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}</script><h1 id="右手坐标系"><a href="#右手坐标系" class="headerlink" title="右手坐标系"></a>右手坐标系</h1><p>OpenGL使用右手坐标系。正X轴方向指向右边，正Y轴指向上方，正Z轴由屏幕内部指向外面。</p><p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems_right_handed.png" alt=""></p><p>也可以伸出右手，大拇指（正X轴）指向右边，食指（正Y轴）指向上方，中指（正Z轴）指向自己。</p><p><strong>左手坐标系在DirectX中广泛应用，并且在标准化设备坐标系中OpenGL也是使用左手坐标系（投影矩阵交换了左右手）。</strong></p><h1 id="Z缓冲（深度缓冲）"><a href="#Z缓冲（深度缓冲）" class="headerlink" title="Z缓冲（深度缓冲）"></a>Z缓冲（深度缓冲）</h1><p>OpenGL使用Z缓冲来存储深度信息，它决定何时是否覆盖一个像素。</p><p>深度值存储在每个片段中（片段的z值），当片段要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前片段在其他片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试，由OpenGL自动完成。</p><p>深度测试默认是关闭的，可使用函数<code>glEnable</code>来开启，使用函数<code>glDisable</code>来禁用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>同时，需要使用函数<code>glClear</code>来清理上一帧的深度缓冲：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><h1 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h1><p>从世界空间坐标系转变成观察空间坐标，首先需要知道观察者，即摄像机相对于世界空间的坐标，还有就是摄像机方向。</p><h2 id="摄像机位置"><a href="#摄像机位置" class="headerlink" title="摄像机位置"></a>摄像机位置</h2><p>摄像机位置简单来说就是世界空间中一个指向摄像机位置的变量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos &#x3D; glm::vec3(0.0f, 0.0f, 3.0f);</span><br></pre></td></tr></table></figure><p>值得注意的是，正Z轴是从屏幕指向你的，如果要摄像机向后移动，把它沿着Z轴正方向移动即可。</p><h2 id="摄像机方向"><a href="#摄像机方向" class="headerlink" title="摄像机方向"></a>摄像机方向</h2><p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraTarget &#x3D; glm::vec3(0.0f, 0.0f, 0.0f);</span><br><span class="line">glm::vec3 cameraDirection &#x3D; glm::normalize(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure><blockquote><p>方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。</p></blockquote><h2 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h2><p>我们知道了摄像机的位置和方向，可以使用GLM库的函数<code>lookAt</code>来得到观察矩阵。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view &#x3D; glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), </span><br><span class="line">           glm::vec3(0.0f, 0.0f, 0.0f), </span><br><span class="line">           glm::vec3(0.0f, 1.0f, 0.0f));</span><br></pre></td></tr></table></figure><p>函数<code>glm::LookAt</code>需要三个参数——摄像机位置、目标位置和世界空间中的上向量。</p><h1 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h1><p>欧拉角表示三维控件中旋转的三个角——俯仰角（Pitch）、偏航角（Yaw）和滚转角（Roll）。</p><p><img src="https://learnopengl-cn.github.io/img/01/09/camera_pitch_yaw_roll.png" alt=""></p><h1 id="万向节死锁"><a href="#万向节死锁" class="headerlink" title="万向节死锁"></a>万向节死锁</h1><p>文章<a href="https://blog.csdn.net/AndrewFan/article/details/60981437">【Unity编程】欧拉角与万向节死锁（图文版）</a>解释得很清楚，出现万向节死锁的原因，简单来说就是，当一个轴转动了某一个角度，使得与另一个轴处于一个平面上后，这时对那个轴的操作得不到预期的效果。</p><p>借助工具（<a href="https://andrewfanchina.github.io/UnityLabs/Euler/">这里</a>）来加深对万向节死锁的理解。</p><p>首先我们先了解下工具的使用情况。</p><p>红色轴为X轴，绿色轴为Y轴，蓝色轴为Z轴，有实心圆点的一端是正方向。如下图：</p><p><img src="./tool00.png" alt=""></p><p>俯仰角（Pitch）改变的方向是垂直于X轴，平行于YZ平面。如下图：</p><p><img src="./tool01.png" alt=""></p><p>偏航角（Yaw）改变的方向是垂直于Y轴，平行于XZ平面。如下图：</p><p><img src="./tool02.png" alt=""></p><p>滚转角（Roll）改变的方向是垂直于Z轴，平行于XY平面。如下图：</p><p><img src="./tool03.png" alt=""></p><p>下面开始实现万向节死锁，第一步，我们先将目标朝上扬起90°，即俯仰角（Pitch）添加90°。如下图：</p><p><img src="./tool01.png" alt=""></p><p>1、假设我们第二步将目标向右旋转90°，即偏航角（Yaw）添加90°。如下图，对于目标来说，它是滚动旋转了90°。</p><p><img src="./tool04.png" alt=""></p><p>2、假设我们第二步将目标向右滚动旋转90°，即滚转角（Roll）添加90°，如下图，跟第一种假设情况一样，对于目标来说，它是滚动旋转了90°，但是它运动的方向并没有垂直于Z轴，平行于XY轴。</p><p><img src="./tool05.png" alt=""></p><p>显然，自由度从原来的三个自由度变成了两个自由度（俯仰角和偏航角）。因为X轴和Y轴平行了，如下图：</p><p><img src="https://img-blog.csdn.net/20170311165659086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQW5kcmV3RmFu/font/5a6L5L2T/fontsize/200/fill/I0JBQkFCMA==/dissolve/70/gravity/NorthEast" alt=""></p><h1 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h1><h1 id="摄像机类的使用记录"><a href="#摄像机类的使用记录" class="headerlink" title="摄像机类的使用记录"></a>摄像机类的使用记录</h1><p><strong>概述</strong> </p><p>在<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/camera.h">这里</a>可以找到教程中的摄像机类的实现。</p><p>可以看到，Camera类接受四个参数（position, up, yaw, pitch）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::lookAt(Position, Position + Front, Up);</span><br></pre></td></tr></table></figure><p>Camera类将lookAt函数的第二个目标位置参数变成<code>Position+Front</code>，Front变量存储摄像机朝向的向量（前轴）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x &#x3D; cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));</span><br><span class="line">front.y &#x3D; sin(glm::radians(Pitch));</span><br><span class="line">front.z &#x3D; sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));</span><br><span class="line">Front &#x3D; glm::normalize(front);</span><br><span class="line">Right &#x3D; glm::normalize(glm::cross(Front, WorldUp));</span><br><span class="line">Up &#x3D; glm::normalize(glm::cross(Right, Front));</span><br></pre></td></tr></table></figure><p>通过鼠标控制改变俯仰角和偏航角，进而改变摄像机的前轴和上轴，最后改变lookAt的位置。</p><p>值得注意的是，假设俯仰角和偏航角的值都为0，那么Front值为(1,0,0)，一个向右的正X轴方向，即摄像机默认看向X轴正方向。一般地，我们需要将摄像机设置成垂直看向XY平面，所以需要默认给摄像机一个偏航角<code>-90°</code>，使得摄像机从朝向右变成朝向里。</p><p><strong>摄像机位置</strong></p><p>1、摄像机位于正Z轴上，看向原点(0,0,0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Camera camera(glm::vec3(0.0f, 0.0f, 45.0f), glm::vec3(0.0f, 1.0f, 0.0f), -90.0f, 0.0f);</span><br></pre></td></tr></table></figure><p>这时，计算出来的Front为(0,0,-1)，看向负Z轴，这里可以计算出lookAt点为(0,0,44)。但为什么不是原点(0,0,0)呢？其实，这里无论是(0,0,44)还是(0,0,0)，都是一样的视角，只因为摄像机(0,0,45)本身也在Z轴上，这三个点都在同一条垂直于XY平面的直线上，而摄像机默认视角是垂直于XY平面的。</p><p>假如把Up值改成(0,-1,0)，这时的视角就是倒立看到的视角。</p><p>2、摄像机处于45°视角，看向原点(0,0,0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Camera camera(glm::vec3(0.0f, 45.0f, 45.0f), glm::vec3(0.0f, 1.0f, 0.0f), -90.0f, -45.0f);</span><br></pre></td></tr></table></figure><p>Front值为(0,-0.7,-0.7)（向量的长度不会改变向量的方向，它跟(0,45,45)平行反向）。</p><p>可以看到俯仰角倾斜了45°，因为需要摄像机的视角与XY轴的夹角为45°。</p><p>3、摄像机围绕原点(0,0,0)旋转</p><p>我们选择摄像机的视角是位于XY平面看向原点(0,0,0)，处于(0,-45,0)位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Camera camera(glm::vec3(0.0f, -45.0f, 0.0f), glm::vec3(0.0f, 0.0f, -1.0f), -90.0f, 90.0f);</span><br></pre></td></tr></table></figure><p>那么需要设置摄像机的俯仰角固定为90°，偏航角起始值为-90°，且世界上向量应为(0,0,1)或(0,0,-1)。</p><p>然后，需要把Camera类中的目标坐标从<code>Position + Front</code>改成<code>glm::vec3(0.0f, 0.0f, 0.0f)</code>，使得摄像机一直看向原点。</p><p>最后，需要添加一个函数，在每个周期更新摄像机的位置和偏航角。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void auto_cycle()&#123;</span><br><span class="line">static float angle &#x3D; -90.0;</span><br><span class="line">angle +&#x3D; 0.001;</span><br><span class="line">float camX &#x3D; cos(angle) * 45;</span><br><span class="line">float camY &#x3D; sin(angle) * 45;</span><br><span class="line">float offsety &#x3D; camera.Position.y - camY;</span><br><span class="line">camera.Position &#x3D; glm::vec3(camX, camY, 0.0f);</span><br><span class="line">camera.Yaw -&#x3D; 0.001;</span><br><span class="line">camera.updateCameraVectors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改位置的原因很简单，更改偏航角的原因是要让摄像机一直面向原点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Camera&quot;&gt;英文原文地址&lt;/a&gt; &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/09%2</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——RNA</title>
    <link href="https://www.chaguake.com/2021/05/10/Blender-source-code-study-07/"/>
    <id>https://www.chaguake.com/2021/05/10/Blender-source-code-study-07/</id>
    <published>2021-05-10T02:23:35.000Z</published>
    <updated>2021-05-11T01:41:03.309Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Architecture/RNA">这里</a></p><hr><h1 id="RNA"><a href="#RNA" class="headerlink" title="RNA"></a>RNA</h1><blockquote><p>这是一份数据API实现的文档。</p></blockquote><h2 id="实现（Implementation）"><a href="#实现（Implementation）" class="headerlink" title="实现（Implementation）"></a>实现（Implementation）</h2><p>RNA的实现在模块<code>makesrna</code>。其中，几个重要的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RNA_types.h: The important RNA data structures are defined here.</span><br><span class="line">RNA_access.h: API for accessing structs and properties at runtime.</span><br><span class="line">RNA_define.h: API for defining structs and properties.</span><br></pre></td></tr></table></figure><p><img src="https://wiki.blender.org/w/images/0/06/RNADataTypes.png" alt=""></p><h2 id="定义结构体和属性（Defining-Structs-and-Properties）"><a href="#定义结构体和属性（Defining-Structs-and-Properties）" class="headerlink" title="定义结构体和属性（Defining Structs and Properties）"></a>定义结构体和属性（Defining Structs and Properties）</h2><p>结构体和属性都定义在<code>makesrna</code>模块的<code>rna_*.c</code>这一类文件中，其定义作为构建系统的一部分生成。错误信息会在构建期间打印出来。</p><h3 id="结构体（Struct）"><a href="#结构体（Struct）" class="headerlink" title="结构体（Struct）"></a>结构体（Struct）</h3><ul><li><p>如果你没有在已存在的文件中添加它：</p><ul><li><p>拷贝已存在的文件，重命名并清理它。</p></li><li><p>在文件<code>makesrna.c</code>中，把它添加到列表<code>PROCESS_ITEMS</code>。</p></li></ul></li><li><p>在文件<code>rna_access.h</code>中，添加结构体<code>StructRNA</code>的extern描述。</p></li><li><p>对于数据块，在文件<code>rna_ID.c</code>中添加正确的ID_case到函数<code>rna_ID_refine()</code>。</p></li></ul><p>接下来，在函数<code>RNA_def_*</code>类函数中，对应的结构体将会被定义。函数<code>RNA_def_struct</code>定义了结构体本身。我们必须定义一个唯一名称且人类能理解的标识符去标识这些结构体。</p><p>系统就会自动尝试找到与标识符同名的DNA结构体。假如一个相应的结构体拥有不同的名称，函数<code>RNA_def_struct_sdna</code>可以找到正确的名称，这对于以后更加自动地定义属性很重要。</p><p>对于每一个结构体都尽可能地把其名称设置为字符串属性，这个名称将用于UI，并且可以在集合（collections）中使用字符串搜索。</p><p>对于ID数据块结构体（ID struct），它需要满足：</p><ul><li><p>在文件<code>rna_main.c</code>中，将“lists”数组中现有项改成正确的类型以代替“ID”，或者是添加新项。</p></li><li><p>在文件<code>rna_ID.c</code>中，使用函数<code>rna_ID_refine</code>添加改结构体。</p></li></ul><h3 id="属性（Property）"><a href="#属性（Property）" class="headerlink" title="属性（Property）"></a>属性（Property）</h3><p>对于每一个属性，始于函数<code>RNA_def_property</code>。其标识符一定要跟对应的结构体类似。然后我们必须定义一个类型和子类型。类型确定了数据类型，子类型则是对数据的解释，举个例子，一个float数组属性可以是颜色、向量或者矩阵。</p><p>同样地，系统会使用跟标识符一样的字符串在DNA结构体中查找属性，如果它有不一样的名称，下一步要做的是使用函数<code>RNA_def_*_sdna</code>正确指向它。DNA信息用于衍生各种各样的事物，比如说，<code>get/set</code>函数、集合的迭代器、数组长度、限制器等等，下一节将解释映射的工作规则。</p><p>如果这些自动值（the automatic values）不正确，则可以后置覆盖。文件<code>RNA_define.h</code>为不同的类型提供信息概括。重要的定义是数组长度、数字范围和枚举项。</p><p>接下来，我们需要定义默认值。如果没有显式定义，则数字的默认值为0，字符串的默认值为“”，指针的默认值为NULL，集合的默认值则为空。</p><p>为了构建更加自动的用户界面，需要为工具定义通俗易懂的名称和描述。对于可伸缩的数值，定义可拖拽的步长和精度。这些将是从RNA属性中生成按钮时的默认值。</p><p>在很多情况下，自动DNA的匹配会解决这个问题，但在某些情况下，我们必须为<code>get/set</code>函数设置回调函数。它们的名称可以使用函数<code>RNA_def_property_*_funcs</code>传递，参数请参见文件<code>RNA_type.h</code>。集合（collections）是最困难的，尽管可以自动支持<code>ListBase</code>和特定数组。请注意，有些函数调用是可选的，它们只对优化有帮助，举个例子，列表的查找函数。</p><h3 id="DNA匹配（DNA-Matching）"><a href="#DNA匹配（DNA-Matching）" class="headerlink" title="DNA匹配（DNA Matching）"></a>DNA匹配（DNA Matching）</h3><p><img src="https://wiki.blender.org/w/images/1/1b/RNAPreprocessing.png" alt=""></p><ul><li><p>Booleans/Ints/Floats：数组长度基于在float member[x]中的数值<code>x</code>。举个例子，只支持一维数组。如果变量本身不是数组，它会假设连续变量是数组的一部分。举个例子，指定变量<code>r</code>来自浮点型变量<code>r</code>、<code>g</code>和<code>b</code>，那么，可以假设数组的地址为<code>&amp;r</code>。</p></li><li><p>Booleans可以使用函数<code>RNA_def_property_boolean_sdna</code>指定为一个bit。如果定义了数组长度但没有数组成员SDNA，那么可以假设这个数组是通过由指定bit开始的bit标志位定义的。</p></li><li><p>Ints：数值值范围见<code>INT_MIN/INT_MAX</code>，如果检测出是char或者short，则使用对应的值范围。非负数类型现在并没有自动检测（SDNA不支持），所以，应该使用子类型<code>PROP_UNSIGNED</code>或者手动限制其值范围。</p></li><li><p>Enums：函数<code>RNA_def_property_enum_sdna</code>有一个参数去判断枚举是否是bit标志位的，在与其他标志位混用时应当被设置。</p></li><li><p>Strings：char数组，最大长度取决于数组大小。</p></li><li><p>Pointers：如果指针类型未定义，则会根据结构体对应的DNA自动定义，对于定义为指向数组指针的集合，也是使用指针。</p></li><li><p>Collections：基于ListBase，函数<code>begin/next/get</code>会自动生成。</p></li><li><p>Collections：当将包含集合长度的变量的名称传递给SDNA函数时，假设正在使用一个数组，则会为这个数组自动生成函数<code>begin/next/get/end</code>。如果成员的指针是像<code>MVert *mvert;</code>这样的简单指针，它会返回<code>&amp;mvert[i]</code>这样的items，如果它是像<code>Material **mat;</code>这样指向指针的指针，他就会返回<code>mat[i]</code>这样的items。</p></li><li><p>在嵌套结构体中的成员也可以被识别，举个例子，使用函数<code>RNA_def_property_*_sdna</code>传递一个值。</p></li></ul><h3 id="命名约束（Naming-Conventions）"><a href="#命名约束（Naming-Conventions）" class="headerlink" title="命名约束（Naming Conventions）"></a>命名约束（Naming Conventions）</h3><h2 id="运行时接入（Runtime-Access）"><a href="#运行时接入（Runtime-Access）" class="headerlink" title="运行时接入（Runtime Access）"></a>运行时接入（Runtime Access）</h2><p><img src="https://wiki.blender.org/w/images/5/5c/RNARuntimeAccess.png" alt=""></p><p>运行时接入属性值是通过定义在文件<code>RNA_access.h</code>的函数。支持函数<code>get/set</code>和集合迭代器。</p><p>这也是使用函数去检查属性是否可编辑的或已计算的。如果属性是可编辑的，这就意味着它可以被用户修改。如果它是可计算的，这就意味着它可以将一些函数设置为计算的一部分，例如：修改器、约束器或者动画系统的一部分。</p><h3 id="指针（Pointers）"><a href="#指针（Pointers）" class="headerlink" title="指针（Pointers）"></a>指针（Pointers）</h3><p><img src="https://wiki.blender.org/w/images/b/b2/RNAPointerID.png" alt=""></p><p>一个RNA结构体的指针总是包裹在结构体<code>PointerRNA</code>中。结构体<code>PointerRNA</code>包含实际的数据指针和结构体类型。它也包含了数据指针和数据所属的ID数据块类型。这在某种情况下是有需要的，举个例子，一个顶点自身是提供不了足够的信息去更新依赖关系图，我们需要知道顶点所在的网格（mesh）。</p><p>在运行时中创建指针，使用函数<code>RNA_main_pointer_create</code>、<code>RNA_id_pointer_create</code>和<code>RNA_pointer_create</code>。</p><p>属性的回调函数使用PointerRNA们来代替直接指向数据的指针，因此，它们在需要的时候可以使用ID数据。指针和集合的<code>get/set</code>回调函数返回数据指针，类型和ID则会在回调的外部自动填充。</p><h2 id="ID属性（ID-Properties）"><a href="#ID属性（ID-Properties）" class="headerlink" title="ID属性（ID Properties）"></a>ID属性（ID Properties）</h2><p><img src="https://wiki.blender.org/w/images/2/21/RNAIDProperties.png" alt=""></p><p>RNA同样支持ID属性，有两个方法：</p><ul><li><p>如果一个RNA属性是在运行时中定义，或者有<code>PROP_IDPROPERTY</code>标记，ID属性将会通过RNA API被首次创建。RNA API初始化时返回默认值，直到创建ID属性，然后，返回ID属性值。值得注意的是，如果RNA定义了相同名称但不用类型的ID属性，那它会移除和重写，以匹配上RNA的类型。</p></li><li><p>如果存在一个ID属性但它没有对应的RNA属性，当遍历结构体的属性时，依旧通过RNA暴露。RNA信息会得到默认值：像用户界面名称这类物体将从ID属性名称得到，数值范围则会根据其类型得到默认值。</p></li></ul><p>为了简化没有对应RNA属性的ID属性的API，可使用函数<code>RNA_property_*</code>得到实际的<code>PropertyRNA*</code>，或者使用<code>IDProperty*</code>强制转换得到<code>PropertyRNA*</code>。内置函数会检测出哪个数据结构体被使用。因此，对成员<code>PropertyRNA*</code>的访问必须通过访问器函数，而不是直接访问该成员。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Architecture/RNA</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——ID Datablocks</title>
    <link href="https://www.chaguake.com/2021/05/08/Blender-source-code-study-06/"/>
    <id>https://www.chaguake.com/2021/05/08/Blender-source-code-study-06/</id>
    <published>2021-05-08T09:50:42.000Z</published>
    <updated>2021-05-10T02:21:58.106Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Architecture/ID">这里</a></p><hr><h1 id="ID数据块（ID-Datablocks）"><a href="#ID数据块（ID-Datablocks）" class="headerlink" title="ID数据块（ID Datablocks）"></a>ID数据块（ID Datablocks）</h1><p>对象（objects）、网格（meshes）、材料（materials）、场景（scenes），它们都是ID数据块的例子。它们通常定义在头文件<code>DNA_&#123;some type&#125;_typed.h</code>中。</p><p>ID数据块是以一组公共属性开始的内存块。在C中，它被定义为结构体，并且会嵌入一个ID结构体类型作为第一个字段。如果它有存放动画数据的动画数据结构体，则这个动画数据结构体会是第二个字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Mesh &#123;</span><br><span class="line">  ID id;</span><br><span class="line">  struct AnimData *adt;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据块的名称（pointer-&gt;id.name）标识了数据块的类型。举个例子，一个Blender用户界面中显示的网格，它叫“Suzanne”，但在数据块中实际叫“MESuzanne”。可以使用<code>ID *id</code>得到正确的类型。函数<code>GS(id-&gt;name)</code>可以获取名称对应的ID数据类型常量——<code>if (GS(id-&gt;name) == ID_SC) ...</code>，可以用于检测场景中ID数据块。</p><h2 id="ID数据类型的运行时注册（Runtime-Registration-of-ID-Types）"><a href="#ID数据类型的运行时注册（Runtime-Registration-of-ID-Types）" class="headerlink" title="ID数据类型的运行时注册（Runtime Registration of ID Types）"></a>ID数据类型的运行时注册（Runtime Registration of ID Types）</h2><p>2020年以前，ID数据块类型在Blender中是硬编码的。作为“代码清理日” 的一部分，它被转换成运行时的数据结构。本节介绍ID数据块类型新的注册方法。</p><p>运行时类型信息存储在结构体<code>IDTypeInfo</code>中。它包含结构体的元数据，以及一些指向通用函数的指针（创建、拷贝、删除、本地化等等）。下面举个例子，用于实现一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">IDTypeInfo IDType_ID_OB &#x3D; &#123;</span><br><span class="line">    .id_code &#x3D; ID_OB,</span><br><span class="line">    .id_filter &#x3D; FILTER_ID_OB,</span><br><span class="line">    .main_listbase_index &#x3D; INDEX_ID_OB,</span><br><span class="line">    .struct_size &#x3D; sizeof(Object),</span><br><span class="line">    .name &#x3D; &quot;Object&quot;,</span><br><span class="line">    .name_plural &#x3D; &quot;objects&quot;,</span><br><span class="line">    .translation_context &#x3D; BLT_I18NCONTEXT_ID_OBJECT,</span><br><span class="line">    .flags &#x3D; 0,</span><br><span class="line"></span><br><span class="line">    .init_data &#x3D; object_init_data,</span><br><span class="line">    .copy_data &#x3D; object_copy_data,</span><br><span class="line">    .free_data &#x3D; object_free_data,</span><br><span class="line">    .make_local &#x3D; object_make_local,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="添加一个新的ID数据块类型（Adding-a-new-ID-Type）"><a href="#添加一个新的ID数据块类型（Adding-a-new-ID-Type）" class="headerlink" title="添加一个新的ID数据块类型（Adding a new ID Type）"></a>添加一个新的ID数据块类型（Adding a new ID Type）</h2><p>要添加一个新的<code>IDTypeInfo</code>，你需要：</p><ul><li><p>在相关BKE的实现文件（比如ID_ME的实现文件是mesh.c）中定义<code>IDTypeInfo</code>。</p><ul><li><p>在该文件的开头添加静态回调函数和<code>IDTypeInfo</code>结构体定义。</p></li><li><p>如果你需要额外的帮手，只添加它们的前置声明，然后在它们的定义下方实现它们。这使得每个ID数据块类型实现文件的公共信息和特定API分离。</p></li><li><p>这个新的<code>IDTypeInfo</code>应该根据它的识别码来命名。</p></li></ul></li><li><p>在文件<code>BKE_idtype.h</code>中为这个新的ID数据块类型添加extern声明。</p></li><li><p>在文件<code>idtype.c</code>中调用函数<code>id_type_init()</code>来注册这个新的<code>IDTypeInfo</code>。</p></li></ul><h2 id="处理ID数据块类型的函数（Functions-for-Handling-ID-Types）"><a href="#处理ID数据块类型的函数（Functions-for-Handling-ID-Types）" class="headerlink" title="处理ID数据块类型的函数（Functions for Handling ID Types）"></a>处理ID数据块类型的函数（Functions for Handling ID Types）</h2><p>这里有有各种各样的函数可用于ID数据块。在这里列出来必然会出现过时的情况，所以只需阅读文件<code>BKE_idtype.h</code>即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Architecture/ID&quot;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——Dependency Graph</title>
    <link href="https://www.chaguake.com/2021/05/08/Blender-source-code-study-05/"/>
    <id>https://www.chaguake.com/2021/05/08/Blender-source-code-study-05/</id>
    <published>2021-05-08T07:18:14.000Z</published>
    <updated>2021-05-08T09:48:34.391Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Depsgraph">这里</a></p><hr><h1 id="Blender-2-8：依赖关系图"><a href="#Blender-2-8：依赖关系图" class="headerlink" title="Blender 2.8：依赖关系图"></a>Blender 2.8：依赖关系图</h1><blockquote><p>本文档涵盖了依赖关系图的所有设计规范，以支持Blender 2.8项目的所有新功能。</p></blockquote><h2 id="简介（Introduction）"><a href="#简介（Introduction）" class="headerlink" title="简介（Introduction）"></a>简介（Introduction）</h2><p>首先，我们得了解依赖关系图是什么，在任何情况下它应该做什么和不应该做什么。依赖关系图的主要目标是确保场景数据在发生任何更改时，以最有效的方式正确地更新。这意味着依赖关系图只更新依赖于修改后的数值，而不会更新那些没有更改的数据。这样子，艺术家（artists）总是以最大帧更新速率让场景处于有意义的状态。依赖关系图通过预处理场景来实现的——创建一个图，其节点是场景的实体（例如，对象），边则是这些对象之间的关系（例如，当对象A拥有一个父对象B，这个图就有一条处于两个对象之间的边）。</p><p>简单来说，依赖关系图负责场景的动态更新（dynamic updates），其中一些数值随着时间而变化。它不负责一次性的改变（one-time changes）。举个例子，依赖关系图负责f曲线的求值，但不负责网格编辑模式下边的细分操作。</p><h2 id="概述（Overview）"><a href="#概述（Overview）" class="headerlink" title="概述（Overview）"></a>概述（Overview）</h2><p>最新的设计概述相当简单，如下图所示：</p><p><img src="https://wiki.blender.org/w/images/thumb/a/a6/Dev-Blender_2.8_Data_Flow.png/900px-Dev-Blender_2.8_Data_Flow.png" alt=""></p><p>与2.7x系列的差别如下：</p><ul><li><p>DNA数据直接从<code>.blend</code>文件中传递，它简单小巧，只需在外部存储中代表场景。</p></li><li><p>DNA数据没有运行时字段。</p></li><li><p>依赖关系图将所有必需的更改（modifiers, constraints, etc）应用到DNA数据的副本上。我们称它们为生成数据（generated data）。</p></li><li><p>依赖关系图存储自身的评估结果。任何的改变都不会应用到源DNA数据（original DNA）。</p></li><li><p>渲染引擎使用依赖关系图提供的生成数据（generated data），并且不会接触源DNA数据（original DNA）。</p></li><li><p>渲染引擎将具有通用且集中的API，用于存储引擎特定的数据。</p></li></ul><p>这些更改都需要支持像在不同窗口不同状态下实现覆盖和场景这样的特性。它看起来简单，但是它会引导一些重大的设计决定，去尽可能地覆盖所有工具和边缘情况（corner cases）。</p><h2 id="依赖关系图的所有权（Dependency-graph-ownership）"><a href="#依赖关系图的所有权（Dependency-graph-ownership）" class="headerlink" title="依赖关系图的所有权（Dependency graph ownership）"></a>依赖关系图的所有权（Dependency graph ownership）</h2><p>在回答是谁拥有依赖关系图的问题之前，让我们简单地讨论下工作区（workspaces）。</p><p>工作区是组织艺术家（artists）工作流程的一种方式。活动工作区指针存储在每一个窗口（window）中，因此，窗口始终有且仅有一个活动工作区。工作区本身定义了渲染引擎（可以说是与场景渲染引擎相同，但又不完全一样）。工作区还定义了活动场景层（active scene layer），即在工作区编辑器中皆可见。</p><p>这些都是非常重要的声明，理由是渲染引擎和活动场景层都定义了如何去计算对象的最终状态。因此，渲染引擎可以设置一些简单的配置，活动场景层可以拥有覆盖（overrides）。</p><p>这里的决定代表着是窗口（window）拥有依赖关系图（对于交互操作和最终呈现，请看下文）。当艺术家（artists）改变了工作区，或者选择了另一个渲染引擎和场景层，窗口就会被要求重新创建它的依赖关系图，对应新的窗口/工作区状态。</p><p>对于最终的F12渲染所有权则更简单些，依赖关系图由渲染结构拥有。</p><p>通过这个方式，我们尽可能快地对可见数据（visible data）进行场景评估，并支持所有需要上下文关联的覆盖。</p><h2 id="生成数据与写入时复制（Generated-data-and-copy-on-write）"><a href="#生成数据与写入时复制（Generated-data-and-copy-on-write）" class="headerlink" title="生成数据与写入时复制（Generated data and copy on write）"></a>生成数据与写入时复制（Generated data and copy on write）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Depsgraph&quot;&gt;这里&lt;/a</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender官方源码文档——Context</title>
    <link href="https://www.chaguake.com/2021/05/07/Blender-source-code-study-04/"/>
    <id>https://www.chaguake.com/2021/05/07/Blender-source-code-study-04/</id>
    <published>2021-05-07T09:12:07.000Z</published>
    <updated>2021-05-08T09:33:34.842Z</updated>
    
    <content type="html"><![CDATA[<p>最新的官方文档：<a href="https://wiki.blender.org/wiki/Source">目录</a></p><p>本文的原文在<a href="https://wiki.blender.org/wiki/Source/Architecture/Context">这里</a></p><hr><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>在2.5中，bContext结构体被添加进来，作为全局变量的替代品，更明确地去创建上下文（make context）。比如，操作类、Python脚本和绘制代码，它们都能在定义好的上下文（context）中正常使用。</p><p>Blender的上下文（Context）由bContext结构体表示，其API定义在BKE_context.h文件中。获取上下文（context）信息几乎都是使用<code>CTX_data_*</code>或者<code>CTX_wm_*</code>这些类型的函数（它们将bContext结构体对象作为参数），而设置上下文（context）则可以在screens、areas或者regions中懒设置（done lazily）。</p><h1 id="What’s-in-the-context"><a href="#What’s-in-the-context" class="headerlink" title="What’s in the context?"></a>What’s in the context?</h1><p>在以下那张图中，值得注意是，它并不反映谁调用谁，而是反映出有哪些不同类型的数据是在上下文（context）中的。</p><p><img src="https://wiki.blender.org/w/images/5/56/Context_2.5_what.png" alt=""></p><p><code>User Preferences</code>是全局的、且并非是真正意义上的上下文，所有的代码都可以访问它。紧接着是<code>Main</code>，是一个拥有自己数据块的<code>.blend</code>文件，还包括了相关联的<code>.blend</code>文件的数据块。我们应该假设有很多个这样子的文件同时被打开，但现在还未能实现。</p><p>接下来出现了分歧，绘制（drawing）和交互式编辑代码（interactive editing code）可假设是跑在<code>Window Manager</code>下。他们总是工作在某一层级（Screen、Area或者Region）中。随着这些层级有了一定的数据，屏幕（the screen）就会拥有一个活动场景（active Scene），并且区域（areas and regions）可以额外地将其他的数据放进上下文（context），当然，这取决于区域的类型。</p><p>此外，我们有一些代码不能设定是窗口管理（window manager）控制的。但也不意味着它们不能被窗口管理调用，只是表示这些代码不属于窗口管理，也不需要使用窗口管理的方式调用它。这些代码可以不需要窗口选项而直接在后台运行，通常是用于渲染（rendering）、求值（Evalution）。渲染通常是通过一个场景和一些不在bContext结构体中的数据。</p><p>文件读写、内核函数以及窗口管理代码这些并没有显示在图中。但事实上，它们或多或少都存在上下文中，或者根本不包含在上下文指针中。</p><h1 id="Setting-Context"><a href="#Setting-Context" class="headerlink" title="Setting Context"></a>Setting Context</h1><p>首先我们得知道上下文（context）并不是持久化的。如果你想改变一个活动物体（active object），并非是通过上下文（context）设置它来实现。应当在场景（Scene）中设置对应的属性，然后再在上下文（context）中查找使用。上下文是进行操作（operator）或者绘制（drawing）时的临时本地状态。</p><p><strong>Callbacks</strong></p><p>上下文（context）主要由回调（callbacks）组成。屏幕（the Scene）、空间类型（space types）和区域类型（region types）都拥有一个上下文回调函数。这个函数接受一个上下文成员的名称，然后检查这个上下文是否知道这个成员，如果有，则返回一个RNA指针或者一个RNA指针集合。另外，每一个上下文回调都应该提供一个上下文成员列表。</p><p>举个例子，一个图片窗口空间类型的回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int image_context(const bContext *C, const char *member, bContextDataResult *result)</span><br><span class="line">&#123;</span><br><span class="line">    SpaceImage *sima&#x3D; CTX_wm_space_image(C);</span><br><span class="line"></span><br><span class="line">    if(CTX_data_dir(member)) &#123;</span><br><span class="line">        static const char *dir[] &#x3D; &#123;&quot;edit_image&quot;, NULL&#125;;</span><br><span class="line">        CTX_data_dir_set(result, dir);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(CTX_data_equals(member, &quot;edit_image&quot;)) &#123;</span><br><span class="line">        CTX_data_id_pointer_set(result, (ID*)ED_space_image(sima));</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UI Layouts</strong></p><p>此外，还可以为UI布局指定更具体的上下文。主要用于修改器（modifiers）或者约束（constraints）。对于每一个修改器UI布局箱（modifier UI layout box），“修改器”设置进上下文，然后所有来自这个UI布局箱按钮的操作都可以从它的上下文中找到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.set_context_pointer(&quot;group&quot;, group)</span><br></pre></td></tr></table></figure><p><strong>Lookups</strong></p><p>当一个上下文成员被请求，UI布局的上下文首先会被查找，接下来是区域回调（region callback,area callback）和屏幕回调（screen callback）。如果它被找到，就会返回对应的指针，假如找不到，则会返回一个空指针或者空集合。</p><p><img src="https://wiki.blender.org/w/images/thumb/0/06/Context_2.5_setting.png/640px-Context_2.5_setting.png" alt=""></p><h1 id="Getting-Context"><a href="#Getting-Context" class="headerlink" title="Getting Context"></a>Getting Context</h1><p><strong>Window Manager</strong></p><p>窗口管理上下文是最简单的，它仅仅是一些screen、area、space data、region和region data的指针。主要是你得确保它们应该被包含在上下文中。对于绘制函数，它们是相当清晰的，对于操作函数，在<code>poll</code>函数中进行检查或者在运行时验证是很重要的。如果不这样子做，用于在使用配置密钥映射时会导致崩溃。</p><p><strong>Data</strong></p><p>数据上下文就比较复杂了，重要的一点是要理解它是基于RNA指针集合的。这也可以使得python脚本自动用得了上下文。</p><p>在C中有两种方法去获取上下文的数据。某些访问器早已定义。请注意，在内部依旧是使用“edit_object”字符串来获取值，毕竟这很方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object *obedit&#x3D; CTX_data_edit_object(C);</span><br></pre></td></tr></table></figure><p>其它的那些可能没被定义，需要使用字符串去查找上下文成员。这并不能确保数据类型是正确的，所以需要指定想要的数据类型。下面例子返回一个RNA指针（注意看函数后面的<code>.data</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object *obedit&#x3D; CTX_data_pointer_get_type(C, &quot;edit_object&quot;, &amp;RNA_Object).data;</span><br></pre></td></tr></table></figure><p>在Python中更简单了，上下文的成员相当于它的属性（properties）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obedit &#x3D; context.object_edit</span><br></pre></td></tr></table></figure><p>集合（collections）也可以使用的，使用内部提供的宏会更加便捷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CTX_DATA_BEGIN(C, Base*, base, selected_editable_bases) &#123;</span><br><span class="line">    printf(&quot;object: %s\n&quot;, base-&gt;object-&gt;id.name);</span><br><span class="line">&#125;</span><br><span class="line">CTX_DATA_END;</span><br></pre></td></tr></table></figure><p><strong>Where to look</strong></p><p>并没有一个地方可以看到列表中所有的上下文成员。但可以找到某一个上下文成员，最好的方法是查找其相关的回调。也就是说，如果你正在使用图片窗口（image window），可以在<code>space_image.c</code>文件中查找上下文回调函数。</p><p>在Python中，可以实时地查找上下文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dir(context))</span><br></pre></td></tr></table></figure><p><strong>Always Available</strong></p><p>一些上下文成员总是被设置，它们不需要使用<code>poll</code>函数去检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CTX_wm_manager</span><br><span class="line">CTX_wm_window</span><br><span class="line">CTX_wm_screen</span><br><span class="line"></span><br><span class="line">CTX_data_main</span><br><span class="line">CTX_data_scene</span><br><span class="line">CTX_data_tool_settings</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>更多的信息，可以在以下的文件中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source&#x2F;blender&#x2F;blenkernel&#x2F;BKE_context.h</span><br><span class="line">source&#x2F;blender&#x2F;blenkernel&#x2F;intern&#x2F;context.c</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最新的官方文档：&lt;a href=&quot;https://wiki.blender.org/wiki/Source&quot;&gt;目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文的原文在&lt;a href=&quot;https://wiki.blender.org/wiki/Source/Architecture/Con</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（三）——Blender工具窗口和控件实现的调用过程</title>
    <link href="https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/"/>
    <id>https://www.chaguake.com/2021/04/30/Blender-source-code-study-03/</id>
    <published>2021-04-30T09:27:17.000Z</published>
    <updated>2021-05-08T09:33:59.372Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/">Blender源码学习（一）——blender项目，Blender main()入口</a>一文中讲解了Blender工具的程序入口，以及在文章末尾给出Blender源码层级布局。</p><p>Blender工具涉及的模块很多，可以从“窗口是如何做到跨平台实现”这一点作为切入点，先学习工具的“骨架”，然后再学习其他各个模块的实现。</p><h1 id="涉及模块"><a href="#涉及模块" class="headerlink" title="涉及模块"></a>涉及模块</h1><p><strong>ghost</strong></p><p>ghost位于<code>intern</code>目录下，是blender标准的跨平台操作系统工具（Stands for General Handy Operating System Toolkit）。</p><p>ghost主要负责窗口管理行为（window management actions）、OpenGL上下文和鼠标键盘事件（也包括一些不常见的硬件设备），底层使用继承多态方式实现调用对应操作系统的API。</p><p>值得注意的是，ghost是C++编写的，而blender是C编写的，所以ghost封装了一层，满足C调用C++代码的需求。</p><p><strong>windowmanager</strong></p><p>windowmanager位于<code>source/blender</code>目录下，负责blender窗口管理、事件系统、操作管理、线程管理等，作为窗口和功能的逻辑调度者。</p><p><strong>editors</strong></p><p>editors位于<code>source/blender</code>目录下，负责图形、工具和图形的绘制。</p><h1 id="窗口实现流程"><a href="#窗口实现流程" class="headerlink" title="窗口实现流程"></a>窗口实现流程</h1><p>Blender工具实现主要分两个部分，第一部分是用ghost创建的窗口（window），另一部分是使用OpenGL绘制的屏幕（screen）。</p><p>前者是框架，使用操作系统API创建的空白窗口；后者是内容，使用OpenGL的glew库绘制。</p><p><strong>ghost窗口</strong></p><p>调用路径如下：</p><p>main函数（creator.c） -&gt; WM_init函数（wm_init_exit.c） -&gt; wm_homefile_read函数（wm_files.c） -&gt; WM_check函数（wm.c） -&gt; wm_window_ghostwindows_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_ensure函数（wm_window.c） -&gt; wm_window_ghostwindow_add（wm_window.c） -&gt; GHOST_CreateWindow函数。</p><p><strong>screen</strong></p><p>调用路径如下：</p><p>main函数（creator.c） -&gt; WM_main函数（wm.c） -&gt; wm_window_process_events函数（wm_window.c） -&gt; GHOST_DispatchEvents函数（GHOST_C-api.cpp） -&gt; dispatchEvents函数（GHOST_System.cpp） -&gt; dispatchEvents函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; dispatchEvent函数（GHOST_EventManager.cpp） -&gt; processEvent函数 -&gt; ghost_event_proc函数（wm_window.c）-&gt; wm_draw_update（wm_window.c） -&gt; wm_draw_window函数（wm_draw.c）···。</p><p>到<code>wm_draw_update</code>这一步的时候，<code>wm_draw_window</code>函数实现窗口绘制，<code>wm_window_swap_buffers</code>函数实现双缓冲，交换前后台数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void wm_draw_update(bContext *C)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  wm_draw_window(C, win);</span><br><span class="line">  wm_draw_update_clear_window(C, win);</span><br><span class="line">  wm_window_swap_buffers(win);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wm_draw_window</code>函数有两个操作，首先将所有的regions绘制出来，然后再把regions绘制在screen中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void wm_draw_window(bContext *C, wmWindow *win)</span><br><span class="line">&#123;</span><br><span class="line">  bScreen *screen &#x3D; WM_window_get_active_screen(win);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;* Draw area regions into their own framebuffer. This way we can redraw</span><br><span class="line">   * the areas that need it, and blit the rest from existing framebuffers. *&#x2F;</span><br><span class="line">  wm_draw_window_offscreen(C, win, stereo);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &#x2F;* Now we draw into the window framebuffer, in full window coordinates. *&#x2F;</span><br><span class="line">  wm_draw_window_onscreen(C, win, -1);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="What’s-in-the-context"><a href="#What’s-in-the-context" class="headerlink" title="What’s in the context?"></a>What’s in the context?</h1><p><a href="https://wiki.blender.org/wiki/Source/Architecture/Context">官方文档</a></p><p><img src="https://wiki.blender.org/w/images/5/56/Context_2.5_what.png" alt="What&#39;s in the context"></p><p>上面图片展示了Blender模块之间的层级关系。</p><p>最顶层<code>User Preferences</code>为Main函数中创建的全局的bContext对象。</p><p>第二层<code>Main</code>表示一个<code>.blender</code>文件数据，包含其关联的其他<code>.blender</code>文件。</p><p>接下来分成两大块——<code>Window Manager</code>和<code>Scene</code>，前者负责窗口事件一类，后者负责场景数据块和渲染，这一类的操作数据可以不经过bContext进行数据传递。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/&quot;&gt;Blender源码学习（一）——blender项目，Blender main()入口&lt;/a&gt;一文中讲解了Blender工</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（二）——一些重要的结构体</title>
    <link href="https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/"/>
    <id>https://www.chaguake.com/2021/04/30/Blender-source-code-study-02/</id>
    <published>2021-04-30T02:35:03.000Z</published>
    <updated>2021-05-07T08:28:12.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bContext结构体"><a href="#bContext结构体" class="headerlink" title="bContext结构体"></a>bContext结构体</h1><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;context.c</span><br><span class="line">struct bContext &#123;</span><br><span class="line">  int thread;</span><br><span class="line"></span><br><span class="line">  &#x2F;* windowmanager context *&#x2F;</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct wmWindowManager *manager;</span><br><span class="line">    struct wmWindow *window;</span><br><span class="line">    struct WorkSpace *workspace;</span><br><span class="line">    struct bScreen *screen;</span><br><span class="line">    struct ScrArea *area;</span><br><span class="line">    struct ARegion *region;</span><br><span class="line">    struct ARegion *menu;</span><br><span class="line">    struct wmGizmoGroup *gizmo_group;</span><br><span class="line">    struct bContextStore *store;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Operator poll. *&#x2F;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Store the reason the poll function fails (static string, not allocated).</span><br><span class="line">     * For more advanced formatting use &#96;operator_poll_msg_dyn_params&#96;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    const char *operator_poll_msg;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Store values to dynamically to create the string (called when a tool-tip is shown).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    struct bContextPollMsgDyn_Params operator_poll_msg_dyn_params;</span><br><span class="line">  &#125; wm;</span><br><span class="line"></span><br><span class="line">  &#x2F;* data context *&#x2F;</span><br><span class="line">  struct &#123;</span><br><span class="line">    struct Main *main;</span><br><span class="line">    struct Scene *scene;</span><br><span class="line"></span><br><span class="line">    int recursion;</span><br><span class="line">    &#x2F;** True if python is initialized. *&#x2F;</span><br><span class="line">    bool py_init;</span><br><span class="line">    void *py_context;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * If we need to remove members, do so in a copy</span><br><span class="line">     * (keep this to check if the copy needs freeing).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void *py_context_orig;</span><br><span class="line">  &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bContext结构体是Blender程序的上下文（整个程序只有一个），包含窗口管理者上下文（windowmanager context）和数据上下文（data context）。</p><p>bContext结构体中的对象通常使用<code>CTX_data_*</code>和<code>CTX_wm_*</code>函数中获取，并且其参数通常是延迟初始化。</p><p>bContext结构体对象在<code>creator.c</code>文件的<code>main</code>函数中创建，在<code>main</code>函数中使用情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">bContext *C;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">C &#x3D; CTX_create();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">main_args_setup(C, ba);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WM_init(C, argc, (const char **)argv);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CTX_py_init_set(C, true);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">WM_keyconfig_init(C);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">FRS_set_context(C);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">main_args_setup_post(C, ba);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#ifndef WITH_PYTHON_MODULE</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F;</span><br><span class="line">    WM_exit(C);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (!G.file_loaded) &#123;</span><br><span class="line">      WM_init_splash(C);</span><br><span class="line">    &#125;</span><br><span class="line">    WM_main(C);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h1><p><strong>定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BKE_global.h</span><br><span class="line">typedef struct Global &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Active pointers. *&#x2F;</span><br><span class="line">  struct Main *main;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Strings: last saved *&#x2F;</span><br><span class="line">  char ima[1024], lib[1024]; &#x2F;* 1024 &#x3D; FILE_MAX *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;** When set: &#96;G_MAIN-&gt;name&#96; contains valid relative base path. *&#x2F;</span><br><span class="line">  bool relbase_valid;</span><br><span class="line">  bool file_loaded;</span><br><span class="line">  bool save_over;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Strings of recent opened files. *&#x2F;</span><br><span class="line">  struct ListBase recent_files;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Has escape been pressed or Ctrl+C pressed in background mode, used for render quit. *&#x2F;</span><br><span class="line">  bool is_break;</span><br><span class="line"></span><br><span class="line">  bool background;</span><br><span class="line">  bool factory_startup;</span><br><span class="line"></span><br><span class="line">  short moving;</span><br><span class="line"></span><br><span class="line">  &#x2F;** To indicate render is busy, prevent render-window events etc. *&#x2F;</span><br><span class="line">  bool is_rendering;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Debug value, can be set from the UI and python, used for testing nonstandard features.</span><br><span class="line">   * DO NOT abuse it with generic checks like &#96;if (G.debug_value &gt; 0)&#96;. Do not use it as bitflags.</span><br><span class="line">   * Only precise specific values should be checked for, to avoid unpredictable side-effects.</span><br><span class="line">   * Please document here the value(s) you are using (or a range of values reserved to some area).</span><br><span class="line">   *   * -16384 and below: Reserved for python (add-ons) usage.</span><br><span class="line">   *   *     -1: Disable faster motion paths computation (since 08&#x2F;2018).</span><br><span class="line">   *   * 1 - 30: EEVEE debug&#x2F;stats values (01&#x2F;2018).</span><br><span class="line">   *   *    101: Enable UI debug drawing of fullscreen area&#39;s corner widget (10&#x2F;2014).</span><br><span class="line">   *   *    666: Use quicker batch delete for outliners&#39; delete hierarchy (01&#x2F;2019).</span><br><span class="line">   *   *    777: Enable UI node panel&#39;s sockets polling (11&#x2F;2011).</span><br><span class="line">   *   *    799: Enable some mysterious new depsgraph behavior (05&#x2F;2015).</span><br><span class="line">   *   *   1112: Disable new Cloth internal springs handling (09&#x2F;2014).</span><br><span class="line">   *   *   1234: Disable new dyntopo code fixing skinny faces generation (04&#x2F;2015).</span><br><span class="line">   *   *   3001: Enable additional Fluid modifier (Mantaflow) options (02&#x2F;2020).</span><br><span class="line">   *   *   4000: Line Art state output and debugging logs (03&#x2F;2021).</span><br><span class="line">   *   * 16384 and above: Reserved for python (add-ons) usage.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  short debug_value;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Saved to the blend file as #FileGlobal.globalf,</span><br><span class="line">   * however this is now only used for runtime options. *&#x2F;</span><br><span class="line">  int f;</span><br><span class="line"></span><br><span class="line">  struct &#123;</span><br><span class="line">    &#x2F;** Logging vars (different loggers may use). *&#x2F;</span><br><span class="line">    int level;</span><br><span class="line">    &#x2F;** FILE handle or use stderr (we own this so close when done). *&#x2F;</span><br><span class="line">    void *file;</span><br><span class="line">  &#125; log;</span><br><span class="line"></span><br><span class="line">  &#x2F;** debug flag, #G_DEBUG, #G_DEBUG_PYTHON &amp; friends, set python or command line args *&#x2F;</span><br><span class="line">  int debug;</span><br><span class="line"></span><br><span class="line">  &#x2F;** This variable is written to &#x2F; read from #FileGlobal.fileflags *&#x2F;</span><br><span class="line">  int fileflags;</span><br><span class="line"></span><br><span class="line">  &#x2F;** Message to use when auto execution fails. *&#x2F;</span><br><span class="line">  char autoexec_fail[200];</span><br><span class="line">&#125; Global;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;blender.c</span><br><span class="line">Global G;</span><br></pre></td></tr></table></figure><p>Global结构体主要是存放一些全局定义的变量、处于激活状态的节点（Active pointers）对象指针以及已经打开的文件链表（Strings of recent opened files）对象指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bContext结构体&quot;&gt;&lt;a href=&quot;#bContext结构体&quot; class=&quot;headerlink&quot; title=&quot;bContext结构体&quot;&gt;&lt;/a&gt;bContext结构体&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Blender源码学习（一）——blender项目，Blender main()入口</title>
    <link href="https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/"/>
    <id>https://www.chaguake.com/2021/04/29/Blender-source-code-study-01/</id>
    <published>2021-04-29T02:52:14.000Z</published>
    <updated>2021-04-30T01:32:20.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blender项目概括"><a href="#blender项目概括" class="headerlink" title="blender项目概括"></a>blender项目概括</h1><p>blender项目是Blender整个工程的入口，该项目输出文件为<code>blender.exe</code>。</p><p>blender项目位于<code>/blender/source/creator</code>目录下，文件只有几个：<code>creator_intern.h</code>、<code>buildinfo.c</code>、<code>creator.c</code>、<code>creator_args.c</code>、<code>creator_signals.c</code>。</p><p>其中，<code>creator.c</code>是关键文件，而其主要是包含一个<code>main</code>函数。</p><p><code>main</code>函数主要工作是：</p><ul><li><p>解析启动参数</p></li><li><p>根据启动参数启动各个子系统</p></li><li><p>检查是否后台运行，如果是，则使用Less-UI后台运行，否则，使用Use-UI运行。</p></li></ul><p>主要的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Blender&#39;s main function responsibilities are:</span><br><span class="line"> * - setup subsystems.</span><br><span class="line"> * - handle arguments.</span><br><span class="line"> * - run #WM_main() event loop,</span><br><span class="line"> *   or exit immediately when running in background-mode.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int argc,</span><br><span class="line">#ifdef WIN32</span><br><span class="line">         const char **UNUSED(argv_c)</span><br><span class="line">#else</span><br><span class="line">         const char **argv</span><br><span class="line">#endif</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  bContext *C;</span><br><span class="line">    </span><br><span class="line">  &#x2F;* Ensure we free data on early-exit. *&#x2F;</span><br><span class="line">  struct CreatorAtExitData app_init_data &#x3D; &#123;NULL&#125;;</span><br><span class="line">  BKE_blender_atexit_register(callback_main_atexit, &amp;app_init_data);</span><br><span class="line"></span><br><span class="line">  &#x2F;* NOTE: Special exception for guarded allocator type switch:</span><br><span class="line">   *       we need to perform switch from lock-free to fully</span><br><span class="line">   *       guarded allocator before any allocation happened.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; argc; i++) &#123;</span><br><span class="line">      if (STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)) &#123;</span><br><span class="line">        printf(&quot;Switching to fully guarded memory allocator.\n&quot;);</span><br><span class="line">        MEM_use_guarded_allocator();&#x2F;&#x2F;使用守卫式内存分配器</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      if (STREQ(argv[i], &quot;--&quot;)) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MEM_init_memleak_detection();&#x2F;&#x2F;初始化内存检测模块</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Initialize logging. *&#x2F;</span><br><span class="line">  CLG_init();</span><br><span class="line">  CLG_fatal_fn_set(callback_clg_fatal);</span><br><span class="line"></span><br><span class="line">  C &#x3D; CTX_create();  </span><br><span class="line"></span><br><span class="line">#ifdef WITH_LIBMV &#x2F;&#x2F;libmv为多视图重建库（LMV），是Blender运动跟踪能力的计算机视觉后端。</span><br><span class="line">  libmv_initLogging(argv[0]);</span><br><span class="line">#elif defined(WITH_CYCLES_LOGGING)</span><br><span class="line">  CCL_init_logging(argv[0]);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* Error output from the guarded allocation routines. *&#x2F;</span><br><span class="line">  main_callback_setup();</span><br><span class="line"></span><br><span class="line">  &#x2F;*start initialize subsystem*&#x2F;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;*end initialiize subsystem*&#x2F;</span><br><span class="line"></span><br><span class="line">#if defined(WITH_PYTHON_MODULE) || defined(WITH_HEADLESS)</span><br><span class="line">  &#x2F;* Python module mode ALWAYS runs in background-mode (for now). *&#x2F;</span><br><span class="line">  G.background &#x3D; true;</span><br><span class="line">#else</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    main_signal_setup_background();</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  &#x2F;* Background render uses this font too. *&#x2F;</span><br><span class="line">  BKE_vfont_builtin_register(datatoc_bfont_pfb, datatoc_bfont_pfb_size);</span><br><span class="line"></span><br><span class="line">  &#x2F;* Explicitly free data allocated for argument parsing:</span><br><span class="line">   * - &#39;ba&#39;</span><br><span class="line">   * - &#39;argv&#39; on WIN32.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  callback_main_atexit(&amp;app_init_data);</span><br><span class="line">  BKE_blender_atexit_unregister(callback_main_atexit, &amp;app_init_data);</span><br><span class="line"></span><br><span class="line">  &#x2F;* End argument parsing, allow memory leaks to be printed. *&#x2F;</span><br><span class="line">  MEM_use_memleak_detection(true);</span><br><span class="line"></span><br><span class="line">#ifndef WITH_PYTHON_MODULE</span><br><span class="line">  if (G.background) &#123;</span><br><span class="line">    &#x2F;* Using window-manager API in background-mode is a bit odd, but works fine. *&#x2F;</span><br><span class="line">    WM_exit(C);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (!G.file_loaded) &#123;</span><br><span class="line">      WM_init_splash(C);</span><br><span class="line">    &#125;</span><br><span class="line">    WM_main(C);</span><br><span class="line">  &#125;</span><br><span class="line">#endif &#x2F;* WITH_PYTHON_MODULE *&#x2F;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="1、UNUSED宏"><a href="#1、UNUSED宏" class="headerlink" title="1、UNUSED宏"></a>1、UNUSED宏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BLI_memory_utils.h</span><br><span class="line">&#x2F;* UNUSED macro, for function argument *&#x2F;</span><br><span class="line">#if defined(__GNUC__) || defined(__clang__)</span><br><span class="line">#  define UNUSED(x) UNUSED_##x __attribute__((__unused__))</span><br><span class="line">#else</span><br><span class="line">#  define UNUSED(x) UNUSED_##x</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(__GNUC__) || defined(__clang__)</span><br><span class="line">#  define UNUSED_FUNCTION(x) __attribute__((__unused__)) UNUSED_##x</span><br><span class="line">#else</span><br><span class="line">#  define UNUSED_FUNCTION(x) UNUSED_##x</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">int main(int argc,</span><br><span class="line">#ifdef WIN32</span><br><span class="line">         const char **UNUSED(argv_c)</span><br><span class="line">#else</span><br><span class="line">         const char **argv</span><br><span class="line">#endif</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在<code>main</code>函数中使用了GNU C 的一个特性——<code>__attribute__((__unused__))</code>，用于编译时忽略未使用的警告。</p><h2 id="2、setvbuf-stdout-NULL-IONBF-0"><a href="#2、setvbuf-stdout-NULL-IONBF-0" class="headerlink" title="2、setvbuf(stdout, NULL, _IONBF, 0)"></a>2、setvbuf(stdout, NULL, _IONBF, 0)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">  &#x2F;* Un-buffered &#96;stdout&#96; makes &#96;stdout&#96; and &#96;stderr&#96; better synchronized, and helps</span><br><span class="line">   * when stepping through code in a debugger (prints are immediately</span><br><span class="line">   * visible). However disabling buffering causes lock contention on windows</span><br><span class="line">   * see T76767 for details, since this is a debugging aid, we do not enable</span><br><span class="line">   * the un-buffered behavior for release builds. *&#x2F;</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">  setvbuf(stdout, NULL, _IONBF, 0);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>使用<code>setvbuf</code>函数将输出缓冲去掉，信息可以更快的同步。</p><h2 id="3、-putenv-s函数"><a href="#3、-putenv-s函数" class="headerlink" title="3、_putenv_s函数"></a>3、_putenv_s函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  if defined(_MSC_VER)</span><br><span class="line">  _putenv_s(&quot;OMP_WAIT_POLICY&quot;, &quot;PASSIVE&quot;);&#x2F;&#x2F;添加程序的环境变量</span><br><span class="line">#  endif</span><br></pre></td></tr></table></figure><p><code>_putenv_s</code>函数可添加程序的环境变量（并非加在电脑全局环境变量中），对应获取程序的环境变量的函数是<code>getenv_s</code>。</p><h2 id="4、宏实现N个参数同时对比"><a href="#4、宏实现N个参数同时对比" class="headerlink" title="4、宏实现N个参数同时对比"></a>4、宏实现N个参数同时对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;BLI_utildefines_variadic.h</span><br><span class="line">#define _VA_NARGS_GLUE(x, y) x y</span><br><span class="line">#define _VA_NARGS_RETURN_COUNT(\</span><br><span class="line">  _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _10_, _11_, _12_, _13_, _14_, _15_, _16_, \</span><br><span class="line">  _17_, _18_, _19_, _20_, _21_, _22_, _23_, _24_, _25_, _26_, _27_, _28_, _29_, _30_, _31_, _32_, \</span><br><span class="line">  _33_, _34_, _35_, _36_, _37_, _38_, _39_, _40_, _41_, _42_, _43_, _44_, _45_, _46_, _47_, _48_, \</span><br><span class="line">  _49_, _50_, _51_, _52_, _53_, _54_, _55_, _56_, _57_, _58_, _59_, _60_, _61_, _62_, _63_, _64_, \</span><br><span class="line">  count, ...) count</span><br><span class="line">#define _VA_NARGS_EXPAND(args) _VA_NARGS_RETURN_COUNT args</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO2(name, count) name##count</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO1(name, count) _VA_NARGS_OVERLOAD_MACRO2(name, count)</span><br><span class="line">#define _VA_NARGS_OVERLOAD_MACRO(name,  count) _VA_NARGS_OVERLOAD_MACRO1(name, count)</span><br><span class="line">&#x2F;* --- expose for re-use --- *&#x2F;</span><br><span class="line">&#x2F;* 64 args max *&#x2F;</span><br><span class="line">#define VA_NARGS_COUNT(...) _VA_NARGS_EXPAND((__VA_ARGS__, \</span><br><span class="line">  64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, \</span><br><span class="line">  48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, \</span><br><span class="line">  32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, \</span><br><span class="line">  16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2, 1, 0))</span><br><span class="line">#define VA_NARGS_CALL_OVERLOAD(name, ...) \</span><br><span class="line">  _VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;BLI_string.h</span><br><span class="line">&#x2F;* Manual line breaks for readability. *&#x2F;</span><br><span class="line">&#x2F;* clang-format off *&#x2F;</span><br><span class="line">&#x2F;* STR_ELEM#(v, ...): is the first arg equal any others? *&#x2F;</span><br><span class="line">&#x2F;* Internal helpers. *&#x2F;</span><br><span class="line">#define _VA_STR_ELEM2(v, a) (strcmp(v, a) &#x3D;&#x3D; 0)</span><br><span class="line">#define _VA_STR_ELEM3(v, a, b) \</span><br><span class="line">  (_VA_STR_ELEM2(v, a) || (_VA_STR_ELEM2(v, b)))</span><br><span class="line">#define _VA_STR_ELEM4(v, a, b, c) \</span><br><span class="line">  (_VA_STR_ELEM3(v, a, b) || (_VA_STR_ELEM2(v, c)))</span><br><span class="line">#define _VA_STR_ELEM5(v, a, b, c, d) \</span><br><span class="line">  (_VA_STR_ELEM4(v, a, b, c) || (_VA_STR_ELEM2(v, d)))</span><br><span class="line">#define _VA_STR_ELEM6(v, a, b, c, d, e) \</span><br><span class="line">  (_VA_STR_ELEM5(v, a, b, c, d) || (_VA_STR_ELEM2(v, e)))</span><br><span class="line">#define _VA_STR_ELEM7(v, a, b, c, d, e, f) \</span><br><span class="line">  (_VA_STR_ELEM6(v, a, b, c, d, e) || (_VA_STR_ELEM2(v, f)))</span><br><span class="line">#define _VA_STR_ELEM8(v, a, b, c, d, e, f, g) \</span><br><span class="line">  (_VA_STR_ELEM7(v, a, b, c, d, e, f) || (_VA_STR_ELEM2(v, g)))</span><br><span class="line">#define _VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) \</span><br><span class="line">  (_VA_STR_ELEM8(v, a, b, c, d, e, f, g) || (_VA_STR_ELEM2(v, h)))</span><br><span class="line">#define _VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) \</span><br><span class="line">  (_VA_STR_ELEM9(v, a, b, c, d, e, f, g, h) || (_VA_STR_ELEM2(v, i)))</span><br><span class="line">#define _VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) \</span><br><span class="line">  (_VA_STR_ELEM10(v, a, b, c, d, e, f, g, h, i) || (_VA_STR_ELEM2(v, j)))</span><br><span class="line">#define _VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) \</span><br><span class="line">  (_VA_STR_ELEM11(v, a, b, c, d, e, f, g, h, i, j) || (_VA_STR_ELEM2(v, k)))</span><br><span class="line">#define _VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) \</span><br><span class="line">  (_VA_STR_ELEM12(v, a, b, c, d, e, f, g, h, i, j, k) || (_VA_STR_ELEM2(v, l)))</span><br><span class="line">#define _VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) \</span><br><span class="line">  (_VA_STR_ELEM13(v, a, b, c, d, e, f, g, h, i, j, k, l) || (_VA_STR_ELEM2(v, m)))</span><br><span class="line">#define _VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) \</span><br><span class="line">  (_VA_STR_ELEM14(v, a, b, c, d, e, f, g, h, i, j, k, l, m) || (_VA_STR_ELEM2(v, n)))</span><br><span class="line">#define _VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) \</span><br><span class="line">  (_VA_STR_ELEM15(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n) || (_VA_STR_ELEM2(v, o)))</span><br><span class="line">#define _VA_STR_ELEM17(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) \</span><br><span class="line">  (_VA_STR_ELEM16(v, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) || (_VA_STR_ELEM2(v, p)))</span><br><span class="line">&#x2F;* clang-format on *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* reusable STR_ELEM macro *&#x2F;</span><br><span class="line">#define STR_ELEM(...) VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;creator.c</span><br><span class="line">STR_ELEM(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)</span><br></pre></td></tr></table></figure><p><code>STR_ELEM</code>宏实现了第一个参数与其他每个参数对比的能力，最后一层宏为<code>_VA_STR_ELEM5(argv[i], &quot;-d&quot;, &quot;--debug&quot;, &quot;--debug-memory&quot;, &quot;--debug-all&quot;)</code>，最终展开为<code>(((strcmp(argv[i], &quot;-d&quot;) == 0) || (strcmp(argv[i], &quot;--debug&quot;) == 0)) || (strcmp(argv[i], &quot;--debug-memory&quot;) == 0)))...</code>。</p><p>这个宏有两个限制，其一是<code>_VA_STR_ELEM</code>系列宏的数量，在源码中只能处理16个参数的对比；其二是<code>VA_NARGS_COUNT</code>和<code>_VA_NARGS_RETURN_COUNT</code>宏枚举的数字，源码中最大值是64，超过64个参数的宏调用会报错。</p><p>下面解释下<code>STR_ELEM</code>宏的展开过程：</p><ul><li><p>首先，<code>STR_ELEM(...)</code>展开成<code>VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</code>，<code>_VA_STR_ELEM</code>是字符串，用于拼接<code>_VA_STR_ELEM</code>系列宏的前缀，<code>__VA_ARGS__</code>为可变参数的宏。</p></li><li><p>然后，<code>VA_NARGS_CALL_OVERLOAD(_VA_STR_ELEM, __VA_ARGS__)</code>展开成<code>_VA_NARGS_GLUE(_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__)), (__VA_ARGS__))</code>，<code>_VA_NARGS_GLUE</code>宏接受两个参数，然后将他们并排拼接（就比如<code>f(x)</code>中的<code>f</code>和<code>(x)</code>）。第一个参数是<code>_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))</code>，第二个参数是<code>(__VA_ARGS__)</code>。</p></li><li><p><code>_VA_NARGS_OVERLOAD_MACRO(name, VA_NARGS_COUNT(__VA_ARGS__))</code>中，<code>_VA_NARGS_OVERLOAD_MACRO</code>和<code>VA_NARGS_COUNT</code>宏的层级是一样的，前者是将参数<code>name</code>和<code>VA_NARGS_COUNT(__VA_ARGS__)</code>拼接，后者返回参数的个数。</p></li></ul><h1 id="Blender-code-layout"><a href="#Blender-code-layout" class="headerlink" title="Blender code layout"></a>Blender code layout</h1><p><img src="https://www.blender.org/bf/codelayout.jpg" alt="Blender code layout"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;blender项目概括&quot;&gt;&lt;a href=&quot;#blender项目概括&quot; class=&quot;headerlink&quot; title=&quot;blender项目概括&quot;&gt;&lt;/a&gt;blender项目概括&lt;/h1&gt;&lt;p&gt;blender项目是Blender整个工程的入口，该项目输出文件为&lt;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender源码" scheme="https://www.chaguake.com/tags/blender%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>blender快捷键汇总</title>
    <link href="https://www.chaguake.com/2021/04/28/blender-hot-key/"/>
    <id>https://www.chaguake.com/2021/04/28/blender-hot-key/</id>
    <published>2021-04-28T03:09:11.000Z</published>
    <updated>2021-04-28T07:34:26.934Z</updated>
    
    <content type="html"><![CDATA[<p>文章参考：</p><p><a href="https://blog.csdn.net/u012204304/article/details/89030370">Blender2.9入门篇</a></p><hr><h1 id="模拟游戏引擎角色操作（第一人称视角）"><a href="#模拟游戏引擎角色操作（第一人称视角）" class="headerlink" title="模拟游戏引擎角色操作（第一人称视角）"></a>模拟游戏引擎角色操作（第一人称视角）</h1><p>快捷键：<code>Shift</code> + <code>~</code></p><p>在blender下面的状态栏会有操作按键提示。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>1、快捷键：<code>Ctrl</code> + <code>Tab</code></p><p>弹出模式选择导航，鼠标移动选择（也可以左上角点击下拉框选择）。</p><p>2、快捷键：<code>Tab</code></p><p>快速进入编辑模式，再按一次返回物体模式。</p><p>3、快捷键：<code>G</code></p><p>移动选中物体，左键确认，右键取消。</p><p>再点击<code>X</code>或<code>Y</code>或<code>Z</code>键，可沿对应轴水平移动。</p><p>按住鼠标中键，可以在xyz轴上，快速实现物体从一个轴跳到另一个轴，并且带上对原点的偏移量。</p><p>4、快捷键：<code>Alt</code>  + <code>G</code></p><p>物体位置回归原点(0,0,0)。</p><p>5、快捷键：<code>Shift</code> + <code>A</code></p><p>打开Add菜单。</p><p>6、快捷键：<code>Ctrl</code> + <code>N</code></p><p>打开New File菜单。</p><p>7、快捷键：长按<code>Shift</code> + 其他</p><p>微调操作，使得数值增值步长变小。</p><p>8、快捷键：<code>Shift</code> + <code>R</code></p><p>重复上一个命令。</p><p>9、快捷键：<code>Ctrl</code> + <code>Z</code></p><p>撤销操作。</p><p>10、快捷键：<code>F3</code></p><p>弹出操作搜索窗口。</p><p>11、快捷键：<code>F2</code></p><p>选中物体重命名。</p><p>12、快捷键：<code>Ctrl</code> + <code>Space</code></p><p>视图最大化（右侧停靠窗隐藏）。</p><p>13、快捷键：<code>Ctrl</code> + <code>Shift</code> + <code>Space</code></p><p>视图全屏。</p><p>14、快捷键：<code>Z</code></p><p>弹出着色方式选择导航，鼠标移动选择（也可以右上角点击选择）。</p><p>15、快捷键：<code>Shift</code> + <code>Z</code></p><p>线框显示和实体显示切换。</p><p>16、快捷键：<code>Ctrl</code> + <code>~</code></p><p>显示/隐藏Gizmo（视图右上角竖着排列的控件）。</p><p>17、快捷键：<code>鼠标中键</code> + <code>上下移动</code></p><p>自由切换视角。</p><p>18、快捷键：<code>Alt</code> + <code>鼠标中键</code> + <code>上下移动</code></p><p>切换六个正视角（顶、底、前、后、左、右）。</p><p>也可以用数字键盘来切换视角：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">切换到顶视角</td><td style="text-align:center"><code>7</code></td></tr><tr><td style="text-align:center">切换到底视角</td><td style="text-align:center"><code>Ctrl</code> + <code>7</code></td></tr><tr><td style="text-align:center">切换到前视角</td><td style="text-align:center"><code>1</code></td></tr><tr><td style="text-align:center">切换到后视角</td><td style="text-align:center"><code>Ctrl</code> + <code>1</code></td></tr><tr><td style="text-align:center">切换到右视角</td><td style="text-align:center"><code>3</code></td></tr><tr><td style="text-align:center">切换到左视角</td><td style="text-align:center"><code>Ctrl</code> + <code>3</code></td></tr><tr><td style="text-align:center">切换到摄像机视角</td><td style="text-align:center"><code>0</code></td></tr><tr><td style="text-align:center">正交视图和透视图切换</td><td style="text-align:center"><code>5</code></td></tr><tr><td style="text-align:center">四视图和透视图切换</td><td style="text-align:center"><code>Ctrl</code> + <code>Alt</code> + <code>Q</code></td></tr><tr><td style="text-align:center">上下旋转视角</td><td style="text-align:center"><code>8</code>或<code>2</code></td></tr><tr><td style="text-align:center">左右旋转视角</td><td style="text-align:center"><code>6</code>或<code>4</code></td></tr><tr><td style="text-align:center">视角旋转180°</td><td style="text-align:center"><code>9</code></td></tr></tbody></table></div><p>19、快捷键：<code>N</code></p><p>显示/隐藏视图右侧停靠窗口。</p><p>20、快捷键：<code>Shift</code> + <code>鼠标中键</code></p><p>自由移动视图。</p><p>21、快捷键：<code>H</code></p><p>隐藏选中项。</p><p>22、快捷键：<code>Shift</code> + <code>H</code></p><p>隐藏未选中项。</p><p>23、快捷键：<code>Alt</code> + <code>H</code></p><p>显示所有隐藏对象。</p><p>24、快捷键：数字键盘<code>/</code></p><p>居中放大选中对象，再次点击返回原来视角。</p><p>25、快捷键：数字键盘<code>.</code></p><p>居中放大选中对象，不会返回原来视角。</p><p>26、快捷键：<code>Home</code> 或者 <code>Shift</code> + <code>C</code></p><p>完整显示场景所有对象（被隐藏除外）。</p><p>27、快捷键：<code>Ctrl</code> + <code>A</code></p><p>打开Apply菜单。</p><p>28、快捷键：<code>T</code></p><p>显示/隐藏视图左侧工具菜单。</p><p>29、快捷键：<code>Shift</code> + <code>Space</code></p><p>打开工具菜单，跟视图左侧工具菜单一样。</p><p>30、快捷键：<code>Shift</code> + <code>鼠标右键</code></p><p>放置游标在鼠标位置。</p><p>31、快捷键：<code>Shift</code> + <code>C</code></p><p>将游标放在原点(0,0,0)。</p><p>32、快捷键：<code>Shift</code> + <code>S</code></p><p>打开游标菜单导航。</p><p>33、快捷键：<code>&lt;</code></p><p>变换坐标系。同样可在视图上方点击下拉框切换。</p><p>34、快捷键：<code>&gt;</code></p><p>变换轴心点。同样可在视图上方点击下拉框切换。</p><p>35、快捷键：<code>Shift</code> + <code>D</code></p><p>复制。</p><p>36、快捷键：<code>Alt</code> + <code>D</code></p><p>关联复制。</p><p>37、快捷键：<code>Ctrl</code> + <code>J</code></p><p>将选中的所有对象模型合并成一个对象模型。</p><p>38、快捷键：<code>W</code></p><p>框选、套索、圈选工具切换。</p><p>39、快捷键：<code>Ctrl</code> + <code>M</code> </p><p>镜像（反向翻转），需要再输入轴键（<code>X</code>或<code>Y</code>或<code>Z</code>）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012204304/article/details/89030370&quot;&gt;Blender2.9入门篇&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;模拟游戏引擎角色操作（第一人称视角）&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="blender" scheme="https://www.chaguake.com/categories/blender/"/>
    
    
    <category term="blender工具" scheme="https://www.chaguake.com/tags/blender%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL入门（四）——着色器</title>
    <link href="https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/"/>
    <id>https://www.chaguake.com/2021/04/22/OpenGL-introduction-04/</id>
    <published>2021-04-22T08:53:15.000Z</published>
    <updated>2021-04-23T02:03:07.418Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnopengl.com/Getting-started/Shaders">英文原文地址</a>    <a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">中文翻译地址</a></p><p>着色器（Shader）是运行在GPU上的小程序，用于图形渲染管线的某个特定部分。</p><p>而在OpenGL使用GLSL这一门着色器语言来实现着色器程序。</p><h2 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h2><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#version version_number</span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 处理输入并进行一些图形操作</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 输出处理过的结果到输出变量</span><br><span class="line">  out_variable_name &#x3D; weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>GLSL包含C语言大部分默认的基础数据类型。</p><p>向量是GLSL中比较常用的数据类型，常见的类型形式如下（n代表分量的数量）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">vecn</td><td style="text-align:center">包含n个float分量的默认向量</td></tr><tr><td style="text-align:center">bvecn</td><td style="text-align:center">包含n个bool分量的向量</td></tr><tr><td style="text-align:center">ivecn</td><td style="text-align:center">包含n个int分量的向量</td></tr><tr><td style="text-align:center">uvecn</td><td style="text-align:center">包含n个unsigned int分量的向量</td></tr><tr><td style="text-align:center">dvecn</td><td style="text-align:center">包含n个double分量的向量</td></tr></tbody></table></div><p>向量支持重组特性，一个向量的分量可以由其他的向量组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec2 vect &#x3D; vec2(0.1, 0.1)</span><br><span class="line">vec4 result &#x3D; vec4(vect, 0.0, 0.0)</span><br><span class="line">vec4 result2 &#x3D; vec4(result.xyz, 1.0)</span><br></pre></td></tr></table></figure><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>GLSL定义了<code>in</code>和<code>out</code>关键字实现着色器的输入和输出。</p><p>下面举个例子，顶点着色器接收一个3个分量的顶点位置向量，然后输出一个4个分量的顶点颜色向量，它会作为片段着色器的输入。</p><p>顶点着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos; &#x2F;&#x2F; 位置变量的属性位置值为0</span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; &#x2F;&#x2F; 为片段着色器指定一个颜色输出</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos, 1.0); &#x2F;&#x2F; 注意我们如何把一个vec3作为vec4的构造器的参数</span><br><span class="line">    vertexColor &#x3D; vec4(0.5, 0.0, 0.0, 1.0); &#x2F;&#x2F; 把输出变量设置为暗红色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; &#x2F;&#x2F; 从顶点着色器传来的输入变量（名称相同、类型相同）</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h2><p>uniform提供了从CPU应用程序向GPU着色器程序发送数据的能力。</p><p>并且，uniform变量是全局的，它必须在每个着色器程序对象中有且只有一个，并且它可以被着色器程序的任意着色器在任意阶段访问。</p><p>使用方法如下：</p><p>在片段着色器中定义uniform变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; &#x2F;&#x2F; 在OpenGL程序代码中设定这个变量</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor &#x3D; ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C/C++代码中，使用<code>glGetUniformLocation</code>函数获取该uniform变量，然后使用<code>glUniform4f</code>函数对其赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float timeValue &#x3D; glfwGetTime();</span><br><span class="line">float greenValue &#x3D; (sin(timeValue) &#x2F; 2.0f) + 0.5f;</span><br><span class="line">int vertexColorLocation &#x3D; glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</span><br></pre></td></tr></table></figure><p>值得注意的是，如果<code>glGetUniformLocation</code>返回-1就代表没有找到这个位置值。</p><p>而且，<code>glUniform4f</code>函数是属于设置uniform函数族中的一个，因为OpenGL底层是C库，不支持重载。</p><h2 id="传递多个属性"><a href="#传递多个属性" class="headerlink" title="传递多个属性"></a>传递多个属性</h2><p>在上面的例子中，只是传递了顶点位置的属性到顶点着色器上，那怎样才能传递多个属性呢？</p><p>首先，先给出顶点属性数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 位置              &#x2F;&#x2F; 颜色</span><br><span class="line">     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   &#x2F;&#x2F; 右下</span><br><span class="line">    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   &#x2F;&#x2F; 左下</span><br><span class="line">     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    &#x2F;&#x2F; 顶部</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再顶点着色器代码中接收多个输入，每个输入使用<code>(location = n)</code>来做绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location &#x3D; 0) in vec3 aPos;   &#x2F;&#x2F; 位置变量的属性位置值为 0 </span><br><span class="line">layout (location &#x3D; 1) in vec3 aColor; &#x2F;&#x2F; 颜色变量的属性位置值为 1</span><br><span class="line"></span><br><span class="line">out vec3 ourColor; &#x2F;&#x2F; 向片段着色器输出一个颜色</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position &#x3D; vec4(aPos, 1.0);</span><br><span class="line">    ourColor &#x3D; aColor; &#x2F;&#x2F; 将ourColor设置为我们从顶点数据那里得到的输入颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(location = n)</code>对应C/C++代码中<code>glVertexAttribPointer</code>函数的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 位置属性</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">&#x2F;&#x2F; 颜色属性</span><br><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));</span><br><span class="line">glEnableVertexAttribArray(1);</span><br></pre></td></tr></table></figure><p>给出顶点数据的存储结构图：</p><p><img src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt=""></p><p>最后输出结果如下：</p><p><img src="https://learnopengl-cn.github.io/img/01/05/shaders3.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnopengl.com/Getting-started/Shaders&quot;&gt;英文原文地址&lt;/a&gt;    &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/</summary>
      
    
    
    
    <category term="OpenGL" scheme="https://www.chaguake.com/categories/OpenGL/"/>
    
    
    <category term="OpenGL入门" scheme="https://www.chaguake.com/tags/OpenGL%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Go语言基础——函数、方法和接口</title>
    <link href="https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/"/>
    <id>https://www.chaguake.com/2021/04/21/Go-base-knowledge-02/</id>
    <published>2021-04-21T02:59:56.000Z</published>
    <updated>2021-04-21T07:20:07.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4-函数、方法和接口"><a href="#1-4-函数、方法和接口" class="headerlink" title="1.4 函数、方法和接口"></a>1.4 函数、方法和接口</h1><p>函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口定义了方法的集合。</p><p>Go语言通过隐式接口机制实现鸭子面向对象模型（所谓鸭子就是走路像鸭子，叫声像鸭子，那么它就可以当作鸭子）。</p><h2 id="1-4-1-函数"><a href="#1-4-1-函数" class="headerlink" title="1.4.1 函数"></a>1.4.1 函数</h2><p>函数是一个操作序列，可以把它赋值给变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;具名函数</span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var add &#x3D; Add</span><br><span class="line">add(1, 2)</span><br><span class="line">Add(1, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匿名函数</span><br><span class="line">var Add &#x3D; func(a, b int) &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add(1, 2)</span><br></pre></td></tr></table></figure><p>函数的参数和返回值可以有多个，支持可变参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Swap(a, b int) &#123;</span><br><span class="line">    return b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Sum(a int, more ...int) int &#123;</span><br><span class="line">    for _, v :&#x3D; range more &#123;</span><br><span class="line">        a +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum :&#x3D; Sum(1, []int&#123;2, 3&#125;...)</span><br></pre></td></tr></table></figure><p>可以给返回值命名，这样子返回值变量就可以在函数中使用，并且return语句可以不用带返回值（假如return语句带了变量，这是将变量赋值给返回值）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func Sum(a int, more ...int) (sum int) &#123;</span><br><span class="line">    sum +&#x3D; a</span><br><span class="line">    for _, v :&#x3D; range more &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defer关键字</strong></p><p>defer语句可以延迟执行一个函数，并且以栈的方式执行多个defer语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class="line">        defer func()&#123;fmt.Println(i)&#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Output:</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p><strong>Go语言中指针不是固定不变的</strong></p><p>Goroutine启动时只会分配很小的栈（4KB或8KB），在运行过程中才会不断扩充自己的栈空间，在增长过程中会拷贝之前的数据到新的内存空间。</p><p>并且，无法得知函数参数或局部变量到底是保存在栈中还是堆中。</p><h2 id="1-4-2-方法"><a href="#1-4-2-方法" class="headerlink" title="1.4.2 方法"></a>1.4.2 方法</h2><p>方法是关联类型的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (v *vType) Funcname() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var v vType</span><br><span class="line">v.Funcname()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方法表达式特性</strong></p><p>可以使用方法表达式将方法还原为普通函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;func Funcname(v *vType)()&#123;...&#125;</span><br><span class="line">var Func &#x3D; (*vType).Funcname</span><br><span class="line">Func(v)</span><br></pre></td></tr></table></figure><p><strong>方法的继承</strong></p><p>Go语言不支持传统面向对象中的继承特性，但可通过组合的方式支持方法的继承——通过在结构体内置匿名的成员来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &quot;image&#x2F;color&quot;</span><br><span class="line"></span><br><span class="line">type Point struct &#123; X, Y float64 &#125;</span><br><span class="line"></span><br><span class="line">type ColoredPoint struct &#123;</span><br><span class="line">    Point</span><br><span class="line">    Color color.RGBA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cp ColoredPoint</span><br><span class="line">cp.X &#x3D; 1</span><br><span class="line">cp.Point.X &#x3D; 2</span><br></pre></td></tr></table></figure><p>看似<code>cp.X</code>中<code>X</code>是属于<code>ColoredPoint</code>类型的，实际上<code>X</code>依旧是属于匿名成员<code>Point</code>的。因为在编译期间，<code>cp.X</code>会被展开成<code>cp.Point.X</code>。</p><h2 id="1-4-3-接口"><a href="#1-4-3-接口" class="headerlink" title="1.4.3 接口"></a>1.4.3 接口</h2><p>Go语言的接口类型是对其他类型行为的抽象和概括。而且，Go语言的借口类型是延迟绑定，可以实现类似虚函数的多态功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type UpperString string</span><br><span class="line"></span><br><span class="line">func (s UpperString) String() string &#123;</span><br><span class="line">    return strings.ToUpper(string(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">接口在fmt包中有定义：</span><br><span class="line">type fmt.Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Fprintln(os.Stdout, UpperString(&quot;hello, world&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言对接口类型的转换很灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a io.ReadCloser &#x3D; (*os.File)(f)&#x2F;&#x2F;隐式转换</span><br><span class="line">    b io.Reader &#x3D; a&#x2F;&#x2F;隐式转换</span><br><span class="line">    c io.Closer &#x3D; a&#x2F;&#x2F;隐式转换</span><br><span class="line">    d io.Reader &#x3D; c.(io.Reader)&#x2F;&#x2F;显式转换</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4-函数、方法和接口&quot;&gt;&lt;a href=&quot;#1-4-函数、方法和接口&quot; class=&quot;headerlink&quot; title=&quot;1.4 函数、方法和接口&quot;&gt;&lt;/a&gt;1.4 函数、方法和接口&lt;/h1&gt;&lt;p&gt;函数时一个操作序列，方法是绑定到一个具体类型的特殊函数，接口</summary>
      
    
    
    
    <category term="书籍" scheme="https://www.chaguake.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="《Go语言高级编程》" scheme="https://www.chaguake.com/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B/"/>
    
  </entry>
  
</feed>
